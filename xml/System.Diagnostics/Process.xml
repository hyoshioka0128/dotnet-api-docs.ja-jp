<Type Name="Process" FullName="System.Diagnostics.Process">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b42247a72a78d7b5984d2bf2c8a199b139c9a091" /><Meta Name="ms.sourcegitcommit" Value="5c332e8417c001736f7e2f33a84791feebba2cd7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="07/30/2019" /><Meta Name="ms.locfileid" Value="68632563" /></Metadata><TypeSignature Language="C#" Value="public class Process : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Process extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Process" />
  <TypeSignature Language="VB.NET" Value="Public Class Process&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Process : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type Process = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
      <AttributeName>System.ComponentModel.DefaultEvent("Exited")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
      <AttributeName>System.ComponentModel.DefaultProperty("StartInfo")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.MonitoringDescription("Provides access to local and remote processes, enabling starting and stopping of local processes.")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.MonitoringDescription("ProcessDesc")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=2.0.5.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>ローカル プロセスやリモート プロセスへのアクセスを提供し、ローカル システム プロセスの起動と停止ができるようにします。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process> コンポーネントは、コンピューターで実行されているプロセスへのアクセスを提供します。 プロセスとは、簡単に言えば実行中のアプリです。 スレッドは、オペレーティング システムがプロセッサ時間を割り当てる基本単位です。 スレッドは、別のスレッドによって実行されている部分を含む、プロセスのコードの任意の部分を実行できます。  
  
 <xref:System.Diagnostics.Process>コンポーネントは、アプリの起動、停止、制御、および監視を行うための便利なツールです。 <xref:System.Diagnostics.Process>コンポーネントを使用して、実行中のプロセスの一覧を取得したり、新しいプロセスを開始したりできます。 システム プロセスにアクセスするには、<xref:System.Diagnostics.Process> コンポーネントを使用します。 <xref:System.Diagnostics.Process>コンポーネントを初期化した後は、実行中のプロセスに関する情報を取得するために使用できます。 そのような情報には、スレッドのセットや、読み込まれたモジュール (.dll と .exe ファイル)、プロセスが使用しているメモリの量などのパフォーマンス情報が含まれます。  
  
 この型は <xref:System.IDisposable> インターフェイスを実装します。 型の使用が完了したら、直接的または間接的に型を破棄する必要があります。 直接的に型を破棄するには、`try` / `finally` ブロック内で <xref:System.IDisposable.Dispose%2A> メソッドを呼び出します。 間接的に型を破棄するには、`using` (C# の場合) または `Using` (Visual Basic 言語) などの言語構成要素を使用します。 詳細については、<xref:System.IDisposable> インターフェイスに関するトピック内の「IDisposable を実装するオブジェクトの使用」セクションを参照してください。  
  
> [!NOTE]
>  32 ビット プロセスは 64 ビット プロセスのモジュールにアクセスできません。 32 ビット プロセスから 64 ビット プロセスの詳細情報を取得しようとすると、<xref:System.ComponentModel.Win32Exception> 例外が発生します。 一方で、64 ビット プロセスは 32 ビット プロセスのモジュールにアクセスできます。  
  
 プロセス コンポーネントは、一度にすべてのプロパティのグループに関する情報を取得します。 <xref:System.Diagnostics.Process> コンポーネントは、いずれかのグループの 1 つのメンバーに関する情報を取得した後は、そのグループ内の他のプロパティの値をキャッシュします。そして、<xref:System.Diagnostics.Process.Refresh%2A> メソッドを呼び出すまで、そのグループの他のメンバーに関する新しい情報を取得しません。 そのため、プロパティ値は、最後の <xref:System.Diagnostics.Process.Refresh%2A> メソッドの呼び出しよりも新しい値を保証しません。 グループの内訳はオペレーティング システムに依存します。  
  
 システムでパス変数を引用符で囲んで宣言している場合、その場所で見つかるプロセスを開始するときに、そのパスを完全修飾する必要があります。 そうしないと、システムはそのパスを見つけられません。 たとえば、`c:\mypath` がパスに含まれておらず、それを `path = %path%;"c:\mypath"`` のように引用符を使用して追加した場合、`c:\mypath` 内の任意のプロセスを開始するときに、それを完全修飾する必要があります。  
  
 システム プロセスは、プロセス識別子によって、システムで一意に識別されます。 多くの Windows リソースと同様に、プロセスはそれのハンドルによっても識別されますが、ハンドルはコンピューター上で一意でない場合があります。 ハンドルはリソースの識別子の総称です。 プロセス ハンドルは、オペレーティング システムによって保持され、<xref:System.Diagnostics.Process.Handle%2A> コンポーネントの <xref:System.Diagnostics.Process> プロパティを通じてアクセスできます。 これはプロセスが終了した場合でもアクセスできます。これにより、<xref:System.Diagnostics.Process.ExitCode%2A> (通常は、成功を示す 0 か、0 以外のエラー コードのどちらかです) や <xref:System.Diagnostics.Process.ExitTime%2A> などの、プロセスの管理情報を取得できます。 ハンドルは非常に貴重なリソースなので、ハンドル リークはメモリ リークよりも有害です。  
  
> [!NOTE]
>  このクラスには、リンク確認要求と、すべてのメンバーに適用されるクラス レベルの継承確認要求が含まれています。 直接の呼び出し元か派生クラスのいずれかに完全信頼アクセス許可がない場合、<xref:System.Security.SecurityException> がスローされます。 セキュリティ要求の詳細については、「[リンク確認要求](~/docs/framework/misc/link-demands.md)」を参照してください。  
  
<a name="Core"></a>   
## <a name="includenetcoreincludesnet-core-mdmd-notes"></a>[!INCLUDE[net_core](~/includes/net-core-md.md)] での注意  
 .NET Framework では、既定では <xref:System.Diagnostics.Process> クラスは <xref:System.Console> のエンコードを使用します。これは、入力ストリーム、出力ストリーム、およびエラー ストリームについては、通常はコード ページ エンコードです。 コード例では、システムのカルチャが英語 (米国) で、コード ページ 437 が <xref:System.Console> クラスの既定のエンコードです。 しかし、[!INCLUDE[net_core](~/includes/net-core-md.md)] では、これらのエンコードの限られたサブセットしか使用できないことがあります。 その場合は、<xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> を既定のエンコードとして使用します。  
  
 <xref:System.Diagnostics.Process> オブジェクトが特定のコード ページ エンコードに依存している場合、<xref:System.Diagnostics.Process> のメソッドを呼び出す*前に*次の手順を行うと、特定のコード ページ エンコードも利用できます。  
  
1.  プロジェクトに、参照を追加して、コードページ...........................  
  
2.  <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType> プロパティから、<xref:System.Text.EncodingProvider> オブジェクトを取得します。  
  
3.  <xref:System.Text.EncodingProvider> オブジェクトを <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType> メソッドに渡すと、エンコーディング プロバイダーでサポートされているその他のエンコードを利用できるようになります。  
  
 <xref:System.Diagnostics.Process> のメソッドを呼び出す前にエンコーディング プロバイダーを登録していれば、<xref:System.Diagnostics.Process> クラスは、UTF8 ではなく既定のシステム エンコードを自動的に使用します。  
  
   
  
## Examples  
 次の例では、 <xref:System.Diagnostics.Process>クラスのインスタンスを使用してプロセスを開始します。  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 次の例では<xref:System.Diagnostics.Process> 、クラス自体と静的<xref:System.Diagnostics.Process.Start%2A>メソッドを使用してプロセスを開始します。  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 次F#の例では`runProc` 、プロセスを開始し、すべての出力とエラー情報をキャプチャし、プロセスが実行したミリ秒数を記録する関数を定義します。  関数`runProc`には、起動するアプリケーションの名前、アプリケーションに渡す引数、および開始ディレクトリという3つのパラメーターがあります。  
  
 [!code-fsharp[System.Diagnostics.Process#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.diagnostics.process/fs/Start1.fs#1)]  
  
 `runProc`関数のコードは[ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment)によって記述されており、 [Microsoft のパブリックライセンス](https://opensource.org/licenses/ms-pl)で入手できます。  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このクラスは、部分的に信頼されているコードでは使用できません。</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">継承に対する完全な信頼。 このクラスは、部分的に信頼されたコードによって継承することはできません。</permission>
    <altmember cref="M:System.Diagnostics.Process.Start" />
    <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
    <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
    <altmember cref="M:System.Diagnostics.Process.Kill" />
    <altmember cref="T:System.Diagnostics.ProcessThread" />
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/windowsdesktop/Using-the-NET-Process-Class-d70597ef">.NET Process クラスの使用</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Process ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Process();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Diagnostics.Process" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.MachineName%2A>プロパティを指定しない場合、既定値はローカルコンピューター (".") になります。  
  
 新しい<xref:System.Diagnostics.Process>コンポーネントをコンピューター上のプロセスと関連付けるには、2つのオプションがあります。 1つ目のオプションは、コンストラクターを使用し<xref:System.Diagnostics.Process>てコンポーネントを作成し、 <xref:System.Diagnostics.Process.StartInfo%2A>プロパティの適切なメンバー <xref:System.Diagnostics.Process.Start%2A>を設定<xref:System.Diagnostics.Process>し、を呼び出してを新しいシステムプロセスに関連付けます。 2つ目のオプションは、 <xref:System.Diagnostics.Process>またはいずれかの<xref:System.Diagnostics.Process.GetProcesses%2A>戻り値<xref:System.Diagnostics.Process.GetProcessById%2A>を使用して、を実行中のシステムプロセスに関連付けます。  
  
 メソッドのオーバーロードを`static`使用して新しいシステムプロセスを開始すると、メソッドによって新しい<xref:System.Diagnostics.Process>コンポーネントが作成され、プロセスに関連付けられます。 <xref:System.Diagnostics.Process.Start%2A>  
  
 プロパティが既定`true`値に設定されている場合は、Windows `Start`メニューの`Run`ダイアログボックスの場合と同様の方法でアプリケーションとドキュメントを開始できます。 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> が<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>の`false`場合は、実行可能ファイルのみを開始できます。  
  
 コマンドラインから呼び出すことができる実行可能ファイルは、次の2つの方法のいずれかで起動できます。 <xref:System.Diagnostics.Process.StartInfo%2A>プロパティの適切なメンバーを設定し、パラメーターを指定せずにメソッドを<xref:System.Diagnostics.Process.Start%2A>呼び出すか、または適切なパラメーターをに渡します。`static`メンバー 。<xref:System.Diagnostics.Process.Start%2A>  
  
 コンストラクター、静的<xref:System.Diagnostics.Process.Start%2A>オーバーロード<xref:System.Diagnostics.Process>のいずれか、 <xref:System.Diagnostics.Process.GetProcessById%2A>、 <xref:System.Diagnostics.Process.GetProcesses%2A>、、 <xref:System.Diagnostics.Process.GetProcessesByName%2A>のいずれかのメソッドを使用して、コンポーネントを作成できます。 完了すると、関連付けられているプロセスのビューが表示されます。 これは、プロセスのプロパティがメモリ内で変更されたときに自動的に更新される動的ビューではありません。 代わりに、コンポーネントのを<xref:System.Diagnostics.Process.Refresh%2A>呼び出して、アプリケーションの<xref:System.Diagnostics.Process>プロパティ情報を更新する必要があります。  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BasePriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BasePriority { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int" Usage="System.Diagnostics.Process.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Base process priority.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessBasePriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスの基本優先順位を取得します。</summary>
        <value>関連付けられたプロセスの <see cref="P:System.Diagnostics.Process.PriorityClass" /> から算出される基本優先順位。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロセス<xref:System.Diagnostics.Process.BasePriority%2A>のは、関連付けられたプロセス内で作成されるスレッドの開始優先順位です。 基本優先順位に関する情報は、システムモニターの優先順位ベースカウンターを使用して表示できます。  
  
 オペレーティングシステムは、経過時間またはその他のブーストに基づいて、プロセスを他のプロセスの前に配置する必要があるときに基本優先順位を変更できます。  
  
 <xref:System.Diagnostics.Process.BasePriority%2A>プロパティを使用すると、プロセスに割り当てられた開始優先度を表示できます。 ただし、読み取り専用であるため、を使用<xref:System.Diagnostics.Process.BasePriority%2A>してプロセスの優先順位を設定することはできません。 優先順位を変更するには<xref:System.Diagnostics.Process.PriorityClass%2A> 、プロパティを使用します。 はシステムモニター <xref:System.Diagnostics.Process.PriorityClass%2A>を使用して表示できますが、はでは表示されません。 <xref:System.Diagnostics.Process.BasePriority%2A> <xref:System.Diagnostics.Process.BasePriority%2A>とは<xref:System.Diagnostics.Process.PriorityClass%2A> 、どちらもプログラムによって表示できます。 次の表は、値と<xref:System.Diagnostics.Process.BasePriority%2A> <xref:System.Diagnostics.Process.PriorityClass%2A>値の間の関係を示しています。  
  
|BasePriority|PriorityClass|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 次の例では、メモ帳のインスタンスを起動します。 次に、この例では、関連付けられているプロセスのさまざまなプロパティを取得して表示します。 この例では、プロセスが終了したことを検出し、プロセスの終了コードを表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。Windows 98 や Windows Me でこのプロパティにアクセスするには <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> プロパティを <see langword="false" /> に設定します。</exception>
        <exception cref="T:System.InvalidOperationException">プロセスが終了しています。  
  
 または  
  
 プロセスが開始されていないため、プロセス ID はありません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
        <altmember cref="T:System.Diagnostics.ThreadPriorityLevel" />
      </Docs>
    </Member>
    <Member MemberName="BeginErrorReadLine">
      <MemberSignature Language="C#" Value="public void BeginErrorReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginErrorReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginErrorReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginErrorReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginErrorReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginErrorReadLine : unit -&gt; unit" Usage="process.BeginErrorReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アプリケーションのリダイレクトされた <see cref="P:System.Diagnostics.Process.StandardError" /> ストリームで、非同期読み取り操作を開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ストリーム<xref:System.Diagnostics.Process.StandardError%2A>は、同期的または非同期的に読み取ることができます。 、、などのメソッドは、プロセスのエラー出力ストリームに対して同期読み取り操作を実行します。<xref:System.IO.StreamReader.ReadToEnd%2A> <xref:System.IO.StreamReader.ReadLine%2A> <xref:System.IO.StreamReader.Read%2A> これらの同期読み取り操作は、関連付けら<xref:System.Diagnostics.Process>れている<xref:System.Diagnostics.Process.StandardError%2A>ストリームへの書き込みが完了するまで、またはストリームを閉じるまで完了しません。  
  
 これに対し<xref:System.Diagnostics.Process.BeginErrorReadLine%2A> <xref:System.Diagnostics.Process.StandardError%2A>て、は、ストリームに対して非同期の読み取り操作を開始します。 このメソッドは、ストリーム出力に対して指定されたイベントハンドラーを有効にし、すぐに呼び出し元に戻します。これにより、ストリーム出力がイベントハンドラーに送られている間に他の処理を実行できます。  
  
 に<xref:System.Diagnostics.Process.StandardError%2A>対して非同期の読み取り操作を実行するに<xref:System.Diagnostics.Process>は、次の手順に従います。  
  
1.  <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> を `false` に設定します。  
  
2.  <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> を `true` に設定します。  
  
3.  イベントにイベントハンドラーを<xref:System.Diagnostics.Process.ErrorDataReceived>追加します。 イベントハンドラーは、 <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType>デリゲートシグネチャと一致している必要があります。  
  
4.  を<xref:System.Diagnostics.Process>開始します。  
  
5.  <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> の<xref:System.Diagnostics.Process>を呼び出します。 この呼び出しは、で非同期読み取り<xref:System.Diagnostics.Process.StandardError%2A>操作を開始します。  
  
 非同期読み取り操作を開始すると、関連付けられている<xref:System.Diagnostics.Process>が<xref:System.Diagnostics.Process.StandardError%2A>ストリームにテキスト行を書き込むたびに、イベントハンドラーが呼び出されます。  
  
 を呼び出す<xref:System.Diagnostics.Process.CancelErrorRead%2A>ことによって、非同期の読み取り操作を取り消すことができます。 読み取り操作は、呼び出し元またはイベントハンドラーによって取り消すことができます。 をキャンセルした後、 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>を再度呼び出して、非同期の読み取り操作を再開できます。  
  
> [!NOTE]
>  リダイレクトされたストリームでは、非同期および同期読み取り操作を混在させることはできません。 の<xref:System.Diagnostics.Process>リダイレクトされたストリームを非同期モードまたは同期モードで開くと、そのストリームのすべての読み取り操作は同じモードである必要があります。 たとえば、 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> ストリーム<xref:System.Diagnostics.Process.StandardError%2A>でを<xref:System.IO.StreamReader.ReadLine%2A>呼び出すことはできません。また、逆の場合も同様です。 ただし、異なるモードの2つの異なるストリームを読み取ることができます。 たとえば、を呼び出し<xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 、 <xref:System.Diagnostics.Process.StandardOutput%2A>ストリームに対して<xref:System.IO.StreamReader.ReadLine%2A>を呼び出すことができます。  
  
   
  
## Examples  
 次の例では`net view` 、コマンドを使用して、リモートコンピューター上の使用可能なネットワークリソースを一覧表示します。 ユーザーは、ターゲットコンピューターの名前をコマンドライン引数として指定します。 ユーザーは、エラー出力のファイル名を指定することもできます。 この例では、net コマンドの出力を収集し、プロセスが終了するまで待機してから、出力結果をコンソールに書き込みます。 ユーザーがオプションのエラーファイルを指定した場合、この例ではエラーがファイルに書き込まれます。  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> プロパティが <see langword="false" /> である。  
  
または 
<see cref="P:System.Diagnostics.Process.StandardError" /> ストリームで非同期読み取り操作は既に実行されています。  
  
- または - 
<see cref="P:System.Diagnostics.Process.StandardError" /> ストリームは、同期読み取り操作によって使用されています。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
      </Docs>
    </Member>
    <Member MemberName="BeginOutputReadLine">
      <MemberSignature Language="C#" Value="public void BeginOutputReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginOutputReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginOutputReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginOutputReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginOutputReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginOutputReadLine : unit -&gt; unit" Usage="process.BeginOutputReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アプリケーションのリダイレクトされた <see cref="P:System.Diagnostics.Process.StandardOutput" /> ストリームで、非同期読み取り操作を開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ストリーム<xref:System.Diagnostics.Process.StandardOutput%2A>は、同期的または非同期的に読み取ることができます。 、、などのメソッドは、プロセスの出力ストリームに対して同期読み取り操作を実行します。<xref:System.IO.StreamReader.ReadToEnd%2A> <xref:System.IO.StreamReader.ReadLine%2A> <xref:System.IO.StreamReader.Read%2A> これらの同期読み取り操作は、関連付けら<xref:System.Diagnostics.Process>れている<xref:System.Diagnostics.Process.StandardOutput%2A>ストリームへの書き込みが完了するまで、またはストリームを閉じるまで完了しません。  
  
 これに対し<xref:System.Diagnostics.Process.BeginOutputReadLine%2A> <xref:System.Diagnostics.Process.StandardOutput%2A>て、は、ストリームに対して非同期の読み取り操作を開始します。 このメソッドは、ストリーム出力に対して指定されたイベントハンドラーを有効にし、すぐに呼び出し元に戻します。これにより、ストリーム出力がイベントハンドラーに送られている間に他の処理を実行できます。  
  
 に<xref:System.Diagnostics.Process.StandardOutput%2A>対して非同期の読み取り操作を実行するに<xref:System.Diagnostics.Process>は、次の手順に従います。  
  
1.  <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> を `false` に設定します。  
  
2.  <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> を `true` に設定します。  
  
3.  イベントにイベントハンドラーを<xref:System.Diagnostics.Process.OutputDataReceived>追加します。 イベントハンドラーは、 <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType>デリゲートシグネチャと一致している必要があります。  
  
4.  を<xref:System.Diagnostics.Process>開始します。  
  
5.  <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> の<xref:System.Diagnostics.Process>を呼び出します。 この呼び出しは、で非同期読み取り<xref:System.Diagnostics.Process.StandardOutput%2A>操作を開始します。  
  
 非同期読み取り操作を開始すると、関連付けられている<xref:System.Diagnostics.Process>が<xref:System.Diagnostics.Process.StandardOutput%2A>ストリームにテキスト行を書き込むたびに、イベントハンドラーが呼び出されます。  
  
 を呼び出す<xref:System.Diagnostics.Process.CancelOutputRead%2A>ことによって、非同期の読み取り操作を取り消すことができます。 読み取り操作は、呼び出し元またはイベントハンドラーによって取り消すことができます。 をキャンセルした後、 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>を再度呼び出して、非同期の読み取り操作を再開できます。  
  
> [!NOTE]
>  リダイレクトされたストリームでは、非同期および同期読み取り操作を混在させることはできません。 の<xref:System.Diagnostics.Process>リダイレクトされたストリームを非同期モードまたは同期モードで開くと、そのストリームのすべての読み取り操作は同じモードである必要があります。 たとえば、 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> ストリーム<xref:System.Diagnostics.Process.StandardOutput%2A>でを<xref:System.IO.StreamReader.ReadLine%2A>呼び出すことはできません。また、逆の場合も同様です。 ただし、異なるモードの2つの異なるストリームを読み取ることができます。 たとえば、を呼び出し<xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 、 <xref:System.Diagnostics.Process.StandardError%2A>ストリームに対して<xref:System.IO.StreamReader.ReadLine%2A>を呼び出すことができます。  
  
   
  
## Examples  
 次の例は、 <xref:System.Diagnostics.Process.StandardOutput%2A> `sort`コマンドのリダイレクトされたストリームで非同期の読み取り操作を実行する方法を示しています。 `sort`コマンドは、テキスト入力の読み取りと並べ替えを行うコンソールアプリケーションです。  
  
 この例では、イベントハンドラーの`SortOutputHandler`イベントデリゲートを作成し、イベント<xref:System.Diagnostics.Process.OutputDataReceived>に関連付けます。 イベントハンドラーは、リダイレクト<xref:System.Diagnostics.Process.StandardOutput%2A>されたストリームからテキスト行を受け取り、テキストを書式設定して、画面にテキストを書き込みます。  
  
 [!code-cpp[Process_AsyncStreams#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/sort_async.cpp#1)]
 [!code-csharp[Process_AsyncStreams#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/sort_async.cs#1)]
 [!code-vb[Process_AsyncStreams#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/sort_async.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> プロパティが <see langword="false" /> である。  
  
- または - 
<see cref="P:System.Diagnostics.Process.StandardOutput" /> ストリームで非同期読み取り操作は既に実行されています。  
  
- または - 
<see cref="P:System.Diagnostics.Process.StandardOutput" /> ストリームは、同期読み取り操作によって使用されています。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
      </Docs>
    </Member>
    <Member MemberName="CancelErrorRead">
      <MemberSignature Language="C#" Value="public void CancelErrorRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelErrorRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelErrorRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelErrorRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelErrorRead();" />
      <MemberSignature Language="F#" Value="member this.CancelErrorRead : unit -&gt; unit" Usage="process.CancelErrorRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アプリケーションのリダイレクトされた <see cref="P:System.Diagnostics.Process.StandardError" /> ストリームで、非同期読み取り操作をキャンセルします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A><xref:System.Diagnostics.Process.StandardError%2A>ストリームに対して非同期の読み取り操作を開始します。 <xref:System.Diagnostics.Process.CancelErrorRead%2A>非同期の読み取り操作を終了します。  
  
 をキャンセルした後、を再度呼び出し<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>て、非同期の読み取り操作を再開できます。  
  
 を呼び出す<xref:System.Diagnostics.Process.CancelErrorRead%2A>と、実行中のすべての<xref:System.Diagnostics.Process.StandardError%2A>読み取り操作が完了し、イベントハンドラーが無効になります。 以降にリダイレクトされる<xref:System.Diagnostics.Process.StandardError%2A>すべての出力は失われます。 の呼び出し<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>でイベントハンドラーを再び有効にすると、非同期の読み取り操作が再開されます。 非同期の読み取り操作を再開する前にイベントハンドラーを変更する場合は、新しいイベントハンドラーを追加する前に既存のイベントハンドラーを削除する必要があります。  
  
```csharp  
// At this point the DataReceivedEventHandler(ErrorHandler1)   
// has executed a CancelErrorRead.  
  
// Remove the prior event handler.  
process.ErrorDataReceived -=   
    new DataReceivedEventHandler(ErrorHandler1);  
  
// Register a new event handler.  
process.ErrorDataReceived +=   
    new DataReceivedEventHandler(ErrorHandler2);  
  
// Call the corresponding BeginErrorReadLine.  
process.BeginErrorReadLine();  
```  
  
> [!NOTE]
>  リダイレクト<xref:System.Diagnostics.Process.StandardError%2A>されたストリームには、非同期および同期読み取り操作を混在させることはできません。 の<xref:System.Diagnostics.Process>リダイレクトされたストリームを非同期モードまたは同期モードで開くと、そのストリームのすべての読み取り操作は同じモードである必要があります。 で非同期の<xref:System.Diagnostics.Process.StandardError%2A>読み取り操作をキャンセルしてから、再度ストリームから読み取る必要がある場合は、 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>を使用して非同期の読み取り操作を再開する必要があります。 <xref:System.Diagnostics.Process.CancelErrorRead%2A> <xref:System.Diagnostics.Process.StandardError%2A> 、 、<xref:System.IO.StreamReader.ReadLine%2A>などの同期読み取りメソッドを呼び出さないでください。<xref:System.IO.StreamReader.ReadToEnd%2A> <xref:System.IO.StreamReader.Read%2A>  
  
   
  
## Examples  
 次の例では`nmake` 、ユーザーが指定した引数を使用してコマンドを開始します。 エラーストリームと出力ストリームは非同期に読み込まれます。収集されたテキスト行は、コンソールに表示されるだけでなく、ログファイルに書き込まれます。 コマンドの出力が指定された行数を超えた場合、非同期の読み取り操作は取り消されます。  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.Process.StandardError" /> ストリームは、非同期読み取り操作では有効になっていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="CancelOutputRead">
      <MemberSignature Language="C#" Value="public void CancelOutputRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelOutputRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelOutputRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelOutputRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelOutputRead();" />
      <MemberSignature Language="F#" Value="member this.CancelOutputRead : unit -&gt; unit" Usage="process.CancelOutputRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アプリケーションのリダイレクトされた <see cref="P:System.Diagnostics.Process.StandardOutput" /> ストリームで、非同期読み取り操作をキャンセルします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A><xref:System.Diagnostics.Process.StandardOutput%2A>ストリームに対して非同期の読み取り操作を開始します。 <xref:System.Diagnostics.Process.CancelOutputRead%2A>非同期の読み取り操作を終了します。  
  
 をキャンセルした後、を再度呼び出し<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>て、非同期の読み取り操作を再開できます。  
  
 を呼び出す<xref:System.Diagnostics.Process.CancelOutputRead%2A>と、実行中のすべての<xref:System.Diagnostics.Process.StandardOutput%2A>読み取り操作が完了し、イベントハンドラーが無効になります。 以降に<xref:System.Diagnostics.Process.StandardOutput%2A>リダイレクトされるすべての出力は、バッファーに保存されます。 の呼び出し<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>を使用してイベントハンドラーを再度有効にすると、保存された出力がイベントハンドラーに送信され、非同期の読み取り操作が再開されます。 非同期の読み取り操作を再開する前にイベントハンドラーを変更する場合は、新しいイベントハンドラーを追加する前に既存のイベントハンドラーを削除する必要があります。  
  
```csharp  
// At this point the DataReceivedEventHandler(OutputHandler1)   
// has executed a CancelOutputRead.  
  
// Remove the prior event handler.  
process.OutputDataReceived -=   
    new DataReceivedEventHandler(OutputHandler1);  
  
// Register a new event handler.  
process.OutputDataReceived +=   
    new DataReceivedEventHandler(OutputHandler2);  
  
// Call the corresponding BeginOutputReadLine.  
process.BeginOutputReadLine();  
```  
  
> [!NOTE]
>  リダイレクト<xref:System.Diagnostics.Process.StandardOutput%2A>されたストリームには、非同期および同期読み取り操作を混在させることはできません。 の<xref:System.Diagnostics.Process>リダイレクトされたストリームを非同期モードまたは同期モードで開くと、そのストリームのすべての読み取り操作は同じモードである必要があります。 で非同期の<xref:System.Diagnostics.Process.StandardOutput%2A>読み取り操作をキャンセルしてから、再度ストリームから読み取る必要がある場合は、 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>を使用して非同期の読み取り操作を再開する必要があります。 <xref:System.Diagnostics.Process.CancelOutputRead%2A> <xref:System.Diagnostics.Process.StandardOutput%2A> 、 、<xref:System.IO.StreamReader.ReadLine%2A>などの同期読み取りメソッドを呼び出さないでください。<xref:System.IO.StreamReader.ReadToEnd%2A> <xref:System.IO.StreamReader.Read%2A>  
  
   
  
## Examples  
 次の例では`nmake` 、ユーザーが指定した引数を使用してコマンドを開始します。 エラーストリームと出力ストリームは非同期に読み込まれます。収集されたテキスト行は、コンソールに表示されるだけでなく、ログファイルに書き込まれます。 コマンドの出力が指定された行数を超えた場合、非同期の読み取り操作は取り消されます。  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.Process.StandardOutput" /> ストリームは、非同期読み取り操作では有効になっていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="process.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このコンポーネントに関連付けられているすべてのリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Close%2A>メソッドを使用すると、プロセスは待機している場合、終了の待機を停止し、プロセスハンドルを閉じて、プロセス固有のプロパティをクリアします。 <xref:System.Diagnostics.Process.Close%2A>は、外部で参照されている場合に、標準の出力、入力、およびエラーリーダーとライターを閉じません。  
  
> [!NOTE]
>  <xref:System.Diagnostics.Process.Dispose%2A> メソッドは <xref:System.Diagnostics.Process.Close%2A> を呼び出します。 ブロックにオブジェクトを配置すると、を呼び出す<xref:System.Diagnostics.Process.Close%2A>必要なくリソースが解放されます。 <xref:System.Diagnostics.Process> `using`  
  
   
  
## Examples  
 次の例では、メモ帳のインスタンスを起動します。 次に、関連付けられたプロセスの物理メモリ使用量を、最大で10秒間、2秒間隔で取得します。 この例では、10秒が経過する前にプロセスが終了するかどうかを検出します。 この例では、10秒後にプロセスがまだ実行されている場合、プロセスを終了します。  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="CloseMainWindow">
      <MemberSignature Language="C#" Value="public bool CloseMainWindow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CloseMainWindow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CloseMainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Function CloseMainWindow () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CloseMainWindow();" />
      <MemberSignature Language="F#" Value="member this.CloseMainWindow : unit -&gt; bool" Usage="process.CloseMainWindow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>メイン ウィンドウにクローズ メッセージを送信して、ユーザー インターフェイスがあるプロセスを終了します。</summary>
        <returns>クローズ メッセージが正常に送信された場合は <see langword="true" />。関連付けられたプロセスにメイン ウィンドウがない場合、またはメイン ウィンドウが使用できない場合 (モーダル ダイアログ ボックスが表示されているときなど) は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロセスが実行されると、そのメッセージループは待機状態になります。 メッセージループは、Windows メッセージがオペレーティングシステムによってプロセスに送信されるたびに実行されます。 を<xref:System.Diagnostics.Process.CloseMainWindow%2A>呼び出すと、メインウィンドウを閉じるための要求が送信されます。このウィンドウは、適切な形式のアプリケーションで、子ウィンドウを閉じ、アプリケーションに対して実行中のすべてのメッセージループを取り消します。 を呼び出し<xref:System.Diagnostics.Process.CloseMainWindow%2A>てプロセスを終了する要求では、アプリケーションの終了は強制されません。 アプリケーションは、終了する前にユーザーの確認を要求することも、終了を拒否することもできます。 アプリケーションを強制的に終了するには、 <xref:System.Diagnostics.Process.Kill%2A>メソッドを使用します。 の<xref:System.Diagnostics.Process.CloseMainWindow%2A>動作は、[システム] メニューを使用してアプリケーションのメインウィンドウを閉じるユーザーの動作と同じです。 そのため、メインウィンドウを閉じてプロセスを終了する要求では、アプリケーションが直ちに終了することはありません。  
  
 プロセスによって編集されたデータまたはプロセスに割り当てられた<xref:System.Diagnostics.Process.Kill%2A>リソースは、を呼び出すと失われることがあります。 <xref:System.Diagnostics.Process.Kill%2A>プロセスが異常終了する原因となり、必要な場合にのみ使用する必要があります。 <xref:System.Diagnostics.Process.CloseMainWindow%2A>プロセスの正常終了を有効にし、すべてのウィンドウを閉じます。そのため、インターフェイスを備えたアプリケーションに適しています。 が<xref:System.Diagnostics.Process.CloseMainWindow%2A>失敗した場合は<xref:System.Diagnostics.Process.Kill%2A> 、を使用してプロセスを終了できます。 <xref:System.Diagnostics.Process.Kill%2A>は、グラフィカルインターフェイスを持たないプロセスを終了する唯一の方法です。  
  
 は、 <xref:System.Diagnostics.Process.Kill%2A> <xref:System.Diagnostics.Process.CloseMainWindow%2A>ローカルコンピューターで実行されているプロセスに対してのみ呼び出すことができます。 リモートコンピューター上のプロセスを終了させることはできません。 リモートコンピューター上で実行されているプロセスの情報のみを表示できます。  
  
   
  
## Examples  
 次の例では、メモ帳のインスタンスを起動します。 次に、関連付けられたプロセスの物理メモリ使用量を2秒間隔で最大10秒間取得します。 この例では、10秒が経過する前にプロセスが終了するかどうかを検出します。 この例では、10秒後にプロセスがまだ実行されている場合、プロセスを終了します。  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。Windows 98 や Windows Me でこのプロパティにアクセスするには <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> プロパティを <see langword="false" /> に設定します。</exception>
        <exception cref="T:System.InvalidOperationException">プロセスは既に終了しています。  
  
- または - 
この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="process.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="process.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">マネージド リソースとアンマネージド リソースの両方を解放する場合は <see langword="true" />。アンマネージド リソースだけを解放する場合は <see langword="false" />。</param>
        <summary>このプロセスによって使用されているすべてのリソースを解放します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process component should watch for the associated process to exit, and raise the Exited event.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessEnableRaisingEvents")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロセスが終了したときに、<see cref="E:System.Diagnostics.Process.Exited" /> イベントを発生させるかどうかを取得または設定します。</summary>
        <value>正常終了または <see cref="M:System.Diagnostics.Process.Kill" /> の呼び出しによって関連付けられたプロセスが終了したときに <see cref="E:System.Diagnostics.Process.Exited" /> イベントを発生させる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。 の値が<see cref="E:System.Diagnostics.Process.Exited" /> <see cref="P:System.Diagnostics.Process.EnableRaisingEvents" /> <see cref="P:System.Diagnostics.Process.HasExited" />の場合、またはユーザーがチェックを実行する前にプロセスが終了した場合でも、イベントが発生することに注意してください。 <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
プロパティ<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>は、オペレーティングシステムがプロセスをシャットダウンしたときにコンポーネントに通知する必要があるかどうかを示します。 プロパティ<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>は、プロセスが終了したことをアプリケーションに通知するために、非同期処理で使用されます。 アプリケーションが終了イベント (終了イベントが発生するまでアプリケーションの処理を中断する) を同期的に待機するには、 <xref:System.Diagnostics.Process.WaitForExit%2A>メソッドを使用します。

> [!NOTE]
> Visual Studio を使用していて、プロジェクト内<xref:System.Diagnostics.Process>のコンポーネントをダブルクリックする<xref:System.Diagnostics.Process.Exited>と、イベントデリゲートとイベントハンドラーが自動的に生成されます。 追加のコードに<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>よって`false`、プロパティがに設定されます。 関連付けられたプロセスが`true`終了したときにイベントハンドラーが実行されるようにするには、このプロパティをに変更する必要があります。

コンポーネント<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>の値が`true`の場合、 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> または`false`がで、コンポーネントによってチェックが呼び出された場合、コンポーネントは、関連付けられているプロセスの管理情報にアクセスできます。<xref:System.Diagnostics.Process.HasExited%2A>オペレーティングシステムによって保存されます。 このような情報<xref:System.Diagnostics.Process.ExitTime%2A>には<xref:System.Diagnostics.Process.ExitCode%2A>、およびが含まれます。

関連付けられたプロセスが終了<xref:System.Diagnostics.Process.Handle%2A>すると、コンポーネントのは既存のプロセスリソースを参照しなくなります。 代わりに、プロセスリソースに関するオペレーティングシステムの情報にアクセスするためにのみ使用できます。 オペレーティングシステムは、コンポーネントによって<xref:System.Diagnostics.Process>解放されていないプロセスを終了するハンドルがあることを認識しているので、と<xref:System.Diagnostics.Process.Handle%2A>の<xref:System.Diagnostics.Process.ExitTime%2A>情報をメモリに保持します。

プロセスを終了するための監視に関連するコストが発生します。 が<xref:System.Diagnostics.Process.EnableRaisingEvents%2A> <xref:System.Diagnostics.Process.Exited>の場合、関連付けられたプロセスが終了するとイベントが発生します。 `true` <xref:System.Diagnostics.Process.Exited>イベントのプロシージャは、その時点で実行されます。

場合によっては、アプリケーションはプロセスを開始しますが、そのクロージャの通知は必要ありません。 たとえば、アプリケーションでメモ帳を起動して、ユーザーがテキスト編集を実行することを許可し、メモ帳アプリケーションをそれ以上使用しないようにすることができます。 プロセスが終了したときに通知されないようにすることもできます。これは、アプリケーションの継続操作には関係がないためです。 を<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>に`false`設定すると、システムリソースを節約できます。

## Examples  
次のコード例では、ファイルを出力するプロセスを作成します。 このメソッドは<xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 、プロパティを設定して、プロセス<xref:System.Diagnostics.Process.Exited>が終了時にイベントを発生させます。 イベント<xref:System.Diagnostics.Process.Exited>ハンドラーは、プロセス情報を表示します。

[!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]   
[!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]   
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
      </Docs>
    </Member>
    <Member MemberName="EnterDebugMode">
      <MemberSignature Language="C#" Value="public static void EnterDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnterDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.EnterDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnterDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnterDebugMode();" />
      <MemberSignature Language="F#" Value="static member EnterDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.EnterDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のスレッドのネイティブ プロパティ <see langword="SeDebugPrivilege" /> を有効にすることにより、<see cref="T:System.Diagnostics.Process" /> コンポーネントを、特殊なモードで実行されているオペレーティング システム プロセスと対話する状態にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一部のオペレーティングシステムプロセスは、特別なモードで実行されます。 コンポーネントでを呼び出し<xref:System.Diagnostics.Process.EnterDebugMode%2A>ていない限り、これらのプロセスのプロパティを読み取ろうとしたり、これらのプロセスにアタッチしたりすることはできません。 特別<xref:System.Diagnostics.Process.LeaveDebugMode%2A>なモードで実行されるこれらのプロセスにアクセスする必要がなくなったときに、を呼び出します。  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="M:System.Diagnostics.Process.LeaveDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="ErrorDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler ErrorDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler ErrorDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.ErrorDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ErrorDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ ErrorDataReceived;" />
      <MemberSignature Language="F#" Value="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessAssociated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションがリダイレクトされた <see cref="P:System.Diagnostics.Process.StandardError" /> ストリームに書き込む場合に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベント<xref:System.Diagnostics.Process.ErrorDataReceived>は、関連付けられたプロセスがリダイレクト<xref:System.Diagnostics.Process.StandardError%2A>されたストリームに書き込まれたことを示します。  
  
 イベントは、の<xref:System.Diagnostics.Process.StandardError%2A>非同期読み取り操作中にのみ発生します。 非同期<xref:System.Diagnostics.Process.StandardError%2A> <xref:System.Diagnostics.Process.ErrorDataReceived> の読み取り<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>操作を開始するには、のストリームをリダイレクトし、イベントにイベントハンドラーを追加して、を呼び出す必要があります。<xref:System.Diagnostics.Process> その後、 <xref:System.Diagnostics.Process.ErrorDataReceived>このイベントは、プロセスが終了するか、が呼び出さ<xref:System.Diagnostics.Process.StandardError%2A> <xref:System.Diagnostics.Process.CancelErrorRead%2A>れるまで、リダイレクトされたストリームに行が書き込まれるたびに通知します。  
  
> [!NOTE]
>  非同期出力を処理するアプリケーションでは、出力バッファー <xref:System.Diagnostics.Process.WaitForExit>がフラッシュされたことを確認するためにメソッドを呼び出す必要があります。 <xref:System.Diagnostics.Process.WaitForExit(System.Int32)>オーバーロードを使用してタイムアウトを指定しても、出力バッファーがフラッシュされて*いない*ことに注意してください。
  
   
  
## Examples  
 次の例では`net view` 、コマンドを使用して、リモートコンピューター上の使用可能なネットワークリソースを一覧表示します。 ユーザーは、ターゲットコンピューターの名前をコマンドライン引数として指定します。 ユーザーは、エラー出力のファイル名を指定することもできます。 この例では、net コマンドの出力を収集し、プロセスが終了するまで待機してから、出力結果をコンソールに書き込みます。 ユーザーがオプションのエラーファイルを指定した場合、この例ではエラーがファイルに書き込まれます。  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int" Usage="System.Diagnostics.Process.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The value returned from the associated process when it terminated.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExitCode")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスが終了したときにプロセスによって指定された値を取得します。</summary>
        <value>関連付けられたプロセスが終了したときにプロセスによって指定されたコード。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 システム<xref:System.Diagnostics.Process.ExitCode%2A>プロセスが終了したときに返された状態を取得するには、を使用します。 終了コードは、 `main()`プロシージャからの整数の戻り値と同じように使用できます。  
  
 プロセス<xref:System.Diagnostics.Process.ExitCode%2A>の値は、そのプロセスのアプリケーション開発者によって実装された特定の規則を反映しています。 終了コード値を使用してコード内で決定を行う場合は、アプリケーションプロセスで使用される終了コード規則がわかっていることを確認してください。  
  
 通常、開発者は、 <xref:System.Diagnostics.Process.ExitCode%2A>値0で終了が成功したことを示し、0以外の値でエラーを指定します。この値は、呼び出し元のメソッドが異常なプロセス終了の原因を識別するために使用できます。 これらのガイドラインに従う必要はありませんが、規則です。  
  
 プロセスが終了する<xref:System.Diagnostics.Process.ExitCode%2A>前にを取得しようとすると、例外がスローされます。 最初に<xref:System.Diagnostics.Process.HasExited%2A>プロパティを調べて、関連付けられているプロセスが終了したかどうかを確認します。  
  
> [!NOTE]
>  標準出力が非同期イベントハンドラーにリダイレクトされた場合、が返さ<xref:System.Diagnostics.Process.HasExited%2A> `true`れたときに出力処理が完了していない可能性があります。 非同期イベント処理が完了したことを確認するに<xref:System.Diagnostics.Process.WaitForExit>は、チェック<xref:System.Diagnostics.Process.HasExited%2A>する前にパラメーターを取らないオーバーロードを呼び出します。  
  
 <xref:System.Diagnostics.Process.CloseMainWindow%2A> また<xref:System.Diagnostics.Process.Kill%2A>はメソッドを使用して、関連付けられたプロセスを終了させることができます。  
  
 関連付けられたプロセスが終了すると、同期的かつ非同期的に通知される2つの方法があります。 同期通知は、関連する<xref:System.Diagnostics.Process.WaitForExit%2A>コンポーネントが終了するまで、アプリケーションの処理を一時停止するためにメソッドを呼び出すことに依存します。 非同期通知は<xref:System.Diagnostics.Process.Exited>イベントに依存します。 非同期通知を使用する<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>場合、 <xref:System.Diagnostics.Process>コンポーネントが`true`プロセスを終了したという通知を受け取るには、をに設定する必要があります。  
  
   
  
## Examples  
 次の例では、メモ帳のインスタンスを起動します。 次に、この例では、関連付けられているプロセスのさまざまなプロパティを取得して表示します。 この例では、プロセスが終了したことを検出し、プロセスの終了コードを表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">プロセスは終了していません。  
  
または 
プロセス <see cref="P:System.Diagnostics.Process.Handle" /> は終了していません。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行中のプロセスの <see cref="P:System.Diagnostics.Process.ExitCode" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
      </Docs>
    </Member>
    <Member MemberName="Exited">
      <MemberSignature Language="C#" Value="public event EventHandler Exited;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Exited" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.Exited" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exited As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Exited;" />
      <MemberSignature Language="F#" Value="member this.Exited : EventHandler " Usage="member this.Exited : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("If the WatchForExit property is set to true, then this event is raised when the associated process exits.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExited")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロセスが終了したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベント<xref:System.Diagnostics.Process.Exited>は、関連付けられたプロセスが終了したことを示します。 この現象は、プロセスが終了 (中止) されたか、または正常に終了したことを意味します。 このイベントは、 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A>プロパティの値がで`true`ある場合にのみ発生します。  
  
 関連付けられたプロセスが終了すると、同期的かつ非同期的に通知される2つの方法があります。 同期通知とは、 <xref:System.Diagnostics.Process.WaitForExit%2A>プロセスが終了するまで、メソッドを呼び出して現在のスレッドをブロックすることを意味します。 非同期通知では<xref:System.Diagnostics.Process.Exited> 、イベントを使用します。これにより、呼び出し元のスレッドは、その間に実行を継続できます。 後者の場合、を<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>呼び出し元のアプリケーション`true`が終了イベントを受け取るには、をに設定する必要があります。  
  
 オペレーティングシステムは、プロセスをシャットダウンすると、終了したイベントに対してハンドラーが登録されている他のすべてのプロセスに通知します。 この時点で、終了したばかりのプロセスのハンドルを使用して、など<xref:System.Diagnostics.Process.ExitTime%2A>のいくつかのプロパティにアクセスできます。また<xref:System.Diagnostics.Process.HasExited%2A> 、オペレーティングシステムはそのハンドルを完全に解放するまで保持します。  
  
> [!NOTE]
>  終了したプロセスをハンドルする場合でも、を再度呼び出し<xref:System.Diagnostics.Process.Start%2A>て同じプロセスに再接続することはできません。 を<xref:System.Diagnostics.Process.Start%2A>呼び出すと、関連付けられているプロセスが自動的に解放され、 <xref:System.Diagnostics.Process.Handle%2A>同じファイルを持つプロセスに接続されますが、まったく新しいプロセスになります。  
  
 Windows フォームアプリケーションで<xref:System.Diagnostics.Process.Exited>イベントを使用する方法の詳細については、 <xref:System.Diagnostics.Process.SynchronizingObject%2A> 「」プロパティを参照してください。  
  
   
  
## Examples  
 次のコード例では、ファイルを出力するプロセスを作成します。 プロセスの作成<xref:System.Diagnostics.Process.Exited>時に<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>プロパティが設定されていたため、プロセスが終了したときにイベントを発生させます。 イベント<xref:System.Diagnostics.Process.Exited>ハンドラーは、プロセス情報を表示します。  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="ExitTime">
      <MemberSignature Language="C#" Value="public DateTime ExitTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExitTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExitTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitTime : DateTime" Usage="System.Diagnostics.Process.ExitTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The time that the associated process exited.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExitTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスが終了した時刻を取得します。</summary>
        <value>関連付けられたプロセスが終了した時刻を示す <see cref="T:System.DateTime" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロセスが終了していない場合、 <xref:System.Diagnostics.Process.ExitTime%2A>プロパティを取得しようとすると例外がスローされます。 プロパティ<xref:System.Diagnostics.Process.ExitTime%2A>を取得する前にを使用<xref:System.Diagnostics.Process.HasExited%2A>して、関連付けられたプロセスが終了したかどうかを確認します。  
  
   
  
## Examples  
 次のコード例では、ファイルを出力するプロセスを作成します。 プロセスは、終了<xref:System.Diagnostics.Process.Exited>時にイベントを発生<xref:System.Diagnostics.Process.ExitTime%2A>させ、イベントハンドラーはプロパティとその他のプロセス情報を表示します。  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行中のプロセスの <see cref="P:System.Diagnostics.Process.ExitTime" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcess">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetCurrentProcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetCurrentProcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetCurrentProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcess () As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetCurrentProcess();" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcess : unit -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetCurrentProcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントを取得し、現在アクティブなプロセスに関連付けます。</summary>
        <returns>呼び出し元のアプリケーションを実行しているプロセス リソースに関連付けられた新しい <see cref="T:System.Diagnostics.Process" /> コンポーネント。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、 <xref:System.Diagnostics.Process>新しいインスタンスを作成し、ローカルコンピューター上のプロセスリソースに関連付けます。  
  
 同様<xref:System.Diagnostics.Process.GetProcessById%2A>の、 <xref:System.Diagnostics.Process.GetProcessesByName%2A>、および<xref:System.Diagnostics.Process.GetProcesses%2A>メソッドと同様<xref:System.Diagnostics.Process.GetCurrentProcess%2A>に、は既存のリソースを<xref:System.Diagnostics.Process>新しいコンポーネントに関連付けます。  
  
   
  
## Examples  
 次の例では、現在のプロセス、ローカルコンピューター上で実行されているプロセス、ローカルコンピューター上で実行されているメモ帳のすべてのインスタンス、およびローカルコンピューター上の特定のプロセスの情報を取得します。 次に、リモートコンピューター上の同じプロセスの情報を取得します。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessById">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントを作成し、指定した既存のプロセス リソースに関連付けます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById processId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="processId">システムで一意なプロセス リソースの識別子。</param>
        <summary>ローカル コンピューター上のプロセス ID が指定された新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントを返します。</summary>
        <returns><paramref name="processId" /> パラメーターで識別されるローカル プロセス リソースに関連付けられた <see cref="T:System.Diagnostics.Process" /> コンポーネント。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、 <xref:System.Diagnostics.Process>新しいコンポーネントを作成し、ローカルコンピューター上のプロセスリソースに関連付けます。 プロセスリソースはコンピューターに既に存在している<xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29>必要があります。ではシステムリソースが作成されず、リソースが<xref:System.Diagnostics.Process>アプリケーションで生成されたコンポーネントに関連付けられるためです。 プロセス<xref:System.Diagnostics.Process.Id%2A>は、コンピューターで現在実行されているプロセスに対してのみ取得できます。 プロセスが終了した<xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29>後で、期限切れの識別子を渡すと、は例外をスローします。  
  
 特定のコンピューターでは、プロセスの識別子は一意です。 <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29>1つのプロセスを返します。 特定のアプリケーションを実行しているすべてのプロセスを取得する<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>場合は、を使用します。 指定したアプリケーションを実行しているコンピューターに複数<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>のプロセスが存在する場合、は、関連付けられているすべてのプロセスを含む配列を返します。 これらの各プロセスに対して、その識別子に対してクエリを実行できます。 プロセス識別子は、Windows タスクマネージャーの`Processes`パネルで表示できます。 列`PID`には、プロセスに割り当てられているプロセス識別子が表示されます。  
  
 パラメーターは (32 ビット符号付き整数) です。ただし、基になる Windows API は、 `DWORD` (符号なし32ビット整数) を使用して類似の api を使用します。 <xref:System.Int32> `processId` これは、歴史的な理由によるものです。
  
## Examples  
 次の例では、現在のプロセス、ローカルコンピューター上で実行されているプロセス、ローカルコンピューター上で実行されているメモ帳のすべてのインスタンス、およびローカルコンピューター上の特定のプロセスの情報を取得します。 次に、リモートコンピューター上の同じプロセスの情報を取得します。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="processId" /> パラメーターで指定されたプロセスは実行されていません。 識別子の有効期限が切れている可能性があります。</exception>
        <exception cref="T:System.InvalidOperationException">このオブジェクトによってプロセスは開始されませんでした。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer, machineName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById (processId, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processId">システムで一意なプロセス リソースの識別子。</param>
        <param name="machineName">ネットワーク上のコンピューターの名前。</param>
        <summary>プロセス ID とネットワーク上のコンピューターの名前が指定された新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントを返します。</summary>
        <returns><paramref name="processId" /> パラメーターで識別されるリモート プロセス リソースに関連付けられた <see cref="T:System.Diagnostics.Process" /> コンポーネント。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、 <xref:System.Diagnostics.Process>新しいコンポーネントを作成し、ネットワーク上のリモートコンピューター上のプロセスリソースに関連付けます。 プロセスリソースは、指定されたコンピューターに既に<xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29>存在している必要があります。では、システムリソースは作成さ<xref:System.Diagnostics.Process>れず、リソースがアプリケーションによって生成されるコンポーネントに関連付けられるためです。 プロセス<xref:System.Diagnostics.Process.Id%2A>は、コンピューターで現在実行されているプロセスに対してのみ取得できます。 プロセスが終了した<xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29>後で、期限切れの識別子を渡すと、は例外をスローします。  
  
 特定のコンピューターでは、プロセスの識別子は一意です。 <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29>1つのプロセスを返します。 特定のアプリケーションを実行しているすべてのプロセスを取得する<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>場合は、を使用します。 指定したアプリケーションを実行しているコンピューターに複数<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>のプロセスが存在する場合、は、関連付けられているすべてのプロセスを含む配列を返します。 これらの各プロセスに対して、その識別子に対してクエリを実行できます。 プロセス識別子は、Windows タスクマネージャーの`Processes`パネルで表示できます。 列`PID`には、プロセスに割り当てられているプロセス識別子が表示されます。  
  
 を指定`machineName`しない場合は、ローカルコンピューターが使用されます。 または、を値 "." に、 `machineName`または空の文字列 ("") に設定して、ローカルコンピューターを指定することもできます。  
  
 パラメーターは (32 ビット符号付き整数) です。ただし、基になる Windows API は、 `DWORD` (符号なし32ビット整数) を使用して類似の api を使用します。 <xref:System.Int32> `processId` これは、歴史的な理由によるものです。   
  
## Examples  
 次の例では、現在のプロセス、ローカルコンピューター上で実行されているプロセス、ローカルコンピューター上で実行されているメモ帳のすべてのインスタンス、およびローカルコンピューター上の特定のプロセスの情報を取得します。 次に、リモートコンピューター上の同じプロセスの情報を取得します。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="processId" /> パラメーターで指定されたプロセスは実行されていません。 識別子の有効期限が切れている可能性があります。  
  
または 
<paramref name="machineName" /> パラメーターの構文が正しくありません。 名前の長さがゼロ (0) の可能性があります。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="machineName" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">このオブジェクトによってプロセスは開始されませんでした。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcesses">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントの配列を作成し、既存のプロセス リソースに関連付けます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses () As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses();" />
      <MemberSignature Language="F#" Value="static member GetProcesses : unit -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ローカル コンピューター上の各プロセス リソースごとに新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントを作成します。</summary>
        <returns>ローカル コンピューター上で実行されているすべてのプロセス リソースを表す <see cref="T:System.Diagnostics.Process" /> 型の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、新しい<xref:System.Diagnostics.Process>コンポーネントの配列を作成し、ローカルコンピューター上のすべてのプロセスリソースに関連付けます。 プロセスリソースは、ローカルコンピューターに既に存在して<xref:System.Diagnostics.Process.GetProcesses%2A>いる必要があります。は、システムリソースを作成する<xref:System.Diagnostics.Process>のではなく、アプリケーションによって生成されるコンポーネントにリソースを関連付けるためです。 オペレーティングシステム自体がバックグラウンドプロセスを実行しているため、この配列は空になりません。  
  
 コンピューター上で実行されているすべてのプロセスを取得しない場合<xref:System.Diagnostics.Process.GetProcessById%2A>は、メソッドまたは<xref:System.Diagnostics.Process.GetProcessesByName%2A>メソッドを使用して、その番号を制限できます。 <xref:System.Diagnostics.Process.GetProcessById%2A>メソッドに<xref:System.Diagnostics.Process>渡すプロセス識別子によってシステムで識別されるプロセスに関連付けられたコンポーネントを作成します。 <xref:System.Diagnostics.Process.GetProcessesByName%2A>関連付けられた<xref:System.Diagnostics.Process>プロセスリソースが、メソッドに渡す実行可能ファイルを共有するコンポーネントの配列を作成します。  
  
> [!NOTE]
>  サービスホストプロセス (svchost.exe) の同じインスタンス内に複数の Windows サービスを読み込むことができます。 GetProcesses は、これらの個々のサービスを識別しません。詳細について<xref:System.ServiceProcess.ServiceController.GetServices%2A>は、「」を参照してください。  
  
   
  
## Examples  
 次の例では、現在のプロセス、ローカルコンピューター上で実行されているプロセス、ローカルコンピューター上で実行されているメモ帳のすべてのインスタンス、およびローカルコンピューター上の特定のプロセスの情報を取得します。 次に、リモートコンピューター上の同じプロセスの情報を取得します。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses (machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcesses : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">プロセスの一覧を読み取る対象のコンピューター。</param>
        <summary>指定したコンピューター上の各プロセス リソースごとに新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントを作成します。</summary>
        <returns>指定したコンピューター上で実行されているすべてのプロセス リソースを表す <see cref="T:System.Diagnostics.Process" /> 型の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、新しい<xref:System.Diagnostics.Process>コンポーネントの配列を作成し、指定した (通常はリモートの) コンピューター上のすべてのプロセスリソースに関連付けます。 プロセスリソースは、ローカルコンピューターに既に存在して<xref:System.Diagnostics.Process.GetProcesses%2A>いる必要があります。は、システムリソースを作成する<xref:System.Diagnostics.Process>のではなく、アプリケーションによって生成されるコンポーネントにリソースを関連付けるためです。 オペレーティングシステム自体がバックグラウンドプロセスを実行しているため、この配列は空になりません。  
  
 コンピューター上で実行されているすべてのプロセスを取得しない場合<xref:System.Diagnostics.Process.GetProcessById%2A>は、メソッドまたは<xref:System.Diagnostics.Process.GetProcessesByName%2A>メソッドを使用して、その番号を制限できます。 <xref:System.Diagnostics.Process.GetProcessById%2A>メソッドに<xref:System.Diagnostics.Process>渡すプロセス識別子によってシステムで識別されるプロセスに関連付けられたコンポーネントを作成します。 <xref:System.Diagnostics.Process.GetProcessesByName%2A>関連付けられた<xref:System.Diagnostics.Process>プロセスリソースが、メソッドに渡す実行可能ファイルを共有するコンポーネントの配列を作成します。  
  
 この<xref:System.Diagnostics.Process.GetProcesses%2A>メソッドのこのオーバーロードは、通常、ネットワーク上のリモートコンピューター上で実行されているプロセスリソースの一覧を取得するために使用されますが、"." を渡すことによってローカルコンピューターを指定することもできます。  
  
> [!NOTE]
>  サービスホストプロセス (svchost.exe) の同じインスタンス内に複数の Windows サービスを読み込むことができます。 GetProcesses は、これらの個々のサービスを識別しません。詳細について<xref:System.ServiceProcess.ServiceController.GetServices%2A>は、「」を参照してください。  
  
   
  
## Examples  
 次の例では、現在のプロセス、ローカルコンピューター上で実行されているプロセス、ローカルコンピューター上で実行されているメモ帳のすべてのインスタンス、およびローカルコンピューター上の特定のプロセスの情報を取得します。 次に、リモートコンピューター上の同じプロセスの情報を取得します。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> パラメーターの構文が正しくありません。 長さがゼロ (0) の可能性があります。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="machineName" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.PlatformNotSupportedException">リモート コンピューターに対してこの操作を実行することは、オペレーティング システム プラットフォームでサポートされていません。</exception>
        <exception cref="T:System.InvalidOperationException">プロセス情報を取得するために使用するパフォーマンス カウンター API へのアクセスに問題があります。 この例外は、Windows NT、Windows 2000、および Windows XP に固有のものです。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">基になるシステム API にアクセスしようとして、問題が発生しました。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessesByName">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントの配列を作成し、指定したプロセス名を共有する既存のプロセス リソースに関連付けます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName processName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">プロセスのフレンドリ名。</param>
        <summary>新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントの配列を作成し、指定したプロセス名を共有するローカル コンピューター上のすべてのプロセス リソースに関連付けます。</summary>
        <returns>指定したアプリケーションまたはファイルを実行しているプロセス リソースを表す <see cref="T:System.Diagnostics.Process" /> 型の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、新しい<xref:System.Diagnostics.Process>コンポーネントの配列を作成し、ローカルコンピューター上で同じ実行可能ファイルを実行しているすべてのプロセスリソースに関連付けます。 プロセスリソースはコンピューターに既に存在している<xref:System.Diagnostics.Process.GetProcessesByName%2A>必要があります。では、システムリソースは作成さ<xref:System.Diagnostics.Process>れず、アプリケーションによって生成されるコンポーネントに関連付けられるためです。 は`processName` 、ローカルコンピューターで現在実行されていない実行可能ファイルに対して指定できます。そのため、メソッドが返す配列は空にすることができます。  
  
 プロセス名は、Outlook などのプロセスのフレンドリ名です。この名前には、.exe 拡張子やパスは含まれません。 <xref:System.Diagnostics.Process.GetProcessesByName%2A>は、同じ実行可能ファイルに関連付けられているすべてのプロセスを取得して操作する場合に役立ちます。 たとえば、実行可能ファイルの実行中のすべてのインスタンス`processName`をシャットダウンするために、実行可能ファイル名をパラメーターとして渡すことができます。  
  
 プロセス<xref:System.Diagnostics.Process.Id%2A>はシステム上の1つのプロセスリソースに対して一意ですが、ローカルコンピューター上の複数のプロセスで、 `processName`パラメーターによって指定されたアプリケーションを実行できます。 したがって<xref:System.Diagnostics.Process.GetProcessById%2A> 、は、最大で1つ<xref:System.Diagnostics.Process.GetProcessesByName%2A>のプロセスを返しますが、関連付けられているすべてのプロセスを含む配列を返します。 標準 API 呼び出しを使用してプロセスを操作する必要がある場合は、その識別子に対してこれらの各プロセスを順番にクエリできます。 プロセスリソースにはプロセス名だけではアクセスできませんが、プロセスリソースに関連<xref:System.Diagnostics.Process>付けられているコンポーネントの配列を取得した後は、システムリソースを開始、終了、または操作することができます。  
  
   
  
## Examples  
 次の例では、現在のプロセス、ローカルコンピューター上で実行されているプロセス、ローカルコンピューター上で実行されているメモ帳のすべてのインスタンス、およびローカルコンピューター上の特定のプロセスの情報を取得します。 次に、リモートコンピューター上の同じプロセスの情報を取得します。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">プロセス情報を取得するために使用するパフォーマンス カウンター API へのアクセスに問題があります。 この例外は、Windows NT、Windows 2000、および Windows XP に固有のものです。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String, machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string * string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName (processName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">プロセスのフレンドリ名。</param>
        <param name="machineName">ネットワーク上のコンピューターの名前。</param>
        <summary>新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントの配列を作成し、指定したプロセス名を共有するリモート コンピューター上のすべてのプロセス リソースに関連付けます。</summary>
        <returns>指定したアプリケーションまたはファイルを実行しているプロセス リソースを表す <see cref="T:System.Diagnostics.Process" /> 型の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、新しい<xref:System.Diagnostics.Process>コンポーネントの配列を作成し、指定したコンピューター上で同じ実行可能ファイルを実行しているすべてのプロセスリソースに関連付けます。 プロセスリソースはコンピューターに既に存在している<xref:System.Diagnostics.Process.GetProcessesByName%2A>必要があります。では、システムリソースは作成さ<xref:System.Diagnostics.Process>れず、アプリケーションによって生成されるコンポーネントに関連付けられるためです。 は`processName` 、ローカルコンピューターで現在実行されていない実行可能ファイルに対して指定できます。そのため、メソッドが返す配列は空にすることができます。  
  
 プロセス名は、Outlook などのプロセスのフレンドリ名です。この名前には、.exe 拡張子やパスは含まれません。 <xref:System.Diagnostics.Process.GetProcessesByName%2A>は、同じ実行可能ファイルに関連付けられているすべてのプロセスを取得して操作する場合に役立ちます。 たとえば、実行可能ファイルの実行中のすべてのインスタンス`processName`をシャットダウンするために、実行可能ファイル名をパラメーターとして渡すことができます。  
  
 プロセス<xref:System.Diagnostics.Process.Id%2A>はシステム上の1つのプロセスリソースに対して一意ですが、ローカルコンピューター上の複数のプロセスで、 `processName`パラメーターによって指定されたアプリケーションを実行できます。 したがって<xref:System.Diagnostics.Process.GetProcessById%2A> 、は、最大で1つ<xref:System.Diagnostics.Process.GetProcessesByName%2A>のプロセスを返しますが、関連付けられているすべてのプロセスを含む配列を返します。 標準 API 呼び出しを使用してプロセスを操作する必要がある場合は、その識別子に対してこれらの各プロセスを順番にクエリできます。 プロセスリソースにはプロセス名だけではアクセスできませんが、プロセスリソースに関連<xref:System.Diagnostics.Process>付けられているコンポーネントの配列を取得した後は、システムリソースを開始、終了、または操作することができます。  
  
 このオーバーロードを使用して、ローカルコンピューターおよびリモートコンピューター上のプロセスを取得できます。 "." を使用してローカルコンピューターを指定します。 既定では、ローカルコンピューターを使用する別のオーバーロードが存在します。  
  
 リモートコンピューター上のプロセスには、プロセスに関する統計情報などの情報を表示するためだけにアクセスできます。 リモートコンピューターでプロセスを終了、 <xref:System.Diagnostics.Process.Kill%2A>終了 (使用)、または開始することはできません。  
  
   
  
## Examples  
 次の例では、現在のプロセス、ローカルコンピューター上で実行されているプロセス、ローカルコンピューター上で実行されているメモ帳のすべてのインスタンス、およびローカルコンピューター上の特定のプロセスの情報を取得します。 次に、リモートコンピューター上の同じプロセスの情報を取得します。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> パラメーターの構文が正しくありません。 長さがゼロ (0) の可能性があります。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="machineName" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.PlatformNotSupportedException">リモート コンピューターに対してこの操作を実行することは、オペレーティング システム プラットフォームでサポートされていません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="machineName" /> に接続する試みが失敗しました。

または 
プロセス情報を取得するために使用するパフォーマンス カウンター API へのアクセスに問題があります。 この例外は、Windows NT、Windows 2000、および Windows XP に固有のものです。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">基になるシステム API にアクセスしようとして、問題が発生しました。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージコードを呼び出す。 関連付けられた列挙型:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Diagnostics.Process.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Returns the native handle for this process.   The handle is only available if the process was started using this component.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスのネイティブ ハンドルを取得します。</summary>
        <value>関連付けられたプロセスを起動したときに、オペレーティング システムがプロセスに割り当てたハンドル。 システムはこのハンドルを使用して、プロセス属性の追跡を続けます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アプリケーションは、多くのプロセス情報および制御関数のパラメーターとして使用できるプロセスのハンドルを取得できます。 このハンドルを使用すると、を<xref:System.Threading.WaitHandle>初期化したり、プラットフォーム呼び出しを使用してネイティブメソッドを呼び出すことができます。  
  
 このプロセスハンドルはアプリケーションに対してプライベートです。つまり、プロセスハンドルを共有することはできません。 プロセスには、とは<xref:System.Diagnostics.Process.Id%2A> <xref:System.Diagnostics.Process.Handle%2A>異なり、システム全体で有効なプロセスもあります。  
  
 呼び出しによって開始され<xref:System.Diagnostics.Process.Start%2A>たプロセス<xref:System.Diagnostics.Process.Handle%2A>のみが、対応<xref:System.Diagnostics.Process>するインスタンスのプロパティを設定します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">プロセスが開始されていないか、終了しました。 この <see cref="T:System.Diagnostics.Process" /> インスタンスにプロセスが関連付けられていないので、<see cref="P:System.Diagnostics.Process.Handle" /> プロパティを読み取ることができません。  
  
または 
<see cref="T:System.Diagnostics.Process" /> インスタンスは実行中のプロセスにアタッチされていますが、フル アクセス権を持つハンドルを取得するために必要なアクセス許可がありません。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行中のプロセスの <see cref="P:System.Diagnostics.Process.Handle" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HandleCount" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="HandleCount">
      <MemberSignature Language="C#" Value="public int HandleCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HandleCount" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HandleCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HandleCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int HandleCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.HandleCount : int" Usage="System.Diagnostics.Process.HandleCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Handles for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessHandleCount")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロセスが開いたハンドルの数を取得します。</summary>
        <value>プロセスが開いたオペレーティング システム ハンドルの数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ハンドルは、プロセスがオブジェクトを参照する方法を提供します。 プロセスでは、ファイル、リソース、メッセージキューなどのさまざまなオペレーティングシステムオブジェクトへのハンドルを取得できます。 オペレーティングシステムは、ハンドル数が0の場合にのみ、プロセスに関連付けられているメモリを解放します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。Windows 98 や Windows Me でこのプロパティにアクセスするには <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> プロパティを <see langword="false" /> に設定します。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="HasExited">
      <MemberSignature Language="C#" Value="public bool HasExited { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasExited" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HasExited" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasExited As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasExited { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasExited : bool" Usage="System.Diagnostics.Process.HasExited" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the associated process has been terminated.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessTerminated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられているプロセスが終了したかどうかを示す値を取得します。</summary>
        <value><see cref="T:System.Diagnostics.Process" /> コンポーネントが参照するオペレーティング システム プロセスが終了している場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 の値`true` <xref:System.Diagnostics.Process.HasExited%2A>がの場合は、関連付けられたプロセスが通常または異常に終了したことを示します。 または<xref:System.Diagnostics.Process.CloseMainWindow%2A> <xref:System.Diagnostics.Process.Kill%2A>を呼び出すことによって、関連付けられているプロセスを終了するように要求または強制できます。 ハンドルがプロセスに対して開かれている場合、オペレーティングシステムはプロセスが終了したときにプロセスメモリを解放しますが、ハンドル、終了コード、終了時刻など、プロセスに関する管理情報を保持します。 この情報を取得するには、プロパティ<xref:System.Diagnostics.Process.ExitCode%2A>と<xref:System.Diagnostics.Process.ExitTime%2A>プロパティを使用します。 これらのプロパティは、このコンポーネントによって開始されたプロセスに対して自動的に設定されます。 システムプロセスに関連付けられて<xref:System.Diagnostics.Process>いるすべてのコンポーネントが破棄され、終了したプロセスに対するハンドルがなくなった場合、管理情報が解放されます。  
  
 プロセスは、コードとは無関係に終了できます。 このコンポーネントを使用してプロセスを開始した場合、関連付け<xref:System.Diagnostics.Process.HasExited%2A>られているプロセスが個別に終了した場合でも、の値は自動的に更新されます。  
  
> [!NOTE]
>  標準出力が非同期イベントハンドラーにリダイレクトされた場合、このプロパティがを返す`true`ときに出力処理が完了していない可能性があります。 非同期イベント処理が完了したことを確認するに<xref:System.Diagnostics.Process.WaitForExit>は、チェック<xref:System.Diagnostics.Process.HasExited%2A>する前にパラメーターを取らないオーバーロードを呼び出します。  
  
   
  
## Examples  
 次の例では、メモ帳のインスタンスを起動します。 次に、関連付けられたプロセスの物理メモリ使用量を2秒間隔で最大10秒間取得します。 この例では、10秒が経過する前にプロセスが終了するかどうかを検出します。 この例では、10秒後にプロセスがまだ実行されている場合、プロセスを終了します。  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">オブジェクトに関連付けられているプロセスはありません。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">プロセスの終了コードを取得できませんでした。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行中のプロセスの <see cref="P:System.Diagnostics.Process.HasExited" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="M:System.Diagnostics.Process.OnExited" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Diagnostics.Process.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The unique identifier for the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスの一意の識別子を取得します。</summary>
        <value>この <see cref="T:System.Diagnostics.Process" /> インスタンスが参照する、システムが生成したプロセスの一意の識別子。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 関連付けら<xref:System.Diagnostics.Process.Id%2A>れたプロセスが実行されていない場合、プロセスは無効です。 そのため、 <xref:System.Diagnostics.Process.Id%2A>プロパティを取得する前に、プロセスが実行されていることを確認する必要があります。 プロセスが終了するまで、プロセス識別子はシステム全体のプロセスを一意に識別します。  
  
 プロセス識別子を<xref:System.Diagnostics.Process.GetProcessById%2A>メソッドに渡すことによって、ローカルコンピューターまたはリモートコンピューター <xref:System.Diagnostics.Process>で実行されているプロセスを新しいインスタンスに接続できます。 <xref:System.Diagnostics.Process.GetProcessById%2A>は、新しいコンポーネントを作成し、新しい<xref:System.Diagnostics.Process>インスタンスの<xref:System.Diagnostics.Process.Id%2A>プロパティを自動的に設定するメソッドです。`static`  
  
 プロセス識別子は、システムで再利用できます。 プロパティ<xref:System.Diagnostics.Process.Id%2A>値は、関連付けられているプロセスが実行されている場合にのみ一意です。 プロセスが終了すると、システムは関連のない<xref:System.Diagnostics.Process.Id%2A>プロセスに対してプロパティ値を再利用できます。  
  
 識別子はシステム上で一意であるため、インスタンスを<xref:System.Diagnostics.Process>渡す代わりに、他のスレッドに渡すことができます。 この操作により、システムリソースを節約しながら、プロセスが正しく識別されることを保証できます。  
  
   
  
## Examples  
 次の例は、 <xref:System.Diagnostics.Process.Id%2A>アプリケーションの実行中のすべてのインスタンスのを取得する方法を示しています。 このコードは、メモ帳の新しいインスタンスを作成し、メモ帳のすべてのインスタンスを一覧表示し、 <xref:System.Diagnostics.Process.Id%2A>ユーザーが数値を入力して特定のインスタンスを削除できるようにします。  
  
 [!code-csharp[System.Diagnostics.Process.Id#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Id#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">プロセスの <see cref="P:System.Diagnostics.Process.Id" /> プロパティが設定されていません。  
  
または 
この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。</exception>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。Windows 98 や Windows Me でこのプロパティにアクセスするには <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> プロパティを <see langword="false" /> に設定します。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Kill">
      <Docs>
        <summary>To be added.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

メソッド`Kill`は、終了を要求する<xref:System.Diagnostics.Process.CloseMainWindow%2A>だけで、プロセスを強制的に終了します。 グラフィカルインターフェイスを持つプロセスが実行されている場合、そのメッセージループは待機状態になります。 メッセージループは、Windows メッセージがオペレーティングシステムによってプロセスに送信されるたびに実行されます。 を<xref:System.Diagnostics.Process.CloseMainWindow%2A>呼び出すと、メインウィンドウを閉じるための要求が送信されます。このウィンドウは、適切な形式のアプリケーションで、子ウィンドウを閉じ、アプリケーションに対して実行中のすべてのメッセージループを取り消します。 を呼び出し<xref:System.Diagnostics.Process.CloseMainWindow%2A>てプロセスを終了する要求では、アプリケーションの終了は強制されません。
アプリケーションは、終了する前にユーザーの確認を要求することも、終了を拒否することもできます。 アプリケーションを強制的に終了するには、 `Kill`メソッドを使用します。

の<xref:System.Diagnostics.Process.CloseMainWindow%2A>動作は、[システム] メニューを使用してアプリケーションのメインウィンドウを閉じるユーザーの動作と同じです。
そのため、メインウィンドウを閉じてプロセスを終了する要求では、アプリケーションが直ちに終了することはありません。
  
> [!NOTE]
> メソッド<xref:System.Diagnostics.Process.Kill%2A>は、非同期的に実行されます。 `Kill`メソッドを呼び出した後、 <xref:System.Diagnostics.Process.WaitForExit%2A>メソッドを呼び出してプロセスが<xref:System.Diagnostics.Process.HasExited%2A>終了するまで待機するか、プロパティをチェックしてプロセスが終了したかどうかを確認します。

> [!NOTE]
> <xref:System.Diagnostics.Process.WaitForExit%2A> メソッド<xref:System.Diagnostics.Process.HasExited%2A>とプロパティには、子孫プロセスの状態は反映されません。
> を`Kill(entireProcessTree: true)`使用した<xref:System.Diagnostics.Process.WaitForExit%2A>場合<xref:System.Diagnostics.Process.HasExited%2A> 、とは、すべての子孫がまだ終了していなくても、指定されたプロセスが終了した後に、終了が完了したことを示します。
  
プロセスによって編集されたデータまたはプロセスに割り当てられた`Kill`リソースは、を呼び出すと失われることがあります。 
`Kill`プロセスが異常終了する原因となるため、必要な場合にのみ使用してください。
<xref:System.Diagnostics.Process.CloseMainWindow%2A>プロセスの正常終了を有効にし、すべてのウィンドウを閉じます。そのため、インターフェイスを備えたアプリケーションに適しています。 が<xref:System.Diagnostics.Process.CloseMainWindow%2A>失敗した場合は`Kill` 、を使用してプロセスを終了できます。
`Kill`は、グラフィカルインターフェイスを持たないプロセスを終了する唯一の方法です。
  
は、 `Kill` <xref:System.Diagnostics.Process.CloseMainWindow%2A>ローカルコンピューターで実行されているプロセスに対してのみ呼び出すことができます。
リモートコンピューター上のプロセスを終了させることはできません。 リモートコンピューター上で実行されているプロセスの情報のみを表示できます。
  
> [!NOTE]
> プロセスの終了中に`Kill`メソッドの呼び出しが行われた場合、アクセスが<xref:System.ComponentModel.Win32Exception>拒否されると、がスローされます。
  
 ]]></format>
        </remarks>        
      </Docs>
    </MemberGroup>    
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public void Kill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Kill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Kill" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Kill();" />
      <MemberSignature Language="F#" Value="member this.Kill : unit -&gt; unit" Usage="process.Kill " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>関連付けられたプロセスを即時中断します。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられたプロセスを終了できませんでした。  
  
 または  
  
 プロセスを終了しています。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行されているプロセスの <see cref="M:System.Diagnostics.Process.Kill" /> を呼び出そうとしています。 このメソッドはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.InvalidOperationException">プロセスは既に終了しています。  
  
または 
この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="M:System.Environment.Exit(System.Int32)" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public void Kill (bool entireProcessTree);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Kill(bool entireProcessTree) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Kill(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill (entireProcessTree As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Kill(bool entireProcessTree);" />
      <MemberSignature Language="F#" Value="member this.Kill : bool -&gt; unit" Usage="process.Kill entireProcessTree" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entireProcessTree" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="entireProcessTree"><see langword="true" /> の場合、関連付けられているプロセスとその子孫が中止されます。<see langword="false" /> の場合、関連付けられているプロセスのみが中止されます。</param>
        <summary>関連付けられているプロセスと、任意で、その子/子孫プロセスを直ちに停止します。</summary>
        <remarks>が<paramref name="entireProcessTree" /> に<see langword="true" />設定されている場合、呼び出しに詳細を表示するアクセス許可がないプロセスは、子孫終了プロセスによって暗黙的にスキップされます。これは、プロセスが子孫であるかどうかを終了プロセスが判断できないためです。</remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられたプロセスを終了できませんでした。  
  
 - または -  
  
 プロセスを終了しています。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行されているプロセスの <see cref="M:System.Diagnostics.Process.Kill" /> を呼び出そうとしています。 このメソッドはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.InvalidOperationException">プロセスは既に終了しています。  
  
または 
この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。

- または -

呼び出しプロセスは、関連付けられているプロセスの子孫ツリーのメンバーです。</exception>
        <exception cref="T:System.AggregateException">関連付けられているプロセスの子孫ツリーの一部のプロセスを強制終了できませんでした。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="M:System.Environment.Exit(System.Int32)" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
      </Docs>
    </Member>
    <Member MemberName="LeaveDebugMode">
      <MemberSignature Language="C#" Value="public static void LeaveDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LeaveDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.LeaveDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LeaveDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LeaveDebugMode();" />
      <MemberSignature Language="F#" Value="static member LeaveDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.LeaveDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Diagnostics.Process" /> コンポーネントを、特殊なモードで実行されているオペレーティング システム プロセスと対話する状態から解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一部のオペレーティングシステムプロセスは、特別なモードで実行されます。 コンポーネントでを呼び出し<xref:System.Diagnostics.Process.EnterDebugMode%2A>ていない限り、これらのプロセスのプロパティを読み取ろうとしたり、これらのプロセスにアタッチしたりすることはできません。 特別<xref:System.Diagnostics.Process.LeaveDebugMode%2A>なモードで実行されるこれらのプロセスにアクセスする必要がなくなったときに、を呼び出します。  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="M:System.Diagnostics.Process.EnterDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Diagnostics.Process.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of the machine the running the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMachineName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスを実行しているコンピューターの名前を取得します。</summary>
        <value>関連付けられたプロセスを実行しているコンピューターの名前。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 リモートコンピューター上で実行されているプロセスの統計データとプロセス情報を表示<xref:System.Diagnostics.Process.Start%2A>でき<xref:System.Diagnostics.Process.CloseMainWindow%2A>ますが<xref:System.Diagnostics.Process.Kill%2A> 、リモートコンピューターで、、またはを呼び出すことはできません。  
  
> [!NOTE]
>  関連付けられたプロセスがローカルコンピューター上で実行されている場合、このプロパティはコンピューター名のピリオド (".") を返します。 正しいコンピューター名を<xref:System.Environment.MachineName%2A?displayProperty=nameWithType>取得するには、プロパティを使用する必要があります。  
  
   
  
## Examples  
 次の例を使用するには、まず、リモートコンピューター上でメモ帳のインスタンスを少なくとも1つ起動する必要があります。 この例では、メモ帳が実行されているリモートコンピューターの名前を要求し<xref:System.Diagnostics.Process.ProcessName%2A>、 <xref:System.Diagnostics.Process.Id%2A>各インスタンス<xref:System.Diagnostics.Process.MachineName%2A>の、、およびの各プロパティを表示します。  
  
 [!code-csharp[process_GetProcessesByName2_2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CS/process_getprocessesbyname2_2.cs#2)]
 [!code-vb[process_GetProcessesByName2_2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_GetProcessesByName2_2/VB/process_getprocessesbyname2_2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MainModule">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModule MainModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModule MainModule" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainModule" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainModule As ProcessModule" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModule ^ MainModule { System::Diagnostics::ProcessModule ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainModule : System.Diagnostics.ProcessModule" Usage="System.Diagnostics.Process.MainModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The main module of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainModule")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModule</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスのメイン モジュールを取得します。</summary>
        <value>プロセスを開始する際に使用した <see cref="T:System.Diagnostics.ProcessModule" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロセスモジュールは、特定のプロセスに読み込まれる .dll または .exe ファイルを表します。 <xref:System.Diagnostics.Process.MainModule%2A>プロパティを使用すると、モジュール名、ファイル名、モジュールメモリの詳細など、プロセスの開始に使用される実行可能ファイルに関する情報を表示できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行中のプロセスの <see cref="P:System.Diagnostics.Process.MainModule" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">32 ビット プロセスが 64 ビット プロセスのモジュールにアクセスしようとしています。</exception>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。Windows 98 や Windows Me でこのプロパティにアクセスするには、 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> を <see langword="false" /> に設定します。</exception>
        <exception cref="T:System.InvalidOperationException">プロセス <see cref="P:System.Diagnostics.Process.Id" /> が使用できません。  
  
- または - 
プロセスが終了しています。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.Modules" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowHandle">
      <MemberSignature Language="C#" Value="public IntPtr MainWindowHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MainWindowHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MainWindowHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowHandle : nativeint" Usage="System.Diagnostics.Process.MainWindowHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The handle of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainWindowHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスのメイン ウィンドウで使用するウィンドウ ハンドルを取得します。</summary>
        <value>関連付けられたプロセスのメイン ウィンドウで使用する、システムが生成したウィンドウ ハンドル。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メインウィンドウは、現在フォーカスがあるプロセス ( <xref:System.Windows.Forms.Form.TopLevel%2A>フォーム) によって開かれたウィンドウです。 オブジェクト<xref:System.Diagnostics.Process>を更新する<xref:System.Diagnostics.Process.Refresh%2A>には、メソッドを使用して、現在のメインウィンドウハンドルが変更されている場合にそのハンドルを取得する必要があります。 一般に、ウィンドウハンドルはキャッシュされている<xref:System.Diagnostics.Process.Refresh%2A>ため、現在のハンドルを取得することを保証するために、事前にを使用します。  
  
 <xref:System.Diagnostics.Process.MainWindowHandle%2A>プロパティを取得できるのは、ローカルコンピューター上で実行されているプロセスだけです。 <xref:System.Diagnostics.Process.MainWindowHandle%2A>プロパティは、プロセスに関連付けられているウィンドウを一意に識別する値です。  
  
 プロセスには、プロセスにグラフィカルインターフェイスがある場合にのみ、関連付けられているメインウィンドウがあります。 関連付けられたプロセスにメインウィンドウがない場合、 <xref:System.Diagnostics.Process.MainWindowHandle%2A>値は0になります。 この値は、非表示になっているプロセス (タスクバーに表示されないプロセス) でも0になります。 これは、タスクバーの右端にある通知領域にアイコンとして表示されるプロセスの場合に発生する可能性があります。  
  
 プロセスを開始したばかりで、メインウィンドウハンドルを使用する場合は、 <xref:System.Diagnostics.Process.WaitForInputIdle%2A>メソッドを使用して、プロセスの開始を許可し、メインウィンドウハンドルが作成されていることを確認します。 この操作を行わない場合、例外がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">プロセスが終了したため、<see cref="P:System.Diagnostics.Process.MainWindowHandle" /> が定義されていません。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行中のプロセスの <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。Windows 98 や Windows Me でこのプロパティにアクセスするには <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> を <see langword="false" /> に設定します。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowTitle" />
        <altmember cref="P:System.Diagnostics.Process.MainModule" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowTitle">
      <MemberSignature Language="C#" Value="public string MainWindowTitle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MainWindowTitle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowTitle As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MainWindowTitle { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowTitle : string" Usage="System.Diagnostics.Process.MainWindowTitle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The title of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainWindowTitle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロセスのメイン ウィンドウのキャプションを取得します。</summary>
        <value>プロセスのメイン ウィンドウのタイトル。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロセスには、プロセスにグラフィカルインターフェイスがある場合にのみ、関連付けられているメインウィンドウがあります。 関連付けられたプロセスにメインウィンドウがない ( <xref:System.Diagnostics.Process.MainWindowHandle%2A>つまり、が0である) 場合、 <xref:System.Diagnostics.Process.MainWindowTitle%2A>は空の文字列 ("") になります。 プロセスを開始したばかりで、メインウィンドウタイトルを使用する場合は、 <xref:System.Diagnostics.Process.WaitForInputIdle%2A>メソッドを使用して、プロセスの開始を許可し、メインウィンドウハンドルが作成されていることを確認します。 それ以外の場合、例外がスローされます。  
  
> [!NOTE]
>  メインウィンドウは、現在フォーカスがあるウィンドウです。これは、プロセスの主要なウィンドウではない可能性があることに注意してください。 オブジェクト<xref:System.Diagnostics.Process>を更新する<xref:System.Diagnostics.Process.Refresh%2A>には、メソッドを使用して、現在のメインウィンドウハンドルが変更されている場合にそのハンドルを取得する必要があります。  
  
   
  
## Examples  
 次の例では、メモ帳のインスタンスを起動して、プロセスのメインウィンドウのキャプションを取得します。  
  
 [!code-cpp[process_MainWindowTitle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_MainWindowTitle/CPP/process_mainwindowtitle.cpp#1)]
 [!code-csharp[process_MainWindowTitle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_MainWindowTitle/CS/process_mainwindowtitle.cs#1)]
 [!code-vb[process_MainWindowTitle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_MainWindowTitle/VB/process_mainwindowtitle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">プロセスが終了したため、<see cref="P:System.Diagnostics.Process.MainWindowTitle" /> プロパティが定義されていません。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行中のプロセスの <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。Windows 98 や Windows Me でこのプロパティにアクセスするには <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> を <see langword="false" /> に設定します。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="MaxWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MaxWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MaxWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MaxWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MaxWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MaxWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MaxWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMaxWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに許可されるワーキング セットの最大サイズ (バイト単位) を取得または設定します。</summary>
        <value>プロセスに許可されるメモリ上のワーキング セットの最大サイズ (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロセスのワーキングセットは、物理 RAM メモリ内のプロセスに現在表示されているメモリページのセットです。 これらのページは常駐し、アプリケーションがページフォールトをトリガーすることなく使用できます。  
  
 ワーキングセットには、共有データとプライベートデータの両方が含まれます。 共有データには、アプリケーションによって実行されるすべての命令を含むページが含まれます。これには、.dll ファイル内のページとシステム .dll ファイルも含まれます。 ワーキングセットのサイズが増加するにつれて、メモリの需要が増加します。  
  
 プロセスのワーキングセットのサイズは、最小値と最大値です。 プロセスリソースが作成されるたびに、プロセスのワーキングセットの最小サイズと同じ量のメモリがシステムによって予約されます。 仮想メモリマネージャーは、プロセスがアクティブなときに少なくとも最小メモリ容量を維持しようとしますが、最大サイズを超えることはありません。  
  
 既定のワーキングセットのサイズは、システムによって設定されます。 これらのサイズは、 <xref:System.Diagnostics.Process.MaxWorkingSet%2A>メンバーと<xref:System.Diagnostics.Process.MinWorkingSet%2A>メンバーを使用して変更できます。 ただし、これらの値を設定しても、メモリが予約されているか常駐しているかは保証されません。  
  
> [!NOTE]
>  プロセスのワーキングセットのサイズを大きくすると、システムの他の部分から物理メモリを離れた場所に移動します。 ワーキングセットのサイズの最小値または最大値を要求しないようにしてください。そうしないと、システムのパフォーマンスが低下する可能性があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">ワーキング セットの最大サイズが正しくありません。 この値は、ワーキング セットの最小サイズ以上である必要があります。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられているプロセス リソースからワーキング セット情報を取得できません。  
  
 または  
  
 プロセスが開始されていないので、プロセス識別子またはプロセス ハンドルが 0 です。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行中のプロセスの <see cref="P:System.Diagnostics.Process.MaxWorkingSet" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.InvalidOperationException">プロセス <see cref="P:System.Diagnostics.Process.Id" /> が使用できません。  
  
または 
プロセスが終了しています。</exception>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="MinWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MinWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MinWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MinWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MinWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MinWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MinWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The minimum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMinWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに許可されるワーキング セットの最小サイズ (バイト単位) を取得または設定します。</summary>
        <value>プロセスに必要なメモリ上のワーキング セットの最小サイズ (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロセスのワーキングセットは、物理 RAM メモリ内のプロセスに現在表示されているメモリページのセットです。 これらのページは常駐し、アプリケーションがページフォールトをトリガーすることなく使用できます。  
  
 ワーキングセットには、共有データとプライベートデータの両方が含まれます。 共有データには、アプリケーションによって実行されるすべての命令を含むページが含まれます。これには、.dll ファイル内のページとシステム .dll ファイルも含まれます。 ワーキングセットのサイズが増加するにつれて、メモリの需要が増加します。  
  
 プロセスのワーキングセットのサイズは、最小値と最大値です。 プロセスリソースが作成されるたびに、プロセスのワーキングセットの最小サイズと同じ量のメモリがシステムによって予約されます。 仮想メモリマネージャーは、プロセスがアクティブなときに少なくとも最小メモリ容量を維持しようとしますが、最大サイズを超えることはありません。  
  
 既定のワーキングセットのサイズは、システムによって設定されます。 これらのサイズは、 <xref:System.Diagnostics.Process.MaxWorkingSet%2A>メンバーと<xref:System.Diagnostics.Process.MinWorkingSet%2A>メンバーを使用して変更できます。 ただし、これらの値を設定しても、メモリが予約されているか常駐しているかは保証されません。  
  
> [!NOTE]
>  プロセスのワーキングセットのサイズを大きくすると、システムの他の部分から物理メモリを離れた場所に移動します。 ワーキングセットのサイズの最小値または最大値を要求しないようにしてください。そうしないと、システムのパフォーマンスが低下する可能性があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">ワーキング セットの最小サイズが正しくありません。 この値は、ワーキング セットの最大サイズ以下にする必要があります。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられているプロセス リソースからワーキング セット情報を取得できません。  
  
 - または -  
  
 プロセスが開始されていないので、プロセス識別子またはプロセス ハンドルが 0 です。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行中のプロセスの <see cref="P:System.Diagnostics.Process.MinWorkingSet" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.InvalidOperationException">プロセス <see cref="P:System.Diagnostics.Process.Id" /> が使用できません。  
  
- または - 
プロセスが終了しています。</exception>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModuleCollection Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModuleCollection Modules" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Modules" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Modules As ProcessModuleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModuleCollection ^ Modules { System::Diagnostics::ProcessModuleCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Modules : System.Diagnostics.ProcessModuleCollection" Usage="System.Diagnostics.Process.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The modules that are loaded as part of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessModules")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModuleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに読み込まれたモジュールを取得します。</summary>
        <value>関連付けられたプロセスに読み込まれたモジュールを表す <see cref="T:System.Diagnostics.ProcessModule" /> 型の配列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロセスモジュールは、特定のプロセスに読み込まれる .dll または .exe ファイルを表します。 インスタンス<xref:System.Diagnostics.ProcessModule>を使用すると、モジュール名、ファイル名、モジュールメモリの詳細など、モジュールに関する情報を表示できます。  
  
 プロセスでは、複数のモジュールをメモリに読み込むことができます。 たとえば、追加の .dll ファイルを読み込む .exe ファイルには、複数のモジュールがあります。  
  
 プロセスの開始後、このコレクションは、システムによってプロセスが読み込まれるまで空になります。 プロセスにメインウィンドウがある場合は、このプロパティ<xref:System.Diagnostics.Process.WaitForInputIdle%2A>を取得する前にを呼び出して、リストを取得したときにコレクションが空でないことを確認できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行されているプロセスの <see cref="P:System.Diagnostics.Process.Modules" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.InvalidOperationException">プロセス <see cref="P:System.Diagnostics.Process.Id" /> が使用できなくなっています。</exception>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。Windows 98 や Windows Me でこのプロパティにアクセスするには <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> を <see langword="false" /> に設定します。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">システム プロセスまたはアイドル状態のプロセスのいずれかの <see cref="P:System.Diagnostics.Process.Modules" /> プロパティにアクセスしようとしています。 これらのプロセスには、モジュールが存在しません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="T:System.Diagnostics.ProcessModule" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int NonpagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 NonpagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int NonpagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize : int" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use NonpagedSystemMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.NonpagedSystemMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessNonpagedSystemMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.NonpagedSystemMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに割り当てられたページングされないシステム メモリの量 (バイト単位) を取得します。</summary>
        <value>システムによって関連付けられたプロセスに割り当てられた、仮想メモリ ページング ファイルに書き込むことができないメモリの容量 (バイト単位)。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long NonpagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 NonpagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long NonpagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessNonpagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに割り当てられたページングされないシステム メモリの量 (バイト単位) を取得します。</summary>
        <value>関連付けられたプロセスに割り当てられた、仮想メモリ ページング ファイルに書き込むことができないシステム メモリの容量 (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティによって返される値は、プロセスによって使用されるページシステムメモリの現在のサイズ (バイト単位) を表します。 システムメモリはオペレーティングシステムによって使用される物理メモリであり、ページングされたプールと非ページプールに分かれています。 ページングされていないメモリ割り当ては、システムメモリに残り、仮想メモリページングファイルにはページングされません。  
  
 このプロパティは、32ビットプロセッサまたは64ビットプロセッサを搭載したコンピューターのメモリ使用量を監視するために使用できます。 プロパティ値は、プロセスの "**プールの非ページバイト数**" パフォーマンスカウンターに相当します。  
  
   
  
## Examples  
 次のコード例では、メモ帳アプリケーションのインスタンスを起動します。 次に、この例では、関連付けられているプロセスのさまざまなプロパティを取得して表示します。 この例では、プロセスが終了したことを検出し、終了コードとピークメモリの統計情報を表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="OnExited">
      <MemberSignature Language="C#" Value="protected void OnExited ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnExited() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.OnExited" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnExited ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnExited();" />
      <MemberSignature Language="F#" Value="member this.OnExited : unit -&gt; unit" Usage="process.OnExited " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="E:System.Diagnostics.Process.Exited" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.OnExited%2A>は、 <xref:System.Diagnostics.Process.Exited>イベントを発生させる API メソッドです。 を呼び出す<xref:System.Diagnostics.Process.OnExited%2A>と、 <xref:System.Diagnostics.Process> イベントが発生し、コンポーネントを使用してイベントを発生させる唯一の方法<xref:System.Diagnostics.Process.Exited>となります。 <xref:System.Diagnostics.Process.OnExited%2A>は、主にコンポーネントからクラスを派生させるときに使用されます。  
  
 <xref:System.Diagnostics.Process.OnExited%2A>の代わりに、独自のイベントハンドラーを作成することもできます。 独自のイベントハンドラーデリゲートと独自のイベント処理メソッドを作成します。  
  
> [!NOTE]
>  Visual Studio 環境を使用している場合は、コンポーネントを<xref:System.Diagnostics.Process>フォームにドラッグし、アイコンをダブルクリックすると、イベントハンドラーデリゲート (AddOnExited) とイベント処理メソッド (Process1_Exited) が作成されます。 <xref:System.Diagnostics.Process.Exited>イベントが発生したときに実行するために作成したコードは、Process1_Exited プロシージャに入力されます。 <xref:System.Diagnostics.Process.OnExited%2A>メンバーが実装されているため、メンバーを作成する必要はありません。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 概要については、「[イベントの処理と発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 派生クラスで<xref:System.Diagnostics.Process.OnExited%2A>メソッドを使用する方法を次の例に示します。  
  
 [!code-csharp[OnExitSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/onexitsample/cs/program.cs#1)]
 [!code-vb[OnExitSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/onexitsample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="OutputDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler OutputDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler OutputDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.OutputDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event OutputDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ OutputDataReceived;" />
      <MemberSignature Language="F#" Value="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessAssociated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションが、リダイレクトされた <see cref="P:System.Diagnostics.Process.StandardOutput" /> ストリームに行を書き込む度に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベント<xref:System.Diagnostics.Process.OutputDataReceived>は、関連付けら<xref:System.Diagnostics.Process>れたが、リダイレクト<xref:System.Diagnostics.Process.StandardOutput%2A>されたストリームの改行文字で終了する行を書き込んだことを示します。  
  
 イベントは、での<xref:System.Diagnostics.Process.StandardOutput%2A>非同期読み取り操作中に有効になります。 非同期<xref:System.Diagnostics.Process.StandardOutput%2A> <xref:System.Diagnostics.Process.OutputDataReceived> の読み取り<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>操作を開始するには、のストリームをリダイレクトし、イベントにイベントハンドラーを追加して、を呼び出す必要があります。<xref:System.Diagnostics.Process> その後、 <xref:System.Diagnostics.Process.OutputDataReceived>このイベントは、プロセスが終了するか、が呼び出さ<xref:System.Diagnostics.Process.StandardOutput%2A> <xref:System.Diagnostics.Process.CancelOutputRead%2A>れるまで、リダイレクトされたストリームに行が書き込まれるたびに通知します。  
  
> [!NOTE]
>  非同期出力を処理するアプリケーションでは、出力バッファー <xref:System.Diagnostics.Process.WaitForExit%2A>がフラッシュされたことを確認するためにメソッドを呼び出す必要があります。  
  
   
  
## Examples  
 次の例は、 <xref:System.Diagnostics.Process.StandardOutput%2A> `ipconfig`コマンドのリダイレクトされたストリームで非同期の読み取り操作を実行する方法を示しています。  
  
 この例では、イベントハンドラーの`OutputHandler`イベントデリゲートを作成し、イベント<xref:System.Diagnostics.Process.OutputDataReceived>に関連付けます。 イベントハンドラーは、リダイレクト<xref:System.Diagnostics.Process.StandardOutput%2A>されたストリームからテキスト行を受け取り、テキストを書式設定して、後で例のコンソールウィンドウに表示される出力文字列に保存します。  
  
 [!code-cpp[Process_AsyncStreams#4](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/datareceivedevent.cpp#4)]
 [!code-csharp[Process_AsyncStreams#4](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/datareceivedevent.cs#4)]
 [!code-vb[Process_AsyncStreams#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/datareceivedevent.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize">
      <MemberSignature Language="C#" Value="public int PagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize : int" Usage="System.Diagnostics.Process.PagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PagedMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに割り当てられたページ メモリの量 (バイト単位) を取得します。</summary>
        <value>仮想メモリ ページング ファイルに書き込むことができる関連付けられたプロセスによって割り当てられたメモリの容量 (バイト単位)。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに割り当てられたページ メモリの量 (バイト単位) を取得します。</summary>
        <value>関連付けられたプロセスの仮想メモリ ページング ファイル内で割り当てられたメモリの量 (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティによって返される値は、プロセスによって使用される仮想メモリページングファイル内のメモリの現在のサイズをバイト単位で表します。 オペレーティングシステムは、仮想メモリページングファイルと物理メモリを使用して、各プロセスの仮想アドレス空間を管理します。 ページング可能なメモリが使用されていない場合は、ディスク上の仮想メモリのページングファイルに転送できます。 プロセスのオペレーティングシステムによって使用されているメモリのサイズを取得<xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A>するには、プロパティを使用します。  
  
 このプロパティは、32ビットプロセッサまたは64ビットプロセッサを搭載したコンピューターのメモリ使用量を監視するために使用できます。 プロパティ値は、プロセスの**ページファイル Bytes**パフォーマンスカウンターに相当します。  
  
   
  
## Examples  
 次のコード例では、メモ帳アプリケーションのインスタンスを起動し、関連付けられているプロセスのさまざまなプロパティを取得して表示します。 この例では、プロセスが終了したことを検出し、終了コードとピークメモリの統計情報を表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int PagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize : int" Usage="System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PagedSystemMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedSystemMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedSystemMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedSystemMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに割り当てられたページング可能なシステム メモリの量 (バイト単位) を取得します。</summary>
        <value>システムによって関連付けられたプロセスに割り当てられた、仮想メモリ ページング ファイルに書き込むことができるメモリの容量 (バイト単位)。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに割り当てられたページング可能なシステム メモリの量 (バイト単位) を取得します。</summary>
        <value>関連付けられたプロセスに割り当てられた、仮想メモリ ページング ファイルに書き込むことができるシステム メモリの容量 (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティ値によって返される値は、プロセスによって使用されるページング可能なシステムメモリの現在のサイズ (バイト単位) を表します。 システムメモリはオペレーティングシステムによって使用される物理メモリであり、ページングされたプールと非ページプールに分かれています。 ページング可能なメモリが使用されていない場合は、ディスク上の仮想メモリのページングファイルに転送できます。 プロセスによって使用されるアプリケーションメモリのサイズを取得するに<xref:System.Diagnostics.Process.PagedMemorySize64%2A>は、プロパティを使用します。  
  
 このプロパティは、32ビットプロセッサまたは64ビットプロセッサを搭載したコンピューターのメモリ使用量を監視するために使用できます。 プロパティ値は、プロセスの**Pool Bytes (ページバイト数)** パフォーマンスカウンターに相当します。  
  
   
  
## Examples  
 次のコード例では、メモ帳アプリケーションのインスタンスを起動します。 次に、この例では、関連付けられているプロセスのさまざまなプロパティを取得して表示します。 この例では、プロセスが終了したことを検出し、終了コードとピークメモリの統計情報を表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize">
      <MemberSignature Language="C#" Value="public int PeakPagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakPagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakPagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize : int" Usage="System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakPagedMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakPagedMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakPagedMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakPagedMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスによって使用される、仮想メモリ ページング ファイル内のメモリの最大量を取得します (バイト単位)。</summary>
        <value>関連付けられたプロセスによって割り当てられた、仮想メモリ ページング ファイルに書き込むことができたメモリの最大容量 (バイト単位)。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakPagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakPagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakPagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスによって使用される、仮想メモリ ページング ファイル内のメモリの最大量を取得します (バイト単位)。</summary>
        <value>プロセスの開始以降、関連付けられたプロセスの仮想メモリ ページング ファイル内で割り当てられたメモリの最大量 (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティ値によって返される値は、プロセスが開始してから使用した仮想メモリページングファイル内のメモリの最大サイズをバイト単位で表します。 オペレーティングシステムは、仮想メモリページングファイルと物理メモリを使用して、各プロセスの仮想アドレス空間を管理します。 ページング可能なメモリが使用されていない場合は、ディスク上の仮想メモリのページングファイルに転送できます。  
  
 このプロパティは、32ビットプロセッサまたは64ビットプロセッサを搭載したコンピューターのメモリ使用量を監視するために使用できます。 プロパティ値は、プロセスの**ページファイルバイトピーク**パフォーマンスカウンターに相当します。  
  
   
  
## Examples  
 次のコード例では、メモ帳アプリケーションのインスタンスを起動します。 次に、この例では、関連付けられているプロセスのさまざまなプロパティを取得して表示します。 この例では、プロセスが終了したことを検出し、終了コードとピークメモリの統計情報を表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize">
      <MemberSignature Language="C#" Value="public int PeakVirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakVirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakVirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize : int" Usage="System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakVirtualMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakVirtualMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakVirtualMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakVirtualMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスによって使用される仮想メモリの最大量を取得します (バイト単位)。</summary>
        <value>関連付けられたプロセスが要求した仮想メモリの最大容量 (バイト単位)。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakVirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakVirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakVirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスによって使用される仮想メモリの最大量を取得します (バイト単位)。</summary>
        <value>プロセスの開始以降、関連付けられたプロセスに割り当てられた仮想メモリの最大量 (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティによって返される値は、プロセスが開始してから使用した仮想メモリの最大サイズをバイト単位で表します。 オペレーティングシステムは、物理メモリに読み込まれたページか、ディスク上の仮想メモリページングファイルに格納されているページに、各プロセスの仮想アドレス空間をマップします。  
  
 このプロパティは、32ビットプロセッサまたは64ビットプロセッサを搭載したコンピューターのメモリ使用量を監視するために使用できます。 プロパティ値は、プロセスの**仮想バイトピーク**パフォーマンスカウンターに相当します。  
  
   
  
## Examples  
 次のコード例では、メモ帳アプリケーションのインスタンスを起動します。 次に、この例では、関連付けられているプロセスのさまざまなプロパティを取得して表示します。 この例では、プロセスが終了したことを検出し、終了コードとピークメモリの統計情報を表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet">
      <MemberSignature Language="C#" Value="public int PeakWorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakWorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet : int" Usage="System.Diagnostics.Process.PeakWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakWorkingSet64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakWorkingSet64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakWorkingSet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakWorkingSet64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスのピーク ワーキング セット サイズをバイト単位で取得します。</summary>
        <value>関連づけられたプロセスが一度に要求した物理メモリのバイト単位での最大容量。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロセスのワーキングセットは、物理 RAM メモリ内のプロセスに現在表示されているメモリページのセットです。 これらのページは常駐し、アプリケーションがページフォールトをトリガーすることなく使用できます。  
  
 ワーキングセットには、共有データとプライベートデータの両方が含まれます。 共有データには、プロセスモジュールやシステムライブラリを含む、プロセスによって実行されるすべての命令を含むページが含まれます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet64">
      <MemberSignature Language="C#" Value="public long PeakWorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakWorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakWorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet64 : int64" Usage="System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスによって使用される物理メモリの最大量をバイト数として取得します。</summary>
        <value>プロセスの開始以降、関連付けられたプロセスに割り当てられた物理メモリの最大量 (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティによって返される値は、プロセスが開始してから使用されるワーキングセットメモリの最大サイズをバイト単位で表します。 プロセスのワーキングセットは、物理 RAM メモリ内のプロセスに現在表示されているメモリページのセットです。 これらのページは常駐し、アプリケーションがページフォールトをトリガーすることなく使用できます。  
  
 ワーキングセットには、共有データとプライベートデータの両方が含まれます。 共有データには、プロセスモジュールやシステムライブラリからの指示を含め、プロセスが実行するすべての命令を含むページが含まれます。  
  
 このプロパティは、32ビットプロセッサまたは64ビットプロセッサを搭載したコンピューターのメモリ使用量を監視するために使用できます。 プロパティ値は、プロセスの**ワーキングセットのピーク時**のパフォーマンスカウンターと同じです。  
  
   
  
## Examples  
 次のコード例では、メモ帳アプリケーションのインスタンスを起動します。 次に、この例では、関連付けられているプロセスのさまざまなプロパティを取得して表示します。 この例では、プロセスが終了したことを検出し、終了コードとピークメモリの統計情報を表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityBoostEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PriorityBoostEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityBoostEnabled : bool with get, set" Usage="System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Process will be of higher priority while it is actively used.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPriorityBoostEnabled")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メイン ウィンドウのフォーカス時に、オペレーティング システムによって関連付けられたプロセスの優先順位を一時的に上げるかどうかを示す値を取得または設定します。</summary>
        <value>待機状態から抜けたときにプロセスの優先順位を動的に上げる場合は<see langword="true" /> 。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 優先度クラスに動的優先順位列挙値 (<xref:System.Diagnostics.ProcessPriorityClass.Normal>、 <xref:System.Diagnostics.ProcessPriorityClass.High>、または<xref:System.Diagnostics.ProcessPriorityClass.RealTime>) のいずれかがあるプロセスでスレッドが実行されると、待機状態から除外されたときに、システムは一時的にスレッドの優先順位をブーストします。 この操作により、他のプロセスが現在のスレッドの処理を中断するのを防ぐことができます。 この<xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>設定は、プロセスによって作成されたすべての既存のスレッドとスレッドに影響します。 通常の動作を復元するに<xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>は、 `false`プロパティをに設定します。  
  
> [!NOTE]
>  優先順位を高くすると、重要なオペレーティングシステムやネットワーク機能からリソースがドレインされ、他のオペレーティングシステムのタスクに関する問題が発生する可能性があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられているプロセス リソースから priority boost 情報を取得できませんでした。</exception>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。  
  
 または  
  
 プロセス識別子またはプロセス ハンドルが 0 です。 (プロセスは開始されていません。)</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行されているプロセスの <see cref="P:System.Diagnostics.Process.PriorityBoostEnabled" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.InvalidOperationException">プロセス <see cref="P:System.Diagnostics.Process.Id" /> が使用できません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="PriorityClass">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessPriorityClass PriorityClass { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ProcessPriorityClass PriorityClass" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityClass" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityClass As ProcessPriorityClass" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessPriorityClass PriorityClass { System::Diagnostics::ProcessPriorityClass get(); void set(System::Diagnostics::ProcessPriorityClass value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityClass : System.Diagnostics.ProcessPriorityClass with get, set" Usage="System.Diagnostics.Process.PriorityClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The priority that the threads in the process run relative to.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPriorityClass")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessPriorityClass</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスの全体的な優先順位カテゴリを取得または設定します。</summary>
        <value>プロセスの <see cref="P:System.Diagnostics.Process.BasePriority" /> を計算するときに使用する、関連付けられたプロセスの優先順位カテゴリ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロセス優先度クラスは、スレッドの優先度レベルの範囲を含みます。 プロセスで実行されている優先順位が異なるスレッドは、プロセスの優先度クラスと比較して実行されます。 Win32 では、クラスごとに7つの基本優先度レベルを持つ4つの優先度クラスが使用されます。 これらのプロセス優先度クラスは、 <xref:System.Diagnostics.ProcessPriorityClass>列挙体でキャプチャされます。これにより<xref:System.Diagnostics.ProcessPriorityClass.Normal>、プロセスの<xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>優先順位<xref:System.Diagnostics.ProcessPriorityClass.RealTime>を、 <xref:System.Diagnostics.ProcessPriorityClass.High> <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>、、、、またはに<xref:System.Diagnostics.ProcessPriorityClass.Idle>設定できます。 プロセッサにアクセスするためにプロセスを事前に進める必要がある場合、オペレーティングシステムによって基本優先度レベルを変更することができます。 また、を設定<xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>して、待機状態から除外されたスレッドの優先度レベルを一時的に上げることができます。 プロセスが待機状態に戻ると、優先順位がリセットされます。  
  
 <xref:System.Diagnostics.Process.BasePriority%2A>プロパティを使用すると、プロセスに割り当てられている開始の優先順位を表示できます。 ただし、読み取り専用であるため、 <xref:System.Diagnostics.Process.BasePriority%2A>プロパティを使用してプロセスの優先順位を設定することはできません。 優先順位を変更するには<xref:System.Diagnostics.Process.PriorityClass%2A> 、プロパティを使用します。このプロパティは、プロセスの全体的な優先順位カテゴリを取得または設定します。  
  
 システムモニタを使用して、優先度クラスを表示することはできません。 次の表に、と<xref:System.Diagnostics.Process.BasePriority%2A> <xref:System.Diagnostics.Process.PriorityClass%2A>の値の関係を示します。  
  
|BasePriority|PriorityClass|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 次の例では、メモ帳のインスタンスを起動します。 次に、この例では、関連付けられているプロセスのさまざまなプロパティを取得して表示します。 この例では、プロセスが終了したことを検出し、プロセスの終了コードを表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられているプロセスのリソースからプロセス優先度情報を設定できないか、取得できませんでした。  
  
 - または -  
  
 プロセス識別子またはプロセス ハンドルが 0 です。 (プロセスは開始されていません。)</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行されているプロセスの <see cref="P:System.Diagnostics.Process.PriorityClass" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.InvalidOperationException">プロセス <see cref="P:System.Diagnostics.Process.Id" /> が使用できません。</exception>
        <exception cref="T:System.PlatformNotSupportedException">Windows 98 または Windows Millennium Edition (Windows Me) を使用していて、<see cref="P:System.Diagnostics.Process.PriorityClass" /> を <see langword="AboveNormal" /> または <see langword="BelowNormal" /> に設定しました。 これらのプラットフォームにおいて、優先度クラスにそれらの値はサポートされていません。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><see cref="T:System.Diagnostics.ProcessPriorityClass" /> 列挙体で定義されている有効な値が使用されていないため、優先度クラスを設定できません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
        <altmember cref="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize">
      <MemberSignature Language="C#" Value="public int PrivateMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PrivateMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PrivateMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize : int" Usage="System.Diagnostics.Process.PrivateMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PrivateMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PrivateMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivateMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PrivateMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに割り当てられたプライベート メモリの量 (バイト単位) を取得します。</summary>
        <value>関連付けられたプロセスに割り当てられ、他のプロセスと共有できないバイト数。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.PrivateMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize64">
      <MemberSignature Language="C#" Value="public long PrivateMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PrivateMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PrivateMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize64 : int64" Usage="System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivateMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに割り当てられたプライベート メモリの量 (バイト単位) を取得します。</summary>
        <value>関連付けられたプロセスに割り当てられ、他のプロセスと共有できないメモリの量 (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティによって返される値は、プロセスによって使用されるメモリの現在のサイズ (バイト単位) を表し、他のプロセスと共有することはできません。  
  
 このプロパティは、32ビットプロセッサまたは64ビットプロセッサを搭載したコンピューターのメモリ使用量を監視するために使用できます。 プロパティ値は、プロセスの**Private Bytes**パフォーマンスカウンターに相当します。  
  
   
  
## Examples  
 次のコード例では、メモ帳アプリケーションのインスタンスを起動します。 次に、この例では、関連付けられているプロセスのさまざまなプロパティを取得して表示します。 この例では、プロセスが終了したことを検出し、終了コードとピークメモリの統計情報を表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivilegedProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PrivilegedProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivilegedProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent inside the operating system core.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivilegedProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このプロセスの特権プロセッサ時間を取得します。</summary>
        <value>プロセスが、オペレーティング システム コア内でコードを実行した合計時間を示す <see cref="T:System.TimeSpan" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、メモ帳のインスタンスを起動します。 次に、この例では、関連付けられているプロセスのさまざまなプロパティを取得して表示します。 この例では、プロセスが終了したことを検出し、プロセスの終了コードを表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行されているプロセスの <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="ProcessName">
      <MemberSignature Language="C#" Value="public string ProcessName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProcessName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProcessName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProcessName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProcessName : string" Usage="System.Diagnostics.Process.ProcessName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessProcessName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロセスの名前を取得します。</summary>
        <value>システムで使用する、ユーザーがプロセスを識別するための名前。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティ<xref:System.Diagnostics.Process.ProcessName%2A>は、Outlook などの実行可能ファイル名を保持します。この名前には、.exe 拡張子やパスは含まれません。 これは、同じ実行可能ファイルに関連付けられているすべてのプロセスを取得して操作する場合に役立ちます。  
  
> [!NOTE]
>  オペレーティング[!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)]システムでは、 <xref:System.Diagnostics.Process.ProcessName%2A>プロセスモジュール情報を取得できない場合、プロパティは15文字に切り捨てられることがあります。  
  
 を呼び出し<xref:System.Diagnostics.Process.GetProcessesByName%2A>、実行可能ファイル名を渡して、指定されたコンピューター上で実行されているすべてのインスタンスを含む配列を取得できます。 たとえば、この配列を使用して、実行可能ファイルの実行中のすべてのインスタンスをシャットダウンすることができます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">プロセスに ID がないか、 <see cref="T:System.Diagnostics.Process" />に関連付けられているプロセスがありません。  
  
- または - 
関連付けられたプロセスが終了しました。</exception>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。Windows 98 や Windows Me でこのプロパティにアクセスするには <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> を <see langword="false" /> に設定します。</exception>
        <exception cref="T:System.NotSupportedException">プロセスはこのコンピューター上のものではありません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessorAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Property ProcessorAffinity As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ProcessorAffinity { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorAffinity : nativeint with get, set" Usage="System.Diagnostics.Process.ProcessorAffinity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Allowed processor that can be used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessProcessorAffinity")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このプロセスでのスレッドの実行をスケジュールできるプロセッサを取得または設定します。</summary>
        <value>関連付けられたプロセスのスレッドを実行できるプロセッサを示すビットマスク。 既定値は、コンピューターのプロセッサ数によって異なります。 既定値は 2 <sup>n</sup> -1 です。ここで、n はプロセッサ数です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows 2000 以降では、プロセス内のスレッドはプロセッサからプロセッサに移行でき、各移行でプロセッサキャッシュが再読み込みされます。 システム負荷が高い場合、特定のスレッドを実行するプロセッサを指定すると、プロセッサキャッシュを再読み込みする回数を減らすことでパフォーマンスを向上させることができます。 プロセッサとスレッド間の関連付けは、プロセッサ関係と呼ばれます。  
  
 各プロセッサは、1つのビットとして表現されます。 ビット0はプロセッサ1、ビット1はプロセッサ2、などのようになります。 ビットを値1に設定すると、対応するプロセッサがスレッド割り当てに対して選択されます。 <xref:System.Diagnostics.Process.ProcessorAffinity%2A>値を0に設定すると、オペレーティングシステムのスケジュールアルゴリズムによってスレッドのアフィニティが設定されます。 <xref:System.Diagnostics.Process.ProcessorAffinity%2A>値が0以外の値に設定されている場合、値は、選択対象のプロセッサを指定するビットマスクとして解釈されます。  
  
 次の表は、8プロセッサ<xref:System.Diagnostics.Process.ProcessorAffinity%2A>システムの値の選択を示しています。  
  
|ビットマップ|バイナリ値|対象のプロセッサ|  
|-------------|------------------|-------------------------|  
|0x0001|00000000 00000001|1|  
|0x0003|00000000 00000011|1および2|  
|0x0007|00000000 00000111|1、2、3|  
|0x0009|00000000 00001001|1および4|  
|0x007F|00000000 01111111|1、2、3、4、5、6、7|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられているプロセスのリソースから <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> 情報を設定できないか、取得できませんでした。  
  
または 
プロセス識別子またはプロセス ハンドルが 0 です。 (プロセスは開始されていません。)</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行されているプロセスの <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.InvalidOperationException">プロセス <see cref="P:System.Diagnostics.Process.Id" /> が使用できませんでした。  
  
- または - 
プロセスが終了しています。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="process.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>プロセス コンポーネントにキャッシュされている関連付けられたプロセスに関するすべての情報を破棄します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 が<xref:System.Diagnostics.Process.Refresh%2A>呼び出された後、各プロパティに関する情報の最初の要求によって、プロセスコンポーネントは、関連付けられているプロセスから新しい値を取得します。  
  
 コンポーネントがプロセスリソースに関連付けられている場合、のプロパティ<xref:System.Diagnostics.Process>値は、関連付けられているプロセスの状態に従って直ちに設定されます。 <xref:System.Diagnostics.Process> 関連付けられたプロセスに関する情報が後で変更された場合、 <xref:System.Diagnostics.Process>それらの変更はコンポーネントのキャッシュされた値に反映されません。 <xref:System.Diagnostics.Process>コンポーネントは、関連付けられた時点でのプロセスリソースのスナップショットです。 関連付けられたプロセスの現在の値を表示する<xref:System.Diagnostics.Process.Refresh%2A>には、メソッドを呼び出します。  
  
   
  
## Examples  
 次の例では、メモ帳のインスタンスを起動します。 次に、関連付けられたプロセスの物理メモリ使用量を2秒間隔で最大10秒間取得します。 この例では、10秒が経過する前にプロセスが終了するかどうかを検出します。 この例では、10秒後にプロセスがまだ実行されている場合、プロセスを終了します。  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Responding">
      <MemberSignature Language="C#" Value="public bool Responding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Responding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Responding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Responding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Responding { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Responding : bool" Usage="System.Diagnostics.Process.Responding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Is this process responsive.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessResponding")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロセスのユーザー インターフェイスが応答するかどうかを示す値を取得します。</summary>
        <value>関連付けられたプロセスのユーザー インターフェイスがシステムに応答する場合は<see langword="true" /> 。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロセスにユーザーインターフェイスがある場合、プロパティ<xref:System.Diagnostics.Process.Responding%2A>はユーザーインターフェイスに接続して、プロセスがユーザー入力に応答しているかどうかを判断します。 インターフェイスがすぐに応答しない場合、 <xref:System.Diagnostics.Process.Responding%2A>プロパティは`false`を返します。 関連付けられたプロセスのインターフェイスが応答を停止したかどうかを判断するには、このプロパティを使用します。  
  
 プロセス<xref:System.Diagnostics.Process.MainWindowHandle%2A>にがない場合、このプロパティはを返し`true`ます。  
  
   
  
## Examples  
 次の例では、メモ帳のインスタンスを起動します。 次に、この例では、関連付けられているプロセスのさまざまなプロパティを取得して表示します。 この例では、プロセスが終了したことを検出し、プロセスの終了コードを表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。Windows 98 や Windows Me でこのプロパティにアクセスするには <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> を <see langword="false" /> に設定します。</exception>
        <exception cref="T:System.InvalidOperationException">この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行されているプロセスの <see cref="P:System.Diagnostics.Process.Responding" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowHandle" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeProcessHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeProcessHandle ^ SafeHandle { Microsoft::Win32::SafeHandles::SafeProcessHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeHandle : Microsoft.Win32.SafeHandles.SafeProcessHandle" Usage="System.Diagnostics.Process.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeProcessHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このプロセスへのネイティブ ハンドルを取得します。</summary>
        <value>このプロセスへのネイティブ ハンドル。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ハンドルは、呼び出し元のコンポーネントがプロセスを開始した場合にのみ使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionId">
      <MemberSignature Language="C#" Value="public int SessionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SessionId" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SessionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SessionId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SessionId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SessionId : int" Usage="System.Diagnostics.Process.SessionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The session ID for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessSessionId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスのターミナル サービス セッション識別子を取得します。</summary>
        <value>関連付けられたプロセスのターミナル サービス セッション識別子。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティ<xref:System.Diagnostics.Process.SessionId%2A>は、アプリケーションが現在実行されているセッションを識別します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">このプロセスに関連付けられているセッションはありません。</exception>
        <exception cref="T:System.InvalidOperationException">このセッション識別子に関連付けられているプロセスはありません。  
  
 または  
  
 関連付けられたプロセスが、このコンピューター上にありません。</exception>
        <exception cref="T:System.PlatformNotSupportedException"><see cref="P:System.Diagnostics.Process.SessionId" /> プロパティは Windows 98 ではサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="StandardError">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardError" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardError" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardError As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardError { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardError : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard error stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardError")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションのエラー出力の読み取りに使用されるストリームを取得します。</summary>
        <value>アプリケーションの標準エラー ストリームの読み取りに使用できる <see cref="T:System.IO.StreamReader" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 が<xref:System.Diagnostics.Process>テキストを標準エラーストリームに書き込む場合、そのテキストは通常、コンソールに表示されます。 <xref:System.Diagnostics.Process.StandardError%2A>ストリームをリダイレクトすることにより、プロセスのエラー出力を操作または非表示にすることができます。 たとえば、テキストをフィルター処理したり、異なる形式を設定したり、コンソールと指定したログファイルの両方に出力を書き込むことができます。  
  
> [!NOTE]
>  を使用<xref:System.Diagnostics.Process.StandardError%2A>するには、 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>を`false`に設定し、を<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=nameWithType>に`true`設定する必要があります。 それ以外の場合、 <xref:System.Diagnostics.Process.StandardError%2A>ストリームからの読み取りでは例外がスローされます。  
  
 リダイレクト<xref:System.Diagnostics.Process.StandardError%2A>されたストリームは、同期的または非同期的に読み取ることができます。 、、などのメソッドは、プロセスのエラー出力ストリームに対して同期読み取り操作を実行します。<xref:System.IO.StreamReader.ReadToEnd%2A> <xref:System.IO.StreamReader.ReadLine%2A> <xref:System.IO.StreamReader.Read%2A> これらの同期読み取り操作は、関連付けら<xref:System.Diagnostics.Process>れている<xref:System.Diagnostics.Process.StandardError%2A>ストリームへの書き込みが完了するまで、またはストリームを閉じるまで完了しません。  
  
 これに対し<xref:System.Diagnostics.Process.BeginErrorReadLine%2A> <xref:System.Diagnostics.Process.StandardError%2A>て、は、ストリームに対して非同期の読み取り操作を開始します。 このメソッドは、ストリーム出力に対して指定されたイベントハンドラーを有効にし、すぐに呼び出し元に戻します。これにより、ストリーム出力がイベントハンドラーに送られている間に他の処理を実行できます。  
  
 同期読み取り操作では、 <xref:System.Diagnostics.Process.StandardError%2A>ストリームから読み取った呼び出し元と、そのストリームに書き込む子プロセスとの間に依存関係が生じます。 これらの依存関係によって、デッドロック状態が発生する可能性があります。 呼び出し元が子プロセスのリダイレクトされたストリームから読み取る場合は、子に依存します。 呼び出し元は、読み取り操作で、子がストリームに書き込むか、ストリームを閉じるまで待機します。 子プロセスは、リダイレクトされたストリームを埋めるために十分なデータを書き込むときに、親に依存します。 子プロセスは、親が完全なストリームから読み取るか、ストリームを閉じるまで、次の書き込み操作で待機します。 デッドロック状態は、呼び出し元と子プロセスが操作を完了するために互いに待機し、どちらも続行できない場合に発生します。 呼び出し元と子プロセスの間の依存関係を評価することによって、デッドロックを回避できます。  

このセクションの最後の2つの例<xref:System.Diagnostics.Process.Start%2A>では、メソッドを使用して、 *Write500Lines*という名前の実行可能ファイルを起動します。 次の例には、ソースコードが含まれています。

[!code-csharp[Executable launched by Process.Start](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/write500lines.cs)]
[!code-vb[Executable launched by Process.Start](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/write500lines.vb)]

次の例は、リダイレクトされたエラーストリームから読み取り、子プロセスが終了するまで待機する方法を示しています。 これは、の前に`p.StandardError.ReadToEnd` `p.WaitForExit`を呼び出すことによって、デッドロック状態を回避します。 デッドロック状態が発生するのは、親`p.WaitForExit`プロセス`p.StandardError.ReadToEnd`がを呼び出してから、子プロセスがリダイレクトされたストリームを埋めるために十分なテキストを書き込む場合です。 親プロセスは、子プロセスが終了するまで無期限に待機します。 子プロセスは、親が完全な<xref:System.Diagnostics.Process.StandardError%2A>ストリームから読み取るまで無制限に待機します。   

[!code-csharp[Reading from the error stream](~/samples/snippets/csharp/api/system.diagnostics/process/standarderror/stderror-sync.cs)]
[!code-vb[Reading from the error stream](~/samples/snippets/visualbasic/api/system.diagnostics/process/standarderror/stderror-sync.vb)]  

標準出力と標準エラーストリームの両方からすべてのテキストを読み取ると、同様の問題が発生します。 次の例では、両方のストリームに対して読み取り操作を実行します。 <xref:System.Diagnostics.Process.StandardError%2A>ストリームに対して非同期の読み取り操作を実行することで、デッドロック状態を回避します。 デッドロック状態が発生するのは、 `p.StandardOutput.ReadToEnd`親プロセス`p.StandardError.ReadToEnd`がを呼び出した後で、子プロセスがエラーストリームを埋めるために十分なテキストを書き込む場合です。 親プロセスは、子プロセスがその<xref:System.Diagnostics.Process.StandardOutput%2A>ストリームを閉じるまで無期限に待機します。 子プロセスは、親が完全な<xref:System.Diagnostics.Process.StandardError%2A>ストリームから読み取るまで無制限に待機します。  
[!code-csharp[Reading from both streams](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/stdoutput-async.cs)]
[!code-vb[Reading from both streams](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/stdoutput-async.vb)]  

非同期の読み取り操作を使用すると、これらの依存関係とデッドロックの可能性を回避できます。 または、2つのスレッドを作成し、各ストリームの出力を個別のスレッドで読み取ることによって、デッドロック状態を回避できます。  
  
> [!NOTE]
>  リダイレクトされたストリームでは、非同期および同期読み取り操作を混在させることはできません。 の<xref:System.Diagnostics.Process>リダイレクトされたストリームを非同期モードまたは同期モードで開くと、そのストリームのすべての読み取り操作は同じモードである必要があります。 たとえば、 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> ストリーム<xref:System.Diagnostics.Process.StandardError%2A>でを<xref:System.IO.StreamReader.ReadLine%2A>呼び出すことはできません。また、逆の場合も同様です。 ただし、異なるモードの2つの異なるストリームを読み取ることができます。 たとえば、を呼び出し<xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 、 <xref:System.Diagnostics.Process.StandardError%2A>ストリームに対して<xref:System.IO.StreamReader.ReadLine%2A>を呼び出すことができます。  
  
   
  
## Examples  
 次の例では`net use` 、ユーザーが指定した引数と共にコマンドを使用して、ネットワークリソースをマップします。 次に、net コマンドの標準エラーストリームを読み取り、コンソールに書き込みます。  
  
 [!code-cpp[Process_StandardError#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardError/CPP/source.cpp#1)]
 [!code-csharp[Process_StandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardError/CS/source.cs#1)]
 [!code-vb[Process_StandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardError/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.Process.StandardError" /> ストリームがリダイレクト用に定義されていません。<see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> が <see langword="true" /> に設定されており、<see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> が <see langword="false" /> に設定されていることを確認してください。  
  
- または - 
<see cref="P:System.Diagnostics.Process.StandardError" /> ストリームが、 <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" />を使用した非同期読み取り操作のために開いています。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
      </Docs>
    </Member>
    <Member MemberName="StandardInput">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter StandardInput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamWriter StandardInput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardInput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardInput As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamWriter ^ StandardInput { System::IO::StreamWriter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardInput : System.IO.StreamWriter" Usage="System.Diagnostics.Process.StandardInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard input stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardInput")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションの入力の書き込みに使用されるストリームを取得します。</summary>
        <value>アプリケーションの標準入力ストリームの書き込みに使用できる <see cref="T:System.IO.StreamWriter" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 は<xref:System.Diagnostics.Process> 、標準入力ストリーム (通常はキーボード) から入力テキストを読み取ることができます。 <xref:System.Diagnostics.Process.StandardInput%2A>ストリームをリダイレクトすることにより、プログラムで入力を指定できます。 たとえば、キーボード入力を使用する代わりに、指定されたファイルの内容または別のアプリケーションからの出力のテキストを指定できます。  
  
> [!NOTE]
>  を使用<xref:System.Diagnostics.Process.StandardInput%2A>するには、 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>を`false`に設定し、を<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=nameWithType>に`true`設定する必要があります。 それ以外の場合、 <xref:System.Diagnostics.Process.StandardInput%2A>ストリームへの書き込みでは例外がスローされます。  
  
   
  
## Examples  
 次の例は、プロセスの<xref:System.Diagnostics.Process.StandardInput%2A>ストリームをリダイレクトする方法を示しています。 この例では`sort` 、リダイレクトされた入力を使用してコマンドを開始します。 次に、ユーザーにテキストの入力を求めるプロンプトが表示`sort`され、リダイレクト<xref:System.Diagnostics.Process.StandardInput%2A>されたストリームを通じてプロセスに渡されます。 `sort`結果はコンソールでユーザーに表示されます。  
  
 [!code-cpp[Process_StandardInput#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardInput/CPP/process_standardinput.cpp#1)]
 [!code-csharp[Process_StandardInput#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardInput/CS/process_standardinput.cs#1)]
 [!code-vb[Process_StandardInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardInput/VB/process_standardinput.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.Process.StandardInput" /> が <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" /> に設定されているため、 <see langword="false" />ストリームが定義されませんでした。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />
      </Docs>
    </Member>
    <Member MemberName="StandardOutput">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardOutput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardOutput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardOutput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardOutput As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardOutput { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardOutput : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard output stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardOutput")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションのテキスト出力の読み取りに使用されるストリームを取得します。</summary>
        <value>アプリケーションの標準出力ストリームの読み取りに使用できる <see cref="T:System.IO.StreamReader" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 が<xref:System.Diagnostics.Process>標準のストリームにテキストを書き込む場合、そのテキストは通常、コンソールに表示されます。 <xref:System.Diagnostics.Process.StandardOutput%2A>ストリームをリダイレクトすることにより、プロセスの出力を操作または非表示にすることができます。 たとえば、テキストをフィルター処理したり、異なる形式を設定したり、コンソールと指定したログファイルの両方に出力を書き込むことができます。  
  
> [!NOTE]
>  を使用<xref:System.Diagnostics.Process.StandardOutput%2A>するには、 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>を`false`に設定し、を<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=nameWithType>に`true`設定する必要があります。 それ以外の場合、 <xref:System.Diagnostics.Process.StandardOutput%2A>ストリームからの読み取りでは例外がスローされます。  
  
 リダイレクト<xref:System.Diagnostics.Process.StandardOutput%2A>されたストリームは、同期的または非同期的に読み取ることができます。 、、などのメソッドは、プロセスの出力ストリームに対して同期読み取り操作を実行します。<xref:System.IO.StreamReader.ReadToEnd%2A> <xref:System.IO.StreamReader.ReadLine%2A> <xref:System.IO.StreamReader.Read%2A> これらの同期読み取り操作は、関連付けら<xref:System.Diagnostics.Process>れている<xref:System.Diagnostics.Process.StandardOutput%2A>ストリームへの書き込みが完了するまで、またはストリームを閉じるまで完了しません。  
  
 これに対し<xref:System.Diagnostics.Process.BeginOutputReadLine%2A> <xref:System.Diagnostics.Process.StandardOutput%2A>て、は、ストリームに対して非同期の読み取り操作を開始します。 このメソッドは、ストリーム出力に対して指定されたイベントハンドラーを有効にし、すぐに呼び出し元に戻します。これにより、ストリーム出力がイベントハンドラーに送られている間に他の処理を実行できます。  
  
 同期読み取り操作では、 <xref:System.Diagnostics.Process.StandardOutput%2A>ストリームから読み取った呼び出し元と、そのストリームに書き込む子プロセスとの間に依存関係が生じます。 これらの依存関係によって、デッドロック状態が発生する可能性があります。 呼び出し元が子プロセスのリダイレクトされたストリームから読み取る場合は、子に依存します。 呼び出し元は、読み取り操作で、子がストリームに書き込むか、ストリームを閉じるまで待機します。 子プロセスは、リダイレクトされたストリームを埋めるために十分なデータを書き込むときに、親に依存します。 子プロセスは、親が完全なストリームから読み取るか、ストリームを閉じるまで、次の書き込み操作で待機します。 デッドロック状態は、呼び出し元と子プロセスが操作を完了するために互いに待機し、どちらも続行できない場合に発生します。 呼び出し元と子プロセスの間の依存関係を評価することによって、デッドロックを回避できます。  

このセクションの最後の2つの例<xref:System.Diagnostics.Process.Start%2A>では、メソッドを使用して、 *Write500Lines*という名前の実行可能ファイルを起動します。 次の例には、ソースコードが含まれています。

[!code-csharp[Executable launched by Process.Start](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/write500lines.cs)]
[!code-vb[Executable launched by Process.Start](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/write500lines.vb)]

次の例は、リダイレクトされたストリームから読み取り、子プロセスが終了するまで待機する方法を示しています。 この例では、の前に`p.StandardOutput.ReadToEnd` `p.WaitForExit`を呼び出すことにより、デッドロック状態を回避します。 デッドロック状態が発生するのは、親`p.WaitForExit`プロセス`p.StandardOutput.ReadToEnd`がを呼び出してから、子プロセスがリダイレクトされたストリームを埋めるために十分なテキストを書き込む場合です。 親プロセスは、子プロセスが終了するまで無期限に待機します。 子プロセスは、親が完全な<xref:System.Diagnostics.Process.StandardOutput%2A>ストリームから読み取るまで無制限に待機します。  

[!code-csharp[Reading synchronously from a redirected output stream](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/stdoutput-sync.cs)]  
[!code-vb[Reading synchronously from a redirected output stream](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/stdoutput-sync.vb)]  

標準出力と標準エラーストリームの両方からすべてのテキストを読み取ると、同様の問題が発生します。 次の例では、両方のストリームに対して読み取り操作を実行します。 <xref:System.Diagnostics.Process.StandardError%2A>ストリームに対して非同期の読み取り操作を実行することで、デッドロック状態を回避します。 デッドロック状態が発生するのは、 `p.StandardOutput.ReadToEnd`親プロセス`p.StandardError.ReadToEnd`がを呼び出した後で、子プロセスがエラーストリームを埋めるために十分なテキストを書き込む場合です。 親プロセスは、子プロセスがその<xref:System.Diagnostics.Process.StandardOutput%2A>ストリームを閉じるまで無期限に待機します。 子プロセスは、親が完全な<xref:System.Diagnostics.Process.StandardError%2A>ストリームから読み取るまで無制限に待機します。   
[!code-csharp[Reading from a redirected output and error stream](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/stdoutput-async.cs)]  
[!code-vb[Reading from a redirected output and error stream](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/stdoutput-async.vb)]    
  
 非同期の読み取り操作を使用すると、これらの依存関係とデッドロックの可能性を回避できます。 または、2つのスレッドを作成し、各ストリームの出力を個別のスレッドで読み取ることによって、デッドロック状態を回避できます。  
  
> [!NOTE]
>  リダイレクトされたストリームでは、非同期および同期読み取り操作を混在させることはできません。 の<xref:System.Diagnostics.Process>リダイレクトされたストリームを非同期モードまたは同期モードで開くと、そのストリームのすべての読み取り操作は同じモードである必要があります。 たとえば、 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> ストリーム<xref:System.Diagnostics.Process.StandardOutput%2A>でを<xref:System.IO.StreamReader.ReadLine%2A>呼び出すことはできません。また、逆の場合も同様です。 ただし、異なるモードの2つの異なるストリームを読み取ることができます。 たとえば、を呼び出し<xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 、 <xref:System.Diagnostics.Process.StandardError%2A>ストリームに対して<xref:System.IO.StreamReader.ReadLine%2A>を呼び出すことができます。  
  
   
  
## Examples  
 次の例では、ipconfig コマンドを実行し、その標準出力を例のコンソールウィンドウにリダイレクトします。  
  
 [!code-cpp[Process_StandardOutput#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardOutput/CPP/process_standardoutput.cpp#2)]
 [!code-csharp[Process_StandardOutput#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardOutput/CS/process_standardoutput.cs#2)]
 [!code-vb[Process_StandardOutput#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardOutput/VB/process_standardoutput.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.Process.StandardOutput" /> ストリームがリダイレクト用に定義されていません。<see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> が <see langword="true" /> に設定されており、<see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> が <see langword="false" /> に設定されていることを確認してください。  
  
または 
<see cref="P:System.Diagnostics.Process.StandardOutput" /> ストリームが、 <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" />を使用した非同期読み取り操作のために開いています。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>プロセス リソースを起動し、<see cref="T:System.Diagnostics.Process" /> コンポーネントに関連付けます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public bool Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start" />
      <MemberSignature Language="VB.NET" Value="Public Function Start () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; bool" Usage="process.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この <see cref="P:System.Diagnostics.Process.StartInfo" /> コンポーネントの <see cref="T:System.Diagnostics.Process" /> プロパティで指定されたプロセス リソースを起動 (または再利用) し、コンポーネントに関連付けます。</summary>
        <returns>プロセス リソースが起動された場合は <see langword="true" />。新しいプロセス リソースが起動されなかった場合は <see langword="false" /> (既存のプロセスを再利用した場合など)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードを使用して、プロセスリソースを起動し、現在<xref:System.Diagnostics.Process>のコンポーネントに関連付けます。 戻り値`true`は、新しいプロセスリソースが開始されたことを示します。 プロパティのメンバー<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>によって指定されたプロセスリソースが既にコンピューター上で実行されている場合、追加のプロセスリソースは起動されません。 <xref:System.Diagnostics.Process.StartInfo%2A> 代わりに、実行中のプロセスリソースが再`false`利用され、が返されます。  
  
 ClickOnce アプリケーションを起動するには、最初にアプリケーションをインストールした場所 (Web アドレスなど) を指定します。 ClickOnce アプリケーションは、ハードドライブにインストールされている場所を指定することによって起動しないでください。  
  
> [!NOTE]
>  Visual Studio を使用している場合は、コンポーネント<xref:System.Diagnostics.Process.Start%2A>を<xref:System.Diagnostics.Process>デザイナーにドラッグした後に、コードに挿入するメソッドのオーバーロードが使用されます。 ウィンドウを使用して、 `StartInfo`カテゴリを展開し、 `FileName`プロパティに適切な値を書き込みます。 `Properties` 変更内容がフォームの`InitializeComponent`手順に表示されます。  
  
 の<xref:System.Diagnostics.Process.Start%2A>このオーバーロードはメソッドで`static`はありません。 これは、 <xref:System.Diagnostics.Process>クラスのインスタンスから呼び出す必要があります。 を呼び出す<xref:System.Diagnostics.Process.Start%2A>前に、最初に<xref:System.Diagnostics.Process.StartInfo%2A>このインスタンスのプロパティ<xref:System.Diagnostics.Process>情報を指定する必要があります。これは、開始するプロセスリソースを決定するためにその情報が使用されるためです。  
  
 <xref:System.Diagnostics.Process.Start%2A>メソッドの他のオーバーロードは、メンバーです。 `static` メソッドのオーバーロードを呼び出す前に、 <xref:System.Diagnostics.Process>コンポーネントのインスタンスを作成する必要はありません。 代わりに、 <xref:System.Diagnostics.Process>クラス自体に<xref:System.Diagnostics.Process.Start%2A>対してを呼び出すことができ<xref:System.Diagnostics.Process> 、プロセスが開始された場合は新しいコンポーネントが作成されます。 または`null` 、プロセスが再利用された場合は、が返されます。 プロセスリソースは、 <xref:System.Diagnostics.Process> <xref:System.Diagnostics.Process.Start%2A>メソッドによって返される新しいコンポーネントに自動的に関連付けられます。  
  
 メンバーを使用して、Windows `Start`メニューの`Run`ダイアログボックスの機能を複製することができます。 <xref:System.Diagnostics.Process.StartInfo%2A> コマンドラインに入力できるものは、 <xref:System.Diagnostics.Process.StartInfo%2A>プロパティに適切な値を設定することによって開始できます。 設定する<xref:System.Diagnostics.Process.StartInfo%2A>必要があるプロパティは、 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>プロパティだけです。 プロパティ<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>は、実行可能ファイルである必要はありません。 拡張子がシステムにインストールされているアプリケーションに関連付けられている任意のファイルの種類を指定できます。 たとえば、テキストファイル<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>がメモ帳などのエディターに関連付けられている場合、プロパティには拡張子 .txt を付けることができます。また、Microsoft word などのワードプロセッシングツールで .doc ファイルに関連付けられている場合は、.doc 拡張子を持つことができます。  
  
 コマンドラインでは、特定の種類のファイルに対して実行するアクションを指定できます。 たとえば、ドキュメントを印刷したり、テキストファイルを編集したりできます。 プロパティのメンバーを使用<xref:System.Diagnostics.ProcessStartInfo.Verb%2A>して、これらのアクションを指定します。 <xref:System.Diagnostics.Process.StartInfo%2A> その他の種類のファイルについては、 `Run`ダイアログボックスからファイルを起動するときに、コマンドライン引数を指定できます。 たとえば、ブラウザーをと<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>して指定した場合、URL を引数として渡すことができます。 これらの引数は、 <xref:System.Diagnostics.Process.StartInfo%2A>プロパティの<xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>メンバーで指定できます。  
  
 システムでパス変数を引用符で囲んで宣言している場合、その場所で見つかるプロセスを開始するときに、そのパスを完全修飾する必要があります。 そうしないと、システムはそのパスを見つけられません。 たとえば、`c:\mypath` がパスに含まれておらず、それを `path = %path%;"c:\mypath"`` のように引用符を使用して追加した場合、`c:\mypath` 内の任意のプロセスを開始するときに、それを完全修飾する必要があります。  
  
> [!NOTE]
>  ASP.NET Web ページとサーバーコントロールのコードは、Web サーバー上の ASP.NET ワーカープロセスのコンテキストで実行されます。  ASP.NET web ページまた<xref:System.Diagnostics.Process.Start%2A>はサーバーコントロールでメソッドを使用すると、新しいプロセスはアクセス許可が制限された web サーバー上で実行されます。 このプロセスは、クライアントのブラウザーと同じコンテキストで開始されることはなく、ユーザーのデスクトップへのアクセス権も持っていません。  
  
 を使用<xref:System.Diagnostics.Process.Start%2A>してプロセスを開始するときは常に、プロセスを閉じる必要があります。そうしないと、システムリソースが失われる危険性があります。 または<xref:System.Diagnostics.Process.CloseMainWindow%2A> <xref:System.Diagnostics.Process.Kill%2A>を使用してプロセスを終了します。 プロセスが既に閉じられているかどうかは<xref:System.Diagnostics.Process.HasExited%2A> 、そのプロパティを使用して確認できます。  
  
 マネージスレッドのアパートメント状態に関する注意事項については、こちらを参照してください。 が<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>プロセスコンポーネントの`main()` `true` <xref:System.Diagnostics.Process.StartInfo%2A>プロパティにある場合は、メソッドの属性`[STAThread]`を設定して、アプリケーションにスレッドモデルを設定していることを確認します。 それ以外の場合、マネージスレッドは状態`unknown`にするか、 `MTA`状態にすることができ`true`ます。後者<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>の場合は、との競合が発生します。 一部のメソッドでは`unknown`、アパートメント状態をにする必要がありません。 状態が明示的に設定されていない場合、アプリケーションでこのようなメソッド`MTA`が検出されると、既定でに設定されます。これにより、アパートメント状態を変更することはできません。 ただし、 `MTA`では、オペレーティングシステムシェルがスレッドを管理しているときに例外がスローされます。  
  
   
  
## Examples  
 次の例では、 <xref:System.Diagnostics.Process>クラスのインスタンスを使用してプロセスを開始します。  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Diagnostics.Process" /> コンポーネントの <see cref="P:System.Diagnostics.Process.StartInfo" /> にファイル名が指定されませんでした。
あるいは、<see cref="P:System.Diagnostics.Process.StartInfo" /> プロパティの<see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> メンバーは <see langword="true" /> ですが、<see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />、<see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />、または <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> は <see langword="true" /> です。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられているファイルを開いているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">プロセス オブジェクトは既には破棄されています。</exception>
        <exception cref="T:System.PlatformNotSupportedException">メソッドはシェルがサポートされていない Nano Server (.NET Core のみ) などのオペレーティング システムではサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (System.Diagnostics.ProcessStartInfo startInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(class System.Diagnostics.ProcessStartInfo startInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (startInfo As ProcessStartInfo) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::Diagnostics::ProcessStartInfo ^ startInfo);" />
      <MemberSignature Language="F#" Value="static member Start : System.Diagnostics.ProcessStartInfo -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start startInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startInfo" Type="System.Diagnostics.ProcessStartInfo" />
      </Parameters>
      <Docs>
        <param name="startInfo">ファイル名やコマンド ライン引数など、プロセスの起動に使用する情報が格納されている <see cref="T:System.Diagnostics.ProcessStartInfo" />。</param>
        <summary>プロセス起動情報 (起動するプロセスのファイル名など) が格納されているパラメーターで指定されたプロセス リソースを起動し、リソースを新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントに関連付けます。</summary>
        <returns>プロセス リソースに関連付けられている新しい <see cref="T:System.Diagnostics.Process" />。プロセス リソースが起動されていない場合は <see langword="null" />。 同じプロセスのインスタンスが既に実行されているときに起動された新しいプロセスは、他のインスタンスから独立します。 また、Start では、<see cref="P:System.Diagnostics.Process.HasExited" /> プロパティが既に <see langword="true" /> に設定されている null 以外の Process が返される場合があります。 その場合、起動されたプロセス自体の既存のインスタンスがアクティブ化され、その後に終了されることがあります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インスタンスを<xref:System.Diagnostics.ProcessStartInfo>指定してプロセスリソースを開始するには、このオーバーロードを使用します。 オーバーロードによって、リソースが新しい<xref:System.Diagnostics.Process>オブジェクトに関連付けられます。  
  
> [!NOTE]
>  開始する実行可能ファイルのアドレスが URL の場合、プロセスは開始`null`されず、が返されます。  
  
 このオーバーロードを使用すると、最初に新しい<xref:System.Diagnostics.Process>インスタンスを作成せずにプロセスを開始できます。 この<xref:System.Diagnostics.ProcessStartInfo>オーバーロードをパラメーターと共に使用することは、新しい<xref:System.Diagnostics.Process.StartInfo%2A> <xref:System.Diagnostics.Process>インスタンスを作成し、そのプロパティを設定して、 <xref:System.Diagnostics.Process.Start%2A> <xref:System.Diagnostics.Process>インスタンスのを呼び出すための明示的な手順の代替手段です。  
  
 インスタンスを<xref:System.Diagnostics.ProcessStartInfo>パラメーターとして使用すると<xref:System.Diagnostics.Process.Start%2A> 、呼び出しに渡されたものに対して最も制御が必要になり、プロセスを開始できます。 ファイル名またはファイル名と引数だけを渡す必要がある場合は、新しい<xref:System.Diagnostics.ProcessStartInfo>インスタンスを作成する必要はありませんが、これはオプションです。 設定する<xref:System.Diagnostics.Process.StartInfo%2A?displayProperty=nameWithType>必要があるプロパティは、 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>プロパティだけです。 プロパティ<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>は、実行可能ファイルを表す必要はありません。 拡張子がシステムにインストールされているアプリケーションに関連付けられている任意のファイルの種類を指定できます。 たとえば、テキストファイル<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>がメモ帳などのエディターに関連付けられている場合、プロパティには拡張子 .txt を付けることができます。また、Microsoft word などのワードプロセッシングツールで .doc ファイルに関連付けられている場合は、.doc 拡張子を持つことができます。  
  
 ClickOnce アプリケーションを起動するには、最初にアプリケーションをインストールした場所 (Web アドレスなど) を指定します。 ClickOnce アプリケーションは、ハードドライブにインストールされている場所を指定することによって起動しないでください。  
  
 <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A?displayProperty=nameWithType> `CreateProcessWithLogonW`インスタンスの`true`プロパティとプロパティが設定されている場合、アンマネージ関数が呼び出されます。これにより、プロパティ値がまたはの場合でも、新しいウィンドウでプロセスが開始されます。 <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> <xref:System.Diagnostics.Process.StartInfo%2A> <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A?displayProperty=nameWithType>プロパティ値が<xref:System.Diagnostics.ProcessWindowStyle.Hidden?displayProperty=nameWithType>です。 <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> ** **@プロパティが`null`の場合、プロパティは UPN 形式 (user DNS_domain_name) である必要があります。 <xref:System.Diagnostics.ProcessStartInfo.Domain%2A?displayProperty=nameWithType>   
  
 他のオーバーロードとは異なり、パラメーター <xref:System.Diagnostics.Process.Start%2A>を持たないのオーバーロードはメンバー `static`ではありません。 <xref:System.Diagnostics.Process>インスタンスを既に作成し、開始情報 (ファイル名を含む) を指定し、プロセスリソースを起動して既存<xref:System.Diagnostics.Process>のインスタンスに関連付ける場合は、そのオーバーロードを使用します。 既存のコンポーネントの`static`プロセスを開始するのではなく<xref:System.Diagnostics.Process> 、新しいコンポーネントを作成する場合は、オーバーロードのいずれかを使用します。 このオーバーロードと、パラメーターを持たないオーバーロードの両方で、 <xref:System.Diagnostics.ProcessStartInfo>インスタンスを使用してプロセスリソースの開始情報を指定できます。  
  
 システムでパス変数を引用符で囲んで宣言している場合、その場所で見つかるプロセスを開始するときに、そのパスを完全修飾する必要があります。 そうしないと、システムはそのパスを見つけられません。 たとえば、`c:\mypath` がパスに含まれておらず、それを `path = %path%;"c:\mypath"`` のように引用符を使用して追加した場合、`c:\mypath` 内の任意のプロセスを開始するときに、それを完全修飾する必要があります。  
  
> [!NOTE]
>  ASP.NET Web ページとサーバーコントロールのコードは、Web サーバー上の ASP.NET ワーカープロセスのコンテキストで実行されます。  ASP.NET web ページまた<xref:System.Diagnostics.Process.Start%2A>はサーバーコントロールでメソッドを使用すると、新しいプロセスはアクセス許可が制限された web サーバー上で実行されます。 このプロセスは、クライアントのブラウザーと同じコンテキストで開始されることはなく、ユーザーのデスクトップへのアクセス権も持っていません。  
  
 を使用<xref:System.Diagnostics.Process.Start%2A>してプロセスを開始するときは常に、プロセスを閉じる必要があります。そうしないと、システムリソースが失われる危険性があります。 または<xref:System.Diagnostics.Process.CloseMainWindow%2A> <xref:System.Diagnostics.Process.Kill%2A>を使用してプロセスを終了します。 プロセスが既に閉じられているかどうかは<xref:System.Diagnostics.Process.HasExited%2A> 、そのプロパティを使用して確認できます。  
  
 マネージスレッドのアパートメント状態に関する注意事項については、こちらを参照してください。 が<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> `true` `[STAThread]` `main()`パラメーターに設定されている場合は、メソッドの属性を設定することによって、アプリケーションにスレッドモデルが設定されていることを確認してください。 `startInfo` それ以外の場合、マネージスレッドは状態`unknown`にするか、 `MTA`状態にすることができ`true`ます。後者<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>の場合は、との競合が発生します。 一部のメソッドでは`unknown`、アパートメント状態をにする必要がありません。 状態が明示的に設定されていない場合、アプリケーションでこのようなメソッド`MTA`が検出されると、既定でに設定されます。これにより、アパートメント状態を変更することはできません。 ただし、 `MTA`では、オペレーティングシステムシェルがスレッドを管理しているときに例外がスローされます。  
  
   
  
## Examples  
 次の例では、まず Internet Explorer のインスタンスを生成し、ブラウザーにお気に入りフォルダーの内容を表示します。 その後、Internet Explorer の他のインスタンスを起動し、特定のページまたはサイトを表示します。 最後に、特定のサイトに移動しているときに最小化されたウィンドウで Internet Explorer を起動します。  
  
 このメソッドの他の使用例については、 <xref:System.Diagnostics.ProcessStartInfo>クラスの個々のプロパティを参照してください。  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="startInfo" /> パラメーターの <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> プロパティにファイル名が指定されませんでした。  
  
または 
<paramref name="startInfo" /> パラメーターの <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> プロパティは <see langword="true" /> であり、<see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />、<see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />、または <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> プロパティも <see langword="true" /> です。  
  
- または - 
<paramref name="startInfo" /> パラメーターの <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> プロパティは <see langword="true" /> であり、<see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> プロパティは <see langword="null" /> でも空でもないか、または <see cref="P:System.Diagnostics.ProcessStartInfo.Password" /> プロパティは <see langword="null" /> ではありません。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="startInfo" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ObjectDisposedException">プロセス オブジェクトは既には破棄されています。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="startInfo" /> パラメーターの <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> プロパティに指定されたファイルを見つけることができませんでした。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられているファイルを開いているときにエラーが発生しました。  
  
 または  
  
 引数の長さとプロセスへの完全パスの長さの合計が、2080 文字を超えています。 この例外に関連付けられたエラー メッセージは、次のいずれかになります。"システム コールに渡されるデータ領域が小さすぎます" または「アクセスが拒否されました。」</exception>
        <exception cref="T:System.PlatformNotSupportedException">メソッドはシェルがサポートされていない Nano Server (.NET Core のみ) などのオペレーティング システムではサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member Start : string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">プロセスで実行する文書またはアプリケーション ファイルの名前。</param>
        <summary>文書またはアプリケーション ファイルの名前を指定してプロセス リソースを起動し、リソースを新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントに関連付けます。</summary>
        <returns>プロセス リソースに関連付けられている新しい <see cref="T:System.Diagnostics.Process" />。プロセス リソースが起動されていない場合は <see langword="null" />。 同じプロセスのインスタンスが既に実行されているときに起動された新しいプロセスは、他のインスタンスから独立します。 また、Start では、<see cref="P:System.Diagnostics.Process.HasExited" /> プロパティが既に <see langword="true" /> に設定されている null 以外の Process が返される場合があります。 その場合、起動されたプロセス自体の既存のインスタンスがアクティブ化され、その後に終了されることがあります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードを使用して、ファイル名を指定してプロセスリソースを開始します。 オーバーロードによって、リソースが新しい<xref:System.Diagnostics.Process>オブジェクトに関連付けられます。  
  
> [!NOTE]
>  開始する実行可能ファイルのアドレスが URL の場合、プロセスは開始`null`されず、が返されます。  
  
 このオーバーロードを使用すると、最初に新しい<xref:System.Diagnostics.Process>インスタンスを作成せずにプロセスを開始できます。 オーバーロードは<xref:System.Diagnostics.Process> 、新しいインスタンスを作成し、 <xref:System.Diagnostics.Process.StartInfo%2A>プロパティの<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>メンバーを設定して、 <xref:System.Diagnostics.Process>インスタンスのを呼び出す<xref:System.Diagnostics.Process.Start%2A>ための明示的な手順の代わりに使用されます。  
  
 ClickOnce アプリケーションを起動するには、最初`fileName`にアプリケーションをインストールした場所 (Web アドレスなど) にパラメーターを設定します。 ClickOnce アプリケーションは、ハードドライブにインストールされている場所を指定することによって起動しないでください。  
  
 ファイル名を指定してプロセスを開始することは、Windows `Run` `Start`メニューのダイアログボックスに情報を入力することと似ています。 このため、ファイル名は実行可能ファイルを表す必要はありません。 これは、システムにインストールされているアプリケーションに拡張機能が関連付けられている任意のファイルの種類にすることができます。 たとえば、メモ帳などのテキストファイルがエディターに関連付けられている場合、ファイル名の拡張子は .txt にすることができます。また、Microsoft Word などのワードプロセッシングツールを使用して .doc ファイルに関連付けられている場合は、.doc を使用することもできます。 同様に、 `Run`ダイアログボックスが .exe 拡張子の有無にかかわらず実行可能ファイル名を受け入れるようにするのと同様に、 `fileName`パラメーターの .exe 拡張子は省略可能です。 たとえば、 `fileName`パラメーターを "notepad.exe" または "notepad" に設定できます。  
  
 このオーバーロードでは、プロセスのコマンドライン引数は許可されません。 プロセスに対して1つ以上のコマンドライン引数を指定する必要がある場合<xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType>は<xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=nameWithType> 、またはのオーバーロードを使用します。  
  
 他のオーバーロードとは異なり、パラメーター <xref:System.Diagnostics.Process.Start%2A>を持たないのオーバーロードはメンバー `static`ではありません。 <xref:System.Diagnostics.Process>インスタンスを既に作成し、開始情報 (ファイル名を含む) を指定し、プロセスリソースを起動して既存<xref:System.Diagnostics.Process>のインスタンスに関連付ける場合は、そのオーバーロードを使用します。 既存のコンポーネントの`static`プロセスを開始するのではなく<xref:System.Diagnostics.Process> 、新しいコンポーネントを作成する場合は、オーバーロードのいずれかを使用します。 このオーバーロードと、パラメーターを持たないオーバーロードの両方で、開始するプロセスリソースのファイル名を指定できます。  
  
 システムでパス変数を引用符で囲んで宣言している場合、その場所で見つかるプロセスを開始するときに、そのパスを完全修飾する必要があります。 そうしないと、システムはそのパスを見つけられません。 たとえば、`c:\mypath` がパスに含まれておらず、それを `path = %path%;"c:\mypath"`` のように引用符を使用して追加した場合、`c:\mypath` 内の任意のプロセスを開始するときに、それを完全修飾する必要があります。  
  
> [!NOTE]
>  ASP.NET Web ページとサーバーコントロールのコードは、Web サーバー上の ASP.NET ワーカープロセスのコンテキストで実行されます。  ASP.NET web ページまた<xref:System.Diagnostics.Process.Start%2A>はサーバーコントロールでメソッドを使用すると、新しいプロセスはアクセス許可が制限された web サーバー上で実行されます。 このプロセスは、クライアントのブラウザーと同じコンテキストで開始されることはなく、ユーザーのデスクトップへのアクセス権も持っていません。  
  
 を使用<xref:System.Diagnostics.Process.Start%2A>してプロセスを開始するときは常に、プロセスを閉じる必要があります。そうしないと、システムリソースが失われる危険性があります。 または<xref:System.Diagnostics.Process.CloseMainWindow%2A> <xref:System.Diagnostics.Process.Kill%2A>を使用してプロセスを終了します。 プロセスが既に閉じられているかどうかは<xref:System.Diagnostics.Process.HasExited%2A> 、そのプロパティを使用して確認できます。  
  
 マネージスレッドのアパートメント状態に関する注意事項については、こちらを参照してください。 が<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>プロセスコンポーネントの`main()` `true` <xref:System.Diagnostics.Process.StartInfo%2A>プロパティにある場合は、メソッドの属性`[STAThread]`を設定して、アプリケーションにスレッドモデルを設定していることを確認します。 それ以外の場合、マネージスレッドは状態`unknown`にするか、 `MTA`状態にすることができ`true`ます。後者<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>の場合は、との競合が発生します。 一部のメソッドでは`unknown`、アパートメント状態をにする必要がありません。 状態が明示的に設定されていない場合、アプリケーションでこのようなメソッド`MTA`が検出されると、既定でに設定されます。これにより、アパートメント状態を変更することはできません。 ただし、 `MTA`では、オペレーティングシステムシェルがスレッドを管理しているときに例外がスローされます。  
  
   
  
## Examples  
 次の例では、まず Internet Explorer のインスタンスを生成し、ブラウザーにお気に入りフォルダーの内容を表示します。 その後、Internet Explorer の他のインスタンスを起動し、特定のページまたはサイトを表示します。 最後に、特定のサイトに移動しているときに最小化されたウィンドウで Internet Explorer を起動します。  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられているファイルを開いているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">プロセス オブジェクトは既には破棄されています。</exception>
        <exception cref="T:System.IO.FileNotFoundException">PATH 環境変数に、引用符を含む文字列があります。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Start : string * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">プロセスで実行するアプリケーション ファイルの名前。</param>
        <param name="arguments">プロセスを起動するときに渡すコマンド ライン引数。</param>
        <summary>アプリケーションの名前とコマンド ライン引数のセットを指定してプロセス リソースを起動し、リソースを新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントに関連付けます。</summary>
        <returns>プロセス リソースに関連付けられている新しい <see cref="T:System.Diagnostics.Process" />。プロセス リソースが起動されていない場合は <see langword="null" />。 同じプロセスのインスタンスが既に実行されているときに起動された新しいプロセスは、他のインスタンスから独立します。 また、Start では、<see cref="P:System.Diagnostics.Process.HasExited" /> プロパティが既に <see langword="true" /> に設定されている null 以外の Process が返される場合があります。 その場合、起動されたプロセス自体の既存のインスタンスがアクティブ化され、その後に終了されることがあります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ファイル名とコマンドライン引数を指定してプロセスリソースを開始するには、このオーバーロードを使用します。 オーバーロードによって、リソースが新しい<xref:System.Diagnostics.Process>オブジェクトに関連付けられます。  
  
> [!NOTE]
>  開始する実行可能ファイルのアドレスが URL の場合、プロセスは開始`null`されず、が返されます。  
  
 このオーバーロードを使用すると、最初に新しい<xref:System.Diagnostics.Process>インスタンスを作成せずにプロセスを開始できます。 <xref:System.Diagnostics.Process>オーバーロードは、新しいインスタンスを作成するための明示的な手順の代わりに、 <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> <xref:System.Diagnostics.Process.StartInfo%2A>プロパティ<xref:System.Diagnostics.Process>の<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>とメンバーを設定し<xref:System.Diagnostics.Process.Start%2A> 、インスタンスのを呼び出すためのものです。  
  
 ファイル名と引数を指定してプロセスを開始することは、Windows `Run` `Start`メニューのダイアログボックスでファイル名とコマンドライン引数を入力することと似ています。 このため、ファイル名は実行可能ファイルを表す必要はありません。 これは、システムにインストールされているアプリケーションに拡張機能が関連付けられている任意のファイルの種類にすることができます。 たとえば、メモ帳などのテキストファイルがエディターに関連付けられている場合、ファイル名の拡張子は .txt にすることができます。また、Microsoft Word などのワードプロセッシングツールを使用して .doc ファイルに関連付けられている場合は、.doc を使用することもできます。 同様に、 `Run`ダイアログボックスが .exe 拡張子の有無にかかわらず実行可能ファイル名を受け入れるようにするのと同様に、 `fileName`パラメーターの .exe 拡張子は省略可能です。 たとえば、 `fileName`パラメーターを "notepad.exe" または "notepad" に設定できます。 パラメーターが`fileName`実行可能ファイルを表す場合、 `arguments`パラメーターは、の`Notepad.exe myfile.txt`テキストファイルなど、操作対象のファイルを表す場合があります。 パラメーターが`fileName`コマンド (.cmd) ファイルを表す場合`arguments` 、パラメーターには、コマンドウィンドウを終了`/c`するか、`/k`完了後に残すかを指定する "" または "" 引数のいずれかを含める必要があります。  
  
 他のオーバーロードとは異なり、パラメーター <xref:System.Diagnostics.Process.Start%2A>を持たないのオーバーロードはメンバー `static`ではありません。 <xref:System.Diagnostics.Process>インスタンスを既に作成し、開始情報 (ファイル名を含む) を指定し、プロセスリソースを起動して既存<xref:System.Diagnostics.Process>のインスタンスに関連付ける場合は、そのオーバーロードを使用します。 既存のコンポーネントの`static`プロセスを開始するのではなく<xref:System.Diagnostics.Process> 、新しいコンポーネントを作成する場合は、オーバーロードのいずれかを使用します。 このオーバーロードと、パラメーターを持たないオーバーロードの両方で、開始するプロセスリソースのファイル名と渡すコマンドライン引数を指定できます。  
  
 システムでパス変数を引用符で囲んで宣言している場合、その場所で見つかるプロセスを開始するときに、そのパスを完全修飾する必要があります。 そうしないと、システムはそのパスを見つけられません。 たとえば、`c:\mypath` がパスに含まれておらず、それを `path = %path%;"c:\mypath"`` のように引用符を使用して追加した場合、`c:\mypath` 内の任意のプロセスを開始するときに、それを完全修飾する必要があります。  
  
> [!NOTE]
>  ASP.NET Web ページとサーバーコントロールのコードは、Web サーバー上の ASP.NET ワーカープロセスのコンテキストで実行されます。  ASP.NET web ページまた<xref:System.Diagnostics.Process.Start%2A>はサーバーコントロールでメソッドを使用すると、新しいプロセスはアクセス許可が制限された web サーバー上で実行されます。 このプロセスは、クライアントのブラウザーと同じコンテキストで開始されることはなく、ユーザーのデスクトップへのアクセス権も持っていません。  
  
 を使用<xref:System.Diagnostics.Process.Start%2A>してプロセスを開始するときは常に、プロセスを閉じる必要があります。そうしないと、システムリソースが失われる危険性があります。 または<xref:System.Diagnostics.Process.CloseMainWindow%2A> <xref:System.Diagnostics.Process.Kill%2A>を使用してプロセスを終了します。 プロセスが既に閉じられているかどうかは<xref:System.Diagnostics.Process.HasExited%2A> 、そのプロパティを使用して確認できます。 
  
 マネージスレッドのアパートメント状態に関する注意事項については、こちらを参照してください。 が<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>プロセスコンポーネントの`main()` `true` <xref:System.Diagnostics.Process.StartInfo%2A>プロパティにある場合は、メソッドの属性`[STAThread]`を設定して、アプリケーションにスレッドモデルを設定していることを確認します。 それ以外の場合、マネージスレッドは状態`unknown`にするか、 `MTA`状態にすることができ`true`ます。後者<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>の場合は、との競合が発生します。 一部のメソッドでは`unknown`、アパートメント状態をにする必要がありません。 状態が明示的に設定されていない場合、アプリケーションでこのようなメソッド`MTA`が検出されると、既定でに設定されます。これにより、アパートメント状態を変更することはできません。 ただし、 `MTA`では、オペレーティングシステムシェルがスレッドを管理しているときに例外がスローされます。  
  
   
  
## Examples  
 次の例では、まず Internet Explorer のインスタンスを生成し、ブラウザーにお気に入りフォルダーの内容を表示します。 その後、Internet Explorer の他のインスタンスを起動し、特定のページまたはサイトを表示します。 最後に、特定のサイトに移動しているときに最小化されたウィンドウで Internet Explorer を起動します。  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="fileName" /> パラメーターまたは <paramref name="arguments" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられているファイルを開いているときにエラーが発生しました。  
  
 または  
  
 引数の長さとプロセスへの完全パスの長さの合計が、2080 文字を超えています。 この例外に関連付けられたエラー メッセージは、次のいずれかになります。"システム コールに渡されるデータ領域が小さすぎます" または「アクセスが拒否されました。」</exception>
        <exception cref="T:System.ObjectDisposedException">プロセス オブジェクトは既には破棄されています。</exception>
        <exception cref="T:System.IO.FileNotFoundException">PATH 環境変数に、引用符を含む文字列があります。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="userName" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="password" Type="System.Security.SecureString" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="domain" Type="System.String" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">プロセスで実行するアプリケーション ファイルの名前。</param>
        <param name="userName">プロセスの開始時に使用するユーザー名。</param>
        <param name="password">プロセスを開始するときに使用するパスワードを含む <see cref="T:System.Security.SecureString" />。</param>
        <param name="domain">プロセスの開始時に使用するドメイン。</param>
        <summary>アプリケーションの名前、ユーザー名、パスワード、ドメインを指定してプロセス リソースを起動し、リソースを新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントに関連付けます。</summary>
        <returns>プロセス リソースに関連付けられている新しい <see cref="T:System.Diagnostics.Process" />。プロセス リソースが起動されていない場合は <see langword="null" />。 同じプロセスのインスタンスが既に実行されているときに起動された新しいプロセスは、他のインスタンスから独立します。 また、Start では、<see cref="P:System.Diagnostics.Process.HasExited" /> プロパティが既に <see langword="true" /> に設定されている null 以外の Process が返される場合があります。 その場合、起動されたプロセス自体の既存のインスタンスがアクティブ化され、その後に終了されることがあります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードを使用して、ファイル名、ユーザー名、パスワード、およびドメインを指定することにより、新しいプロセスとそのプライマリスレッドを作成します。 新しいプロセスは、指定された実行可能ファイルを、指定した資格情報 (ユーザー、ドメイン、およびパスワード) のセキュリティコンテキストで実行します。  
  
> [!NOTE]
>  実行可能ファイルがリモートドライブにある場合は、リンクされたドライブ文字ではなく、uniform resource identifier (URI) を使用してネットワーク共有を識別する必要があります。  
  
> [!NOTE]
>  開始する実行可能ファイルのアドレスが URL の場合、プロセスは開始`null`されず、が返されます。  
  
 このオーバーロードを使用すると、最初に新しい<xref:System.Diagnostics.Process>インスタンスを作成せずにプロセスを開始できます。 オーバーロードは<xref:System.Diagnostics.Process> 、新しいインスタンスを作成するための明示的な手順の代わりに、 <xref:System.Diagnostics.ProcessStartInfo.UserName%2A> <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> <xref:System.Diagnostics.Process.StartInfo%2A>プロパティ<xref:System.Diagnostics.ProcessStartInfo.Password%2A>の、 <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> 、、の各プロパティを設定<xref:System.Diagnostics.Process.Start%2A>し、を呼び出すためのものです。<xref:System.Diagnostics.Process>インスタンス。  
  
 同様に、[ファイル名を指定して**実行**] ダイアログボックスが .exe 拡張子の有無にかかわらず、実行可能ファイル名を受け入れる場合と同じよう`fileName`に、.exe 拡張子はパラメーターで省略可能です。 たとえば、 `fileName`パラメーターを "notepad.exe" または "notepad" に設定できます。 パラメーターが`fileName`実行可能ファイルを表す場合、 `arguments`パラメーターは、の`Notepad.exe myfile.txt`テキストファイルなど、操作対象のファイルを表す場合があります。  
  
> [!NOTE]
>  ファイル名は<xref:System.Diagnostics.Process.Start%2A> 、、 `password`、および`domain`の各パラメーターを持つ`userName`オーバーロード内の実行可能ファイルを表す必要があります。  
  
 を使用<xref:System.Diagnostics.Process.Start%2A>してプロセスを開始するときは常に、プロセスを閉じる必要があります。そうしないと、システムリソースが失われる危険性があります。 または<xref:System.Diagnostics.Process.CloseMainWindow%2A> <xref:System.Diagnostics.Process.Kill%2A>を使用してプロセスを終了します。 プロセスが既に閉じられているかどうかは<xref:System.Diagnostics.Process.HasExited%2A> 、そのプロパティを使用して確認できます。 
  
   
  
## Examples  
 次のコード例では、このオーバーロードを使用して実行可能ファイルを起動し、実行不可能<xref:System.ComponentModel.Win32Exception>なファイルに関連付けられているアプリケーションを起動しようとしたときに、をスローする方法を示します。  
  
 [!code-csharp[System.Diagnostics.Process.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">ファイル名が指定されませんでした。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられているファイルを開いているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">プロセス オブジェクトは既には破棄されています。</exception>
        <exception cref="T:System.PlatformNotSupportedException">メソッドは Linux または macOS (.NET Core のみ) ではサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="arguments" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="userName" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="password" Type="System.Security.SecureString" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="domain" Type="System.String" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">プロセスで実行するアプリケーション ファイルの名前。</param>
        <param name="arguments">プロセスを起動するときに渡すコマンド ライン引数。</param>
        <param name="userName">プロセスの開始時に使用するユーザー名。</param>
        <param name="password">プロセスを開始するときに使用するパスワードを含む <see cref="T:System.Security.SecureString" />。</param>
        <param name="domain">プロセスの開始時に使用するドメイン。</param>
        <summary>アプリケーションの名前、コマンド ライン引数のセット、ユーザー名、パスワード、およびドメインを指定してプロセス リソースを起動し、リソースを新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントに関連付けます。</summary>
        <returns>プロセス リソースに関連付けられている新しい <see cref="T:System.Diagnostics.Process" />。プロセス リソースが起動されていない場合は <see langword="null" />。 同じプロセスのインスタンスが既に実行されているときに起動された新しいプロセスは、他のインスタンスから独立します。 また、Start では、<see cref="P:System.Diagnostics.Process.HasExited" /> プロパティが既に <see langword="true" /> に設定されている null 以外の Process が返される場合があります。 その場合、起動されたプロセス自体の既存のインスタンスがアクティブ化され、その後に終了されることがあります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードを使用して、ファイル名、コマンドライン引数、ユーザー名、パスワード、およびドメインを指定することにより、新しいプロセスとそのプライマリスレッドを作成します。 新しいプロセスは、指定された実行可能ファイルを、指定した資格情報 (ユーザー、ドメイン、およびパスワード) のセキュリティコンテキストで実行します。  
  
> [!NOTE]
>  実行可能ファイルがリモートドライブにある場合は、リンクされたドライブ文字ではなく、uniform resource identifier (URI) を使用してネットワーク共有を識別する必要があります。  
  
> [!NOTE]
>  開始する実行可能ファイルのアドレスが URL の場合、プロセスは開始`null`されず、が返されます。  
  
 このオーバーロードを使用すると、最初に新しい<xref:System.Diagnostics.Process>インスタンスを作成せずにプロセスを開始できます。 オーバーロードは、新しい<xref:System.Diagnostics.Process>インスタンスを作成するための明示的な手順の代わりに、 <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> <xref:System.Diagnostics.Process.StartInfo%2A>プロパティ<xref:System.Diagnostics.ProcessStartInfo.UserName%2A>の<xref:System.Diagnostics.ProcessStartInfo.Password%2A> <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>、、 <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> 、、およびの各プロパティを設定し、を呼び出します。<xref:System.Diagnostics.Process.Start%2A>インスタンスの<xref:System.Diagnostics.Process> 。  
  
 同様に、[ファイル名を指定して**実行**] ダイアログボックスが .exe 拡張子の有無にかかわらず、実行可能ファイル名を受け入れる場合と同じよう`fileName`に、.exe 拡張子はパラメーターで省略可能です。 たとえば、 `fileName`パラメーターを "notepad.exe" または "notepad" に設定できます。 パラメーターが`fileName`実行可能ファイルを表す場合、 `arguments`パラメーターは、の`Notepad.exe myfile.txt`テキストファイルなど、操作対象のファイルを表す場合があります。  
  
> [!NOTE]
>  ファイル名は<xref:System.Diagnostics.Process.Start%2A> 、、 `password`、および`domain`の各パラメーターを持つ`userName`オーバーロード内の実行可能ファイルを表す必要があります。  
  
 を使用<xref:System.Diagnostics.Process.Start%2A>してプロセスを開始するときは常に、プロセスを閉じる必要があります。そうしないと、システムリソースが失われる危険性があります。 または<xref:System.Diagnostics.Process.CloseMainWindow%2A> <xref:System.Diagnostics.Process.Kill%2A>を使用してプロセスを終了します。 プロセスが既に閉じられているかどうかは<xref:System.Diagnostics.Process.HasExited%2A> 、そのプロパティを使用して確認できます。 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">ファイル名が指定されませんでした。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられているファイルを開いているときにエラーが発生しました。  
  
 または  
  
 引数の長さと関連ファイルへの完全パスの長さの合計が、2080 文字を超えています。 この例外に関連付けられたエラー メッセージは、次のいずれかになります。"システム コールに渡されるデータ領域が小さすぎます" または「アクセスが拒否されました。」</exception>
        <exception cref="T:System.ObjectDisposedException">プロセス オブジェクトは既には破棄されています。</exception>
        <exception cref="T:System.PlatformNotSupportedException">メソッドは Linux または macOS (.NET Core のみ) ではサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="StartInfo">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessStartInfo StartInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessStartInfo StartInfo" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property StartInfo As ProcessStartInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessStartInfo ^ StartInfo { System::Diagnostics::ProcessStartInfo ^ get(); void set(System::Diagnostics::ProcessStartInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StartInfo : System.Diagnostics.ProcessStartInfo with get, set" Usage="System.Diagnostics.Process.StartInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Specifies information used to start a process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStartInfo")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessStartInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Diagnostics.Process" /> の <see cref="M:System.Diagnostics.Process.Start" /> メソッドに渡すプロパティを取得または設定します。</summary>
        <value>プロセスを起動するときに使用するデータを表す <see cref="T:System.Diagnostics.ProcessStartInfo" />。 これらの引数には、プロセスの起動時に使用する実行可能ファイルまたは文書の名前があります。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StartInfo%2A>プロセスを開始するために使用するパラメーターのセットを表します。 が<xref:System.Diagnostics.Process.Start%2A> 呼び出さ<xref:System.Diagnostics.Process.StartInfo%2A>れると、を開始するプロセスを指定するためにが使用されます。 設定する必要<xref:System.Diagnostics.Process.StartInfo%2A> <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>があるメンバーは、プロパティだけです。 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>プロパティを指定してプロセスを開始することは、Windows の **[スタート]** メニューの **[実行]** ダイアログボックスに情報を入力することと似ています。 したがって、 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>プロパティは実行可能ファイルを表す必要はありません。 これは、システムにインストールされているアプリケーションに拡張機能が関連付けられている任意のファイルの種類にすることができます。 たとえば、メモ<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>帳などのテキストファイルがエディターに関連付けられている場合、は .txt 拡張子を持つことができます。また、Microsoft word などのワードプロセッシングツールを使用して .doc ファイルに関連付けられている場合は、.doc を持つことができます。 同様に、[ファイル名を指定して**実行**] ダイアログボックスが .exe 拡張子の有無にかかわらず、実行可能ファイル名を受け入れる場合と同じよう<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>に、.exe 拡張子は、メンバーでは省略可能です。 たとえば、 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>プロパティを "notepad.exe" または "notepad" に設定できます。  
  
 ClickOnce アプリケーションを起動するには、アプリケーション<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>を最初にインストールした場所 (Web アドレスなど) にプロパティを設定します。 ClickOnce アプリケーションは、ハードドライブにインストールされている場所を指定することによって起動しないでください。  
  
 ファイル名に、.doc ファイルなどの実行不可能なファイルが含まれている場合は、ファイルに対して実行するアクションを指定する動詞を含めることができます。 たとえば、.doc 拡張子で終わるファイル<xref:System.Diagnostics.ProcessStartInfo.Verb%2A>の場合、を "Print" に設定できます。 プロパティの値<xref:System.Diagnostics.ProcessStartInfo.Verb%2A>を手動で<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>入力した場合、プロパティに指定されたファイル名に拡張子を付ける必要はありません。 ただし、プロパティを使用し<xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>て、使用可能な動詞を特定する場合は、拡張機能を含める必要があります。  
  
 この<xref:System.Diagnostics.Process.StartInfo%2A>プロパティで指定されたパラメーターは、プロセスで<xref:System.Diagnostics.Process.Start%2A>メソッドを呼び出す時間まで変更できます。 プロセスを開始した後、 <xref:System.Diagnostics.Process.StartInfo%2A>値を変更しても、関連付けられているプロセスには影響しません。 プロパティ<xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29> <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType>と`CreateProcessWithLogonW` <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> `true`プロパティが設定されたメソッドを呼び出すと、アンマネージ関数が呼び出されます。これにより、プロパティ値がまたはの場合でも、新しいウィンドウでプロセスが開始されます。 <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A>プロパティ値が<xref:System.Diagnostics.ProcessWindowStyle.Hidden>です。  
  
 メソッドによって<xref:System.Diagnostics.Process.StartInfo%2A> <xref:System.Diagnostics.Process>返されるオブジェクトのプロパティにのみアクセスする必要があります。 <xref:System.Diagnostics.Process.Start%2A> たとえば、によって<xref:System.Diagnostics.Process.StartInfo%2A> <xref:System.Diagnostics.Process.GetProcesses%2A>返される<xref:System.Diagnostics.Process>オブジェクトのプロパティにアクセスすることはできません。 それ以外の場合、.net <xref:System.Diagnostics.Process.StartInfo%2A> Core では、 <xref:System.InvalidOperationException>プロパティによってとがスローさ<xref:System.Diagnostics.ProcessStartInfo>れ .NET Framework でダミーオブジェクトが返されます。
  
 プロセスが開始されると、ファイル名は (読み取り専用) <xref:System.Diagnostics.Process.MainModule%2A>プロパティを設定するファイルになります。 プロセスの開始後にプロセスに関連付けられている実行可能ファイルを取得する場合は、 <xref:System.Diagnostics.Process.MainModule%2A>プロパティを使用します。 関連付けられたプロセスが開始されて<xref:System.Diagnostics.Process>いないインスタンスの実行可能ファイルを設定する場合は、 <xref:System.Diagnostics.Process.StartInfo%2A>プロパティの<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>メンバーを使用します。 <xref:System.Diagnostics.Process.StartInfo%2A>プロパティのメンバーは、プロセスの<xref:System.Diagnostics.Process.Start%2A>メソッドに渡される引数であるため、関連付けられ<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>たプロセスの開始後にプロパティを変更して<xref:System.Diagnostics.Process.MainModule%2A>も、プロパティはリセットされません。 これらのプロパティは、関連付けられたプロセスを初期化するためにのみ使用されます。  
  
   
  
## Examples  
 次の例では<xref:System.Diagnostics.Process.StartInfo%2A> 、を実行するファイル、それに対して実行されるアクション、およびユーザーインターフェイスを表示する必要があるかどうかをに設定します。 その他の例については、 <xref:System.Diagnostics.ProcessStartInfo>クラスのプロパティのリファレンスページを参照してください。  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Diagnostics.Process.StartInfo" /> を指定する値は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Diagnostics.Process.Start" /> メソッドはプロセスを開始するために使用されませんでした。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime StartTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.StartTime : DateTime" Usage="System.Diagnostics.Process.StartTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The time at which the process was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStartTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスが起動された時刻を取得します。</summary>
        <value>プロセスが起動された時刻を示すオブジェクト。 プロセスが実行中でない場合は、例外がスローされます。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行されているプロセスの <see cref="P:System.Diagnostics.Process.StartTime" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.InvalidOperationException">プロセスが終了しています。  
  
 または  
  
 プロセスは開始されていません。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Windows 関数の呼び出しでエラーが発生しました。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Diagnostics.Process.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The object used to marshal the event handler calls issued as a result of a Process exit.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessSynchronizingObject")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロセス終了イベントの結果として発行されるイベント ハンドラー呼び出しをマーシャリングするために使用するオブジェクトを取得または設定します。</summary>
        <value>プロセスの <see cref="E:System.Diagnostics.Process.Exited" /> イベントの結果として発行されるイベント ハンドラー呼び出しをマーシャリングするために使用する <see cref="T:System.ComponentModel.ISynchronizeInvoke" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 が<xref:System.Diagnostics.EventLog.SynchronizingObject%2A>の`null`場合<xref:System.Diagnostics.Process.Exited> 、イベントを処理するメソッドは、システムスレッドプールからのスレッドで呼び出されます。 システムスレッドプールの詳細については<xref:System.Threading.ThreadPool>、「」を参照してください。  
  
 などの<xref:System.Windows.Forms.Button>ビジュアル Windows フォームコンポーネントによってイベントが処理されるときに、システムスレッドプールを介してコンポーネントにアクセスできない場合や、例外が発生する場合があります。<xref:System.Diagnostics.Process.Exited> これを回避する<xref:System.Diagnostics.Process.SynchronizingObject%2A>には、を Windows フォームコンポーネントに設定します。 <xref:System.Diagnostics.Process.Exited>これにより、イベントを処理するメソッドが、コンポーネントが作成されたのと同じスレッドで呼び出されます。  
  
 が Windows フォームデザイナーの内部[!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]で使用されて<xref:System.Diagnostics.Process.SynchronizingObject%2A>いる場合、はを含むコントロールに<xref:System.Diagnostics.Process>自動的に設定されます。 <xref:System.Diagnostics.Process> たとえば、を<xref:System.Diagnostics.Process> (から<xref:System.Windows.Forms.Form>継承<xref:System.Diagnostics.Process> `Form1` `Form1`する) のデザイナーに配置すると、のプロパティはのインスタンスに設定されます。<xref:System.Diagnostics.Process.SynchronizingObject%2A>  
  
 [!code-cpp[Process_SynchronizingObject#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/remarks.cpp#2)]
 [!code-csharp[Process_SynchronizingObject#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/remarks.cs#2)]
 [!code-vb[Process_SynchronizingObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/remarks.vb#2)]  
  
 通常、このプロパティは、コンポーネントがコントロールまたはフォーム内に配置されるときに設定されます。これは、コンポーネントが特定のスレッドにバインドされるためです。  
  
   
  
## Examples  
 [!code-cpp[Process_SynchronizingObject#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/process_synchronizingobject.cpp#1)]
 [!code-csharp[Process_SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/process_synchronizingobject.cs#1)]
 [!code-vb[Process_SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/process_synchronizingobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName="Threads">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessThreadCollection Threads { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessThreadCollection Threads" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Threads" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Threads As ProcessThreadCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessThreadCollection ^ Threads { System::Diagnostics::ProcessThreadCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Threads : System.Diagnostics.ProcessThreadCollection" Usage="System.Diagnostics.Process.Threads" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of threads of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessThreads")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessThreadCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスで実行されているスレッドのセットを取得します。</summary>
        <value>関連付けられたプロセスで現在実行中のオペレーティング システム スレッドを表す <see cref="T:System.Diagnostics.ProcessThread" /> 型の配列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スレッドは、プロセス内のコードを実行します。 各プロセスは、1つのスレッド (プライマリスレッド) で開始されます。 どのスレッドでも新しいスレッドを作成できます。 プロセス内のスレッドは、プロセスのアドレス空間を共有します。  
  
 現在<xref:System.Diagnostics.ProcessThread>のプロセスに関連付けられているすべてのスレッドを取得するには、を使用します。 プライマリスレッドは、配列内のインデックス0の位置にあるとは限りません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">プロセスに <see cref="P:System.Diagnostics.Process.Id" /> がないか、<see cref="T:System.Diagnostics.Process" /> インスタンスに関連付けられているプロセスがありません。  
  
または 
関連付けられたプロセスが終了しました。</exception>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。Windows 98 や Windows Me でこのプロパティにアクセスするには <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> を <see langword="false" /> に設定します。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="T:System.Diagnostics.ProcessThread" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="process.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>プロセス名の書式指定は文字列にします。親コンポーネント型があれば、この型と組み合わせます。</summary>
        <returns>ベース コンポーネントの <see cref="M:System.Object.ToString" /> の戻り値と組み合わせた <see cref="P:System.Diagnostics.Process.ProcessName" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、メモ帳のインスタンスを起動します。 次に、この例では、関連付けられているプロセスのさまざまなプロパティを取得して表示します。 この例では、プロセスが終了したことを検出し、プロセスの終了コードを表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><see cref="M:System.Diagnostics.Process.ToString" /> は、Windows 98 ではサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.TotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.TotalProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.TotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process has used.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessTotalProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このプロセスの合計プロセッサ時間を取得します。</summary>
        <value>関連付けられたプロセスが CPU を使用した合計時間を示す <see cref="T:System.TimeSpan" />。 この値は、<see cref="P:System.Diagnostics.Process.UserProcessorTime" /> と <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> の合計です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、メモ帳のインスタンスを起動します。 次に、この例では、関連付けられているプロセスのさまざまなプロパティを取得して表示します。 この例では、プロセスが終了したことを検出し、プロセスの終了コードを表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行されているプロセスの <see cref="P:System.Diagnostics.Process.TotalProcessorTime" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.UserProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan UserProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.UserProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.UserProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent outside the operating system core.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessUserProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このプロセスのユーザー プロセッサ時間を取得します。</summary>
        <value>関連付けられたプロセスが、プロセスのアプリケーション部分の内部 (オペレーティング システム コアの外部) でコードを実行した合計時間を示す <see cref="T:System.TimeSpan" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、メモ帳のインスタンスを起動します。 次に、この例では、関連付けられているプロセスのさまざまなプロパティを取得して表示します。 この例では、プロセスが終了したことを検出し、プロセスの終了コードを表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行されているプロセスの <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize">
      <MemberSignature Language="C#" Value="public int VirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int VirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize : int" Usage="System.Diagnostics.Process.VirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use VirtualMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.VirtualMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessVirtualMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.VirtualMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロセスの仮想メモリのサイズ (バイト単位) を取得します。</summary>
        <value>関連付けられたプロセスが要求した仮想メモリの容量 (バイト単位)。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long VirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 VirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long VirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに割り当てられた仮想メモリの量 (バイト単位) を取得します。</summary>
        <value>関連付けられたプロセスに割り当てられた仮想メモリの量 (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティによって返される値は、プロセスによって使用される仮想メモリの現在のサイズ (バイト単位) を表します。 オペレーティングシステムは、物理メモリに読み込まれたページか、ディスク上の仮想メモリページングファイルに格納されているページに、各プロセスの仮想アドレス空間をマップします。  
  
 このプロパティは、32ビットプロセッサまたは64ビットプロセッサを搭載したコンピューターのメモリ使用量を監視するために使用できます。 プロパティ値は、プロセスの**仮想 Bytes**パフォーマンスカウンターに相当します。  
  
   
  
## Examples  
 次のコード例では、メモ帳アプリケーションのインスタンスを起動します。 次に、この例では、関連付けられているプロセスのさまざまなプロパティを取得して表示します。 この例では、プロセスが終了したことを検出し、終了コードとピークメモリの統計情報を表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForExit">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>関連付けられたプロセスが終了するまで待機する時間を設定し、指定した時間が経過するかプロセスが終了するまで現在のスレッドの実行をブロックします。 現在のスレッドがブロックされないようにする場合は、<see cref="E:System.Diagnostics.Process.Exited" /> イベントを使用します。  
  
コード例については、<see cref="P:System.Diagnostics.Process.StandardError" /> および <see cref="P:System.Diagnostics.Process.ExitCode" /> プロパティのリファレンス ページを参照してください。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public void WaitForExit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForExit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit" />
      <MemberSignature Language="VB.NET" Value="Public Sub WaitForExit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WaitForExit();" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : unit -&gt; unit" Usage="process.WaitForExit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>関連付けられたプロセスが終了するまで無期限に待機するように <see cref="T:System.Diagnostics.Process" /> コンポーネントに指示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit>関連付けられたプロセスが終了するまで、現在のスレッドを待機させます。  これは、プロセスで他のすべてのメソッドが呼び出された後に呼び出される必要があります。 現在のスレッドがブロックされないようにする場合は、<xref:System.Diagnostics.Process.Exited> イベントを使用します。  
  
 このメソッドは、 <xref:System.Diagnostics.Process>プロセスおよびイベントハンドラーが終了するのを無期限に待機するようにコンポーネントに指示します。 これにより、アプリケーションが応答を停止する可能性があります。 たとえば、ユーザーインターフェイスを持つ<xref:System.Diagnostics.Process.CloseMainWindow%2A>プロセスに対してを呼び出した場合、関連付けられているプロセスを終了するオペレーティングシステムへの要求は、そのメッセージループに入ることがないように記述されている場合、処理されない可能性があります。  
  
> [!NOTE]
>  以前の[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]バージョンでは、オーバーロード<xref:System.Diagnostics.Process.WaitForExit>は無限に<xref:System.Int32.MaxValue>ではなく、ミリ秒 (約24日間) 待機していました。 また、以前のバージョンでは、完全な<xref:System.Int32.MaxValue>時間に達したときにイベントハンドラーが終了するのを待機していませんでした。  
  
 このオーバーロードは、リダイレクトされた標準出力の非同期イベントの処理など、すべての処理が完了したことを保証します。 標準出力が非同期イベントハンドラーにリダイレクトされ<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>ている場合は、オーバーロードの呼び出しの後にこのオーバーロードを使用する必要があります。  
  
 関連付けられたプロセスが終了すると (つまり、通常または異常終了によって操作システムによってシャットダウンされた場合)、システムはプロセスに関する管理情報を格納し<xref:System.Diagnostics.Process.WaitForExit>、を呼び出したコンポーネントに戻ります。 次に、を使用して、終了した<xref:System.Diagnostics.Process.ExitTime%2A>プロセスにを使用<xref:System.Diagnostics.Process> <xref:System.Diagnostics.Process.Handle%2A>して、コンポーネントが情報にアクセスできるようになります。  
  
 関連付けられたプロセスが終了し<xref:System.Diagnostics.Process.Handle%2A>たため、コンポーネントのプロパティは既存のプロセスリソースを参照しなくなります。 代わりに、ハンドルは、プロセスリソースに関するオペレーティングシステムの情報にアクセスするためにのみ使用できます。 システムは、コンポーネントに<xref:System.Diagnostics.Process>よって解放されていないプロセスを終了するハンドルを認識します。そのため、コンポーネントが<xref:System.Diagnostics.Process>リソースを明確に解放するまで、および<xref:System.Diagnostics.Process.Handle%2A>情報は<xref:System.Diagnostics.Process.ExitTime%2A>メモリに保持されます。 このため、 <xref:System.Diagnostics.Process.Start%2A> <xref:System.Diagnostics.Process>インスタンスを呼び出すたびに、関連付けら<xref:System.Diagnostics.Process.Close%2A>れたプロセスが終了したときにを呼び出すと、そのプロセスに関する管理情報は不要になります。 <xref:System.Diagnostics.Process.Close%2A>終了したプロセスに割り当てられたメモリを解放します。  
  
   
  
## Examples  
 <xref:System.Diagnostics.Process.StandardError%2A>プロパティリファレンスページの「解説」セクションを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">待機の設定にアクセスできませんでした。</exception>
        <exception cref="T:System.SystemException">プロセス <see cref="P:System.Diagnostics.Process.Id" /> が設定されておらず、<see cref="P:System.Diagnostics.Process.Id" /> プロパティを判別する元となる <see cref="P:System.Diagnostics.Process.Handle" /> が存在しません。  
  
- または - 
この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。  
  
- または - 
リモート コンピューターで実行されているプロセスの <see cref="M:System.Diagnostics.Process.WaitForExit" /> を呼び出そうとしています。 このメソッドはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public bool WaitForExit (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForExit(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForExit (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForExit(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : int -&gt; bool" Usage="process.WaitForExit milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">関連付けられたプロセスが終了するまで待機する時間。単位はミリ秒です。 最大値は、32 ビット整数で表現できる最大値で、オペレーティング システムに対して無限大で表現される値です。</param>
        <summary>関連付けられたプロセスが終了するまで、最大で指定したミリ秒間待機するように <see cref="T:System.Diagnostics.Process" /> コンポーネントに指示します。</summary>
        <returns>関連付けられたプロセスが終了した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>関連付けられたプロセスが終了するまで、現在のスレッドを待機させます。 これは、プロセスで他のすべてのメソッドが呼び出された後に呼び出される必要があります。 現在のスレッドがブロックされないようにする場合は、<xref:System.Diagnostics.Process.Exited> イベントを使用します。  
  
 このメソッドは、 <xref:System.Diagnostics.Process>プロセスが終了するまでの時間を待機するようにコンポーネントに指示します。 終了要求が拒否されたために、関連付けられたプロセスが間隔の終了に`false`よって終了しない場合は、呼び出し元のプロシージャにが返されます。 に<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29?displayProperty=nameWithType>を指定すると、 <xref:System.Diagnostics.Process.WaitForExit>オーバーロードと同じ動作が実行されます。 `milliseconds` メソッドに 0 (ゼロ) を渡すと、プロセスが既`true`に終了している場合にのみが返されます。 `false`それ以外の場合は、が直ちに返されます。  
  
> [!NOTE]
>  以前の[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]バージョンでは、が`milliseconds` -1 の場合、 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>オーバーロードは無期限<xref:System.Int32.MaxValue>ではなく、ミリ秒 (約24日間) 待機します。  
  
 標準出力が非同期イベントハンドラーにリダイレクトされている場合、このメソッドから制御が戻ったときに出力処理が完了していない可能性があります。 非同期イベント処理が完了したことを確認するに<xref:System.Diagnostics.Process.WaitForExit>は、このオーバーロードからを`true`受け取った後、パラメーターを受け取らないオーバーロードを呼び出します。 Windows フォームアプリケーションで<xref:System.Diagnostics.Process.Exited>イベントが正しく処理されるようにするには、 <xref:System.Diagnostics.Process.SynchronizingObject%2A>プロパティを設定します。  
  
 関連付けられたプロセスが終了すると (が正常終了または異常終了によってオペレーティングシステムによってシャットダウンされます)、システムはプロセスに関する管理<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>情報を格納し、を呼び出したコンポーネントに戻ります。 次に、を使用して、終了した<xref:System.Diagnostics.Process.ExitTime%2A>プロセスにを使用<xref:System.Diagnostics.Process> <xref:System.Diagnostics.Process.Handle%2A>して、コンポーネントが情報にアクセスできるようになります。  
  
 関連付けられたプロセスが終了し<xref:System.Diagnostics.Process.Handle%2A>たため、コンポーネントのプロパティは既存のプロセスリソースを参照しなくなります。 代わりに、ハンドルは、プロセスリソースに関するオペレーティングシステムの情報にアクセスするためにのみ使用できます。 システムは、コンポーネントに<xref:System.Diagnostics.Process>よって解放されていないプロセスを終了するハンドルを認識します。そのため、コンポーネントが<xref:System.Diagnostics.Process>リソースを明確に解放するまで、および<xref:System.Diagnostics.Process.Handle%2A>情報は<xref:System.Diagnostics.Process.ExitTime%2A>メモリに保持されます。 このため、 <xref:System.Diagnostics.Process.Start%2A> <xref:System.Diagnostics.Process>インスタンスを呼び出すたびに、関連付けら<xref:System.Diagnostics.Process.Close%2A>れたプロセスが終了したときにを呼び出すと、そのプロセスに関する管理情報は不要になります。 <xref:System.Diagnostics.Process.Close%2A>終了したプロセスに割り当てられたメモリを解放します。  
  
   
  
## Examples  
 <xref:System.Diagnostics.Process.ExitCode%2A>プロパティのコード例を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">待機の設定にアクセスできませんでした。</exception>
        <exception cref="T:System.SystemException">プロセス <see cref="P:System.Diagnostics.Process.Id" /> が設定されておらず、<see cref="P:System.Diagnostics.Process.Id" /> プロパティを判別する元となる <see cref="P:System.Diagnostics.Process.Handle" /> が存在しません。  
  
または 
この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。  
  
または 
リモート コンピューターで実行されているプロセスの <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" /> を呼び出そうとしています。 このメソッドはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="milliseconds" /> は無限のタイムアウトを表す -1 以外の負の数です。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForInputIdle">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>関連付けられたプロセスがアイドル状態になるまで、<see cref="T:System.Diagnostics.Process" /> コンポーネントを待機させます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle();" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : unit -&gt; bool" Usage="process.WaitForInputIdle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>関連付けられたプロセスがアイドル状態になるまで、<see cref="T:System.Diagnostics.Process" /> コンポーネントを無期限に待機させます。 このオーバーロードは、ユーザー インターフェイスとメッセージ ループを持つプロセスにだけ適用されます。</summary>
        <returns>関連付けられたプロセスがアイドル状態になった場合は <see langword="true" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 を<xref:System.Diagnostics.Process.WaitForInputIdle>使用すると、メッセージループがアイドル状態に戻るまで、アプリケーションの処理が強制的に待機されます。 ユーザーインターフェイスを持つプロセスが実行されている場合、オペレーティングシステムによって Windows メッセージがプロセスに送信されるたびに、そのメッセージループが実行されます。 次に、プロセスはメッセージループに戻ります。 プロセスは、メッセージループ内のメッセージを待機しているときにアイドル状態になっていると言います。 この状態は、アプリケーションがそのウィンドウと通信する前に、アプリケーションがメインウィンドウの作成を完了するまで待機する必要がある場合などに便利です。  
  
 プロセスにメッセージループがない場合、はを<xref:System.Diagnostics.Process.WaitForInputIdle> <xref:System.InvalidOperationException>スローします。  
  
 オーバーロード<xref:System.Diagnostics.Process.WaitForInputIdle>は、メッセージ<xref:System.Diagnostics.Process>ループ内のプロセスがアイドル状態になるのを無期限に待機するようにコンポーネントに指示します。 この命令により、アプリケーションが応答を停止する可能性があります。 たとえば、プロセスが記述されている場合は、コードフラグメント`while(true)`のように、常にメッセージループを直ちに終了します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">プロセスにグラフィカル インターフェイスがありません。  
  
または 
不明なエラーが発生しました。 プロセスがアイドル状態になることができませんでした。  
  
- または - 
プロセスは既に終了しています。  
  
または 
この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : int -&gt; bool" Usage="process.WaitForInputIdle milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="milliseconds">関連付けられたプロセスがアイドル状態になるまでの待機時間をミリ秒単位で指定する、1 ～ <see cref="F:System.Int32.MaxValue" /> の値。 値 0 の場合はすぐに制御が戻され、値 -1 の場合は無期限に待機することを示します。</param>
        <summary>関連付けられたプロセスがアイドル状態になるまで、最大で指定したミリ秒間、<see cref="T:System.Diagnostics.Process" /> コンポーネントを待機させます。 このオーバーロードは、ユーザー インターフェイスとメッセージ ループを持つプロセスにだけ適用されます。</summary>
        <returns>関連付けられたプロセスがアイドル状態になった場合は<see langword="true" /> 。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 を<xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29>使用すると、メッセージループがアイドル状態に戻るまで、アプリケーションの処理が強制的に待機されます。 ユーザーインターフェイスを持つプロセスが実行されている場合、オペレーティングシステムによって Windows メッセージがプロセスに送信されるたびに、そのメッセージループが実行されます。 次に、プロセスはメッセージループに戻ります。 プロセスは、メッセージループ内のメッセージを待機しているときにアイドル状態になっていると言います。 この状態は、アプリケーションがそのウィンドウと通信する前に、アプリケーションがメインウィンドウの作成を完了するまで待機する必要がある場合などに便利です。  
  
 プロセスにメッセージループがない場合、はを<xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> <xref:System.InvalidOperationException>スローします。  
  
 オーバーロード<xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29>は、メッセージ<xref:System.Diagnostics.Process>ループでプロセスがアイドル状態になるまでの時間を待機するようにコンポーネントに指示します。 ループがまだメッセージを処理しているために、関連付けられているプロセスが間隔の`false`最後までアイドル状態にならない場合は、呼び出し元のプロシージャにが返されます。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">プロセスにグラフィカル インターフェイスがありません。  
  
または 
不明なエラーが発生しました。 プロセスがアイドル状態になることができませんでした。  
  
- または - 
プロセスは既に終了しています。  
  
- または - 
この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public int WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet : int" Usage="System.Diagnostics.Process.WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use WorkingSet64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.WorkingSet64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessWorkingSet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.WorkingSet64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスの物理メモリ使用量 (バイト単位) を取得します。</summary>
        <value>関連付けられたプロセスが使用している物理メモリの合計容量 (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティによって返される値は、プロセスによって使用されるワーキングセットメモリの現在のサイズ (バイト単位) を表します。 プロセスのワーキングセットは、物理 RAM メモリ内のプロセスに現在表示されているメモリページのセットです。 これらのページは常駐し、アプリケーションがページフォールトをトリガーすることなく使用できます。  
  
 ワーキングセットには、共有データとプライベートデータの両方が含まれます。 共有データには、プロセスモジュールやシステムライブラリを含む、プロセスによって実行されるすべての命令を含むページが含まれます。  
  
   
  
## Examples  
 次の例では、メモ帳のインスタンスを起動します。 次に、この例では、関連付けられているプロセスのさまざまなプロパティを取得して表示します。 この例では、プロセスが終了したことを検出し、プロセスの終了コードを表示します。  
  
 [!code-cpp[process_sample#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_sample/CPP/process_sample.cpp#1)]
 [!code-csharp[process_sample#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_sample/CS/process_sample.cs#1)]
 [!code-vb[process_sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_sample/VB/process_sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet64">
      <MemberSignature Language="C#" Value="public long WorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 WorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long WorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet64 : int64" Usage="System.Diagnostics.Process.WorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに割り当てられた物理メモリの量 (バイト単位) を取得します。</summary>
        <value>関連付けられたプロセスに割り当てられた物理メモリの量 (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティによって返される値は、プロセスによって使用されるワーキングセットメモリの現在のサイズ (バイト単位) を表します。 プロセスのワーキングセットは、物理 RAM メモリ内のプロセスに現在表示されているメモリページのセットです。 これらのページは常駐し、アプリケーションがページフォールトをトリガーすることなく使用できます。  
  
 ワーキングセットには、共有データとプライベートデータの両方が含まれます。 共有データには、プロセスモジュールやシステムライブラリの指示を含む、プロセスが実行するすべての命令を含むページが含まれます。  
  
 このプロパティは、32ビットプロセッサまたは64ビットプロセッサを搭載したコンピューターのメモリ使用量を監視するために使用できます。 プロパティ値は、プロセスの**ワーキングセット**パフォーマンスカウンターに相当します。  
  
   
  
## Examples  
 次のコード例では、メモ帳アプリケーションのインスタンスを起動します。 次に、この例では、関連付けられているプロセスのさまざまなプロパティを取得して表示します。 この例では、プロセスが終了したことを検出し、終了コードとピークメモリの統計情報を表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
  </Members>
</Type>
