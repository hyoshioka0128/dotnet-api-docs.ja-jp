<Type Name="String" FullName="System.String">
  <Metadata><Meta Name="ms.openlocfilehash" Value="1a659e4a4b45ebfc3a5c6e7565e99b065c6d0c77" /><Meta Name="ms.sourcegitcommit" Value="5c332e8417c001736f7e2f33a84791feebba2cd7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="07/30/2019" /><Meta Name="ms.locfileid" Value="68632982" /></Metadata><TypeSignature Language="C#" Value="public sealed class String : ICloneable, IComparable, IComparable&lt;string&gt;, IConvertible, IEquatable&lt;string&gt;, System.Collections.Generic.IEnumerable&lt;char&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit string extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;char&gt;, class System.Collections.IEnumerable, class System.ICloneable, class System.IComparable, class System.IComparable`1&lt;string&gt;, class System.IConvertible, class System.IEquatable`1&lt;string&gt;" />
  <TypeSignature Language="DocId" Value="T:System.String" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class String&#xA;Implements ICloneable, IComparable, IComparable(Of String), IConvertible, IEnumerable(Of Char), IEquatable(Of String)" />
  <TypeSignature Language="C++ CLI" Value="public ref class String sealed : ICloneable, IComparable, IComparable&lt;System::String ^&gt;, IConvertible, IEquatable&lt;System::String ^&gt;, System::Collections::Generic::IEnumerable&lt;char&gt;" />
  <TypeSignature Language="F#" Value="type string = class&#xA;    interface IComparable&#xA;    interface ICloneable&#xA;    interface IConvertible&#xA;    interface IEnumerable&#xA;    interface IComparable&lt;string&gt;&#xA;    interface seq&lt;char&gt;&#xA;    interface IEquatable&lt;string&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.String&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.String&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>テキストを一連の UTF-16 コード単位として表現します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 文字列は、テキストを表すために使用される文字のシーケンシャルコレクションです。 オブジェクトは、文字列を<xref:System.Char?displayProperty=nameWithType>表すオブジェクト<xref:System.Char?displayProperty=nameWithType>のシーケンシャルコレクションです。オブジェクトは utf-16 コード単位に対応します。 <xref:System.String> <xref:System.String>オブジェクトの値はオブジェクトの<xref:System.Char?displayProperty=nameWithType>シーケンシャルコレクションの内容であり、その値は変更できません (つまり、読み取り専用です)。 文字列の不変性の詳細については、このトピックで後述する「[不変クラスと StringBuilder クラス](#Immutability)」を参照してください。 メモリ内の<xref:System.String>オブジェクトの最大サイズは 2 gb、または約10億文字です。  
  
[!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

 このセクションの内容:  
  
 [String オブジェクトのインスタンス化](#Instantiation)   
 [Char オブジェクトと Unicode 文字](#Characters)   
 [文字列と Unicode 標準](#Unicode)   
 [文字列と埋め込まれた null 文字](#EmbeddedNulls)   
 [文字列とインデックス](#Indexes)   
 [Null 文字列と空の文字列](#Nulls)   
 [不変性と StringBuilder クラス](#Immutability)   
 [序数およびカルチャに依存する操作](#CultureSensitive)   
 [非正規](#Normalization)   
 [カテゴリ別の文字列操作](#ByCategory)  
  
<a name="Instantiation"></a>   
## <a name="instantiating-a-string-object"></a>String オブジェクトのインスタンス化  
 オブジェクトを<xref:System.String>インスタンス化するには、次の方法があります。  
  
-   <xref:System.String>変数に文字列リテラルを代入する。 これは、文字列を作成するために最もよく使用されるメソッドです。 次の例では、割り当てを使用して複数の文字列を作成します。 でC#は、円記号 (\\) はエスケープ文字なので、文字列内のリテラルの円記号はエスケープする必要があり@-quotedます。また、文字列全体をにする必要があることに注意してください。  
  
     [!code-cpp[System.String.Class.Instantiate#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate1.cpp#1)]
     [!code-csharp-interactive[System.String.Class.Instantiate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#1)]
     [!code-vb[System.String.Class.Instantiate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#1)]  
  
-   クラスコンストラクターを<xref:System.String>呼び出す。 次の例では、複数のクラスコンストラクターを呼び出すことによって文字列をインスタンス化します。 一部のコンストラクターには、パラメーターとしての文字配列または符号付きバイト配列へのポインターが含まれていることに注意してください。 Visual Basic は、これらのコンストラクターの呼び出しをサポートしていません。 <xref:System.String>コンストラクターの詳細については、 <xref:System.String.%23ctor%2A> 「コンストラクターの概要」を参照してください。  
  
     [!code-cpp[System.String.Class.Instantiate#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate2.cpp#2)]
     [!code-csharp[System.String.Class.Instantiate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#2)]
     [!code-vb[System.String.Class.Instantiate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#2)]  
  
-   文字列連結演算子 (+ in C#および & または + in Visual Basic) を使用して、インスタンスと文字列リテラルの<xref:System.String>任意の組み合わせから1つの文字列を作成する。 次の例は、文字列連結演算子の使用方法を示しています。  
  
     [!code-cpp[System.String.Class.Instantiate#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#3)]
     [!code-csharp-interactive[System.String.Class.Instantiate#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#3)]
     [!code-vb[System.String.Class.Instantiate#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#3)]  
  
-   プロパティを取得するか、文字列を返すメソッドを呼び出します。 次の例では、 <xref:System.String>クラスのメソッドを使用して、より大きな文字列から部分文字列を抽出します。  
  
     [!code-cpp[System.String.Class.Instantiate#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#4)]
     [!code-csharp-interactive[System.String.Class.Instantiate#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#4)]
     [!code-vb[System.String.Class.Instantiate#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#4)]  
  
-   書式指定メソッドを呼び出して、値またはオブジェクトをその文字列形式に変換する。 次の例では、[複合書式指定](~/docs/standard/base-types/composite-formatting.md)機能を使用して、2つのオブジェクトの文字列形式を文字列に埋め込みます。  
  
     [!code-cpp[System.String.Class.Instantiate#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#5)]
     [!code-csharp[System.String.Class.Instantiate#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#5)]
     [!code-vb[System.String.Class.Instantiate#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#5)]  
  
<a name="Characters"></a>   
## <a name="char-objects-and-unicode-characters"></a>Char オブジェクトと Unicode 文字  
 文字列内の各文字は、unicode スカラー値 (Unicode コードポイントまたは unicode 文字の序数 (numeric) 値) によって定義されます。 各コードポイントは utf-16 エンコーディングを使用してエンコードされ、エンコーディングの各要素の数値は<xref:System.Char>オブジェクトによって表されます。  
  
> [!NOTE]
>  インスタンスは<xref:System.String> utf-16 コード単位のシーケンシャルコレクションで構成されているため、正しい形式の Unicode 文字列ではない<xref:System.String>オブジェクトを作成することができます。 たとえば、対応する上位サロゲートを持たない下位サロゲートを持つ文字列を作成できます。 <xref:System.Text>名前空間のオブジェクトをエンコードおよびデコードするメソッドなどの一部のメソッドでは、文字列が適切な形式であることを確認する<xref:System.String>ためのチェックが実行されますが、クラスメンバーは文字列が整形式であることを保証しません。  
  
 通常、 <xref:System.Char> 1 つのオブジェクトは1つのコードポイントを表します。つまり、 <xref:System.Char>の数値はコードポイントに相当します。 たとえば、文字 "a" のコードポイントは U + 0061 です。 ただし、コードポイントでは、複数のエンコードされた要素 ( <xref:System.Char>複数のオブジェクト) が必要になる場合があります。 Unicode 規格では、複数<xref:System.Char>のオブジェクトに対応する2種類の文字 (graphemes) と、unicode 補助プレーンの文字に対応する unicode 補助コードポイントが定義されています。  
  
-   書記素は、基本文字とそれに続く1つ以上の組み合わせ文字で表されます。 たとえば、äという文字は、コードポイント<xref:System.Char>が u + 0061 で、その後<xref:System.Char>にコードポイントが u + 0308 のオブジェクトが続くオブジェクトによって表されます。 この文字は、コードポイントが U + <xref:System.Char> 00E4 の1つのオブジェクトによって定義することもできます。 次の例に示すように、カルチャに依存した等値比較では、これら2つの表現が等しいことを示していますが、通常の序数の比較は同じではありません。 ただし、2つの文字列が正規化されている場合は、序数に基づく比較でも等しいことが示されます。 (文字列の正規化の詳細については、「[正規化](#Normalization)」セクションを参照してください)。  
  
     [!code-cpp[System.String.Class#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char1.cpp#2)]
     [!code-csharp[System.String.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/grapheme1.cs#2)]
     [!code-vb[System.String.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/grapheme1.vb#2)]  
  
-   Unicode 補助コードポイント (サロゲートペア) は、コードポイントが上位<xref:System.Char>サロゲートであるオブジェクトと、その<xref:System.Char>コードポイントが下位サロゲートであるオブジェクトによって表されます。 高いサロゲートのコード単位は、U + D800 から U + DBFF までの範囲です。 下限サロゲートのコード単位は、U + DC00 から U + DFFF までの範囲です。 サロゲートペアは、16の Unicode 補助プレーンの文字を表すために使用されます。 次の例では、サロゲート文字を作成し、 <xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=nameWithType>それをメソッドに渡して、サロゲートペアであるかどうかを判断します。  
  
     [!code-cpp[System.String.Class#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char2.cpp#3)]
     [!code-csharp-interactive[System.String.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/surrogate1.cs#3)]
     [!code-vb[System.String.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/surrogate1.vb#3)]  
  
<a name="Unicode"></a>   
## <a name="strings-and-the-unicode-standard"></a>文字列と Unicode 標準  
 文字列内の文字は、値に<xref:System.Char>対応する utf-16 でエンコードされたコード単位で表されます。  
  
 文字列内の各文字には、関連付けられた Unicode 文字カテゴリがあります<xref:System.Globalization.UnicodeCategory> 。これは、列挙体によって .net で表されます。 文字またはサロゲートペアのカテゴリは、メソッドを<xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType>呼び出すことによって決定できます。  

[!INCLUDE[character-categories](~/includes/unicode-categories.md)]
  
 また、.NET では、Unicode 標準に基づく文字列比較と並べ替えがサポートされています。 を通じて[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)].NET Framework のバージョンでは、.NET Framework は文字列データの独自のテーブルを保持します。 これは、Windows 7 で実行され[!INCLUDE[net_v45](~/includes/net-v45-md.md)]ている以降の .NET Framework のバージョンにも当てはまります。 Windows 8 以降[!INCLUDE[net_v45](~/includes/net-v45-md.md)]のバージョンの Windows オペレーティングシステムで実行されているでは、ランタイムは文字列の比較と並べ替えの操作をオペレーティングシステムに委任します。 .NET Core では、 [Unicode ライブラリの国際化コンポーネント](http://site.icu-project.org/)によって、文字列の比較と並べ替えの情報が提供されます。次の表に、.NET のバージョンと、文字の比較と並べ替えの基準となる Unicode 標準のバージョンを示します。  
  
|.NET のバージョン|Unicode 標準のバージョン|  
|----------------------------|-------------------------------------|  
|[!INCLUDE[net_v11_long](~/includes/net-v11-long-md.md)]|[Unicode 標準、バージョン 4.0.0](https://www.unicode.org/versions/Unicode4.0.0/)|  
|.NET Framework 2.0|[Unicode 標準、バージョン 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]|[Unicode 標準、バージョン 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]|[Unicode 標準、バージョン 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)]以降 (Windows 7)|[Unicode 標準、バージョン 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)]Windows 8 以降の windows オペレーティングシステム|[Unicode 標準、バージョン 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/)|  
|.NET Core (すべてのバージョン)|基になるオペレーティング システムでサポートされている Unicode 標準のバージョンによって異なります。|

<a name="EmbeddedNulls"></a>   
## <a name="strings-and-embedded-null-characters"></a>文字列と埋め込まれた null 文字  
 .Net では、 <xref:System.String>オブジェクトに埋め込み null 文字を含めることができます。これは、文字列の長さの一部としてカウントされます。 ただし、C やC++などの一部の言語では、null 文字は文字列の末尾を示します。文字列の一部とは見なされず、文字列の長さの一部としてカウントされません。 これは、c、プログラマー、またはC++ C++ c で記述されたプログラマやライブラリが、オブジェクトに<xref:System.String>適用するときには必ずしも有効でないという一般的な仮定を意味します。  
  
-   `strlen`また<xref:System.String.Length%2A?displayProperty=nameWithType>は`wcslen`関数によって返される値は、必ずしもと同じではありません。  
  
-   関数`strcpy_s`または`wcscpy_s`関数によって作成された文字列は、 <xref:System.String.Copy%2A?displayProperty=nameWithType>メソッドによって作成された文字列と必ずしも同じであるとは限りません。  
  
 オブジェクトをインスタンス<xref:System.String>化するネイティブ C C++とコード、およびプラットフォーム呼び出しを通じてオブジェクト<xref:System.String>を渡すコードは、埋め込まれた null 文字が文字列の末尾を示すと想定してはいけません。  
  
 文字列の並べ替え (または比較) と文字列の検索時には、文字列の埋め込み null 文字も異なる方法で処理されます。 2つの文字列の間でカルチャに依存した比較を実行する場合、Null 文字は無視されます (インバリアントカルチャを使用した比較を含む)。 序数または大文字と小文字を区別しない序数比較の場合にのみ考慮されます。 一方、 <xref:System.String.Contains%2A>、 <xref:System.String.StartsWith%2A>、 <xref:System.String.IndexOf%2A>などのメソッドを使用して文字列を検索する場合は、埋め込み null 文字が常に考慮されます。  
  
<a name="Indexes"></a>   
## <a name="strings-and-indexes"></a>文字列とインデックス  
 インデックスは、 <xref:System.Char> <xref:System.String>内のオブジェクト (Unicode 文字ではない) の位置です。 インデックスは、0から始まる、負でない数値で、文字列内の最初の位置から始まります。インデックス位置は0です。 <xref:System.String.IndexOf%2A> や<xref:System.String.LastIndexOf%2A>などの多数の検索メソッドでは、文字列インスタンス内の文字または部分文字列のインデックスが返されます。  
  
 プロパティ<xref:System.String.Chars%2A>を使用すると、 <xref:System.Char>文字列内のインデックス位置によって個々のオブジェクトにアクセスできます。 プロパティが既定のプロパティ (Visual Basic) またはインデクサー (でC#は) であるため、次のような<xref:System.Char>コードを使用して、文字列内の個々のオブジェクトにアクセスできます。 <xref:System.String.Chars%2A> このコードでは、文字列内の空白文字または句読点を検索して、文字列に含まれる単語の数を確認します。  
  
 [!code-cpp[System.String.Class#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index1.cpp#4)]
 [!code-csharp-interactive[System.String.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index1.cs#4)]
 [!code-vb[System.String.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index1.vb#4)]  
  
 クラスは<xref:System.String> <xref:System.Collections.IEnumerable>インターフェイスを実装するため、次の例に示す<xref:System.Char>ように、 `foreach`コンストラクトを使用して文字列内のオブジェクトを反復処理することもできます。  
  
 [!code-cpp[System.String.Class#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index2.cpp#5)]
 [!code-csharp-interactive[System.String.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index2.cs#5)]
 [!code-vb[System.String.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index2.vb#5)]  
  
 Unicode 文字は複数の<xref:System.Char>オブジェクトとしてエンコードされる可能性があるため、連続したインデックス値が連続する unicode 文字に対応しないことがあります。 特に、文字列には、基本文字で構成され、1つ以上の組み合わせ文字またはサロゲートペアによって形成される複数文字のテキスト単位を含めることができます。 <xref:System.Char>オブジェクトではなく Unicode 文字を操作するには<xref:System.Globalization.StringInfo?displayProperty=nameWithType> 、 <xref:System.Globalization.TextElementEnumerator>クラスおよびクラスを使用します。 次の例では、Unicode 文字で動作する<xref:System.Char>オブジェクトとコードの違いについて説明します。 文の各単語の文字数またはテキスト要素を比較します。 文字列には、基本文字の2つのシーケンスの後に結合文字が含まれます。  
  
 [!code-cpp[System.String.Class#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index3.cpp#6)]
 [!code-csharp-interactive[System.String.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index3.cs#6)]
 [!code-vb[System.String.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index3.vb#6)]  
  
 この例では、 <xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=nameWithType>メソッド<xref:System.Globalization.TextElementEnumerator>とクラスを使用して、文字列内のすべてのテキスト要素を列挙することで、テキスト要素を操作します。 また、メソッドを<xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=nameWithType>呼び出すことによって、各テキスト要素の開始インデックスを含む配列を取得することもできます。  
  
 個々<xref:System.Char>の値ではなく、テキストの単位を操作する方法の詳細<xref:System.Globalization.StringInfo>については、クラスを参照してください。  
  
<a name="Nulls"></a>   
## <a name="null-strings-and-empty-strings"></a>Null 文字列と空の文字列  
 宣言されているが値が割り当てられていない`null`文字列はです。 その文字列に対してメソッドを呼び出そうと<xref:System.NullReferenceException>すると、がスローされます。 Null 文字列は、値が "" または<xref:System.String.Empty?displayProperty=nameWithType>である文字列である空の文字列とは異なります。 場合によっては、メソッドの呼び出しで引数として null 文字列または空の文字列を渡すと、例外がスローされます。 たとえば、null 文字列を<xref:System.Int32.Parse%2A?displayProperty=nameWithType>メソッドに渡すと、が<xref:System.ArgumentNullException>スローされ、空の文字列を渡す<xref:System.FormatException>とがスローされます。 それ以外の場合、メソッドの引数には、null 文字列または空の文字列を指定できます。 たとえば、クラスの<xref:System.IFormattable>実装を提供する場合、null 文字列と空の文字列の両方を通常の ("G") 書式指定子と等価にする必要があります。  
  
 クラス<xref:System.String>には、次の2つの便利なメソッドが含まれてい`null`ます。このメソッドを使用すると、文字列がまたは空かどうかをテストできます。  
  
-   <xref:System.String.IsNullOrEmpty%2A><xref:System.String.Empty?displayProperty=nameWithType>。文字列が`null`と等しいかどうかを示します。 このメソッドにより、次のようなコードを使用する必要がなくなります。  
  
     [!code-cpp[System.String.Class.Null#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#1)]
     [!code-csharp[System.String.Class.Null#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#1)]
     [!code-vb[System.String.Class.Null#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#1)]  
  
-   <xref:System.String.IsNullOrWhiteSpace%2A>は、文字列が、equals `null` <xref:System.String.Empty?displayProperty=nameWithType>、または空白文字だけで構成されているかどうかを示します。 このメソッドにより、次のようなコードを使用する必要がなくなります。  
  
     [!code-cpp[System.String.Class.Null#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#2)]
     [!code-csharp[System.String.Class.Null#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#2)]
     [!code-vb[System.String.Class.Null#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#2)]  
  
 次の例では<xref:System.String.IsNullOrEmpty%2A> 、カスタム`Temperature`クラス<xref:System.IFormattable.ToString%2A?displayProperty=nameWithType>の実装でメソッドを使用します。 メソッドは、"G"、"C"、"F"、"K" の各書式指定文字列をサポートしています。 空の書式指定文字列または値がで`null`ある書式指定文字列がメソッドに渡されると、その値は "G" 書式指定文字列に変更されます。  
  
 [!code-cpp[System.String.Class.Null#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#3)]
 [!code-csharp[System.String.Class.Null#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#3)]
 [!code-vb[System.String.Class.Null#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#3)]  
  
<a name="Immutability"></a>   
## <a name="immutability-and-the-stringbuilder-class"></a>不変性と StringBuilder クラス  
 オブジェクト<xref:System.String>の値は、作成後に変更できないため、不変 (読み取り専用) と呼ばれます。 オブジェクトを<xref:System.String>変更するように見えるメソッドは、実際<xref:System.String>には変更を含む新しいオブジェクトを返します。  
  
 文字列は不変であるため、1つの文字列として表示されるものに対して繰り返しの追加や削除を実行する文字列操作ルーチンでは、パフォーマンスが大幅に低下する可能性があります。 たとえば、次のコードでは、乱数ジェネレーターを使用して、0x0001 ~ 0x052F の範囲で1000文字の文字列を作成します。 コードは、という名前`str`の既存の文字列に新しい文字を追加するために文字列の連結を使用するように見えますが、実際には、連結操作ごとに新しい<xref:System.String>オブジェクトを作成します。  
  
 [!code-cpp[System.String.Class#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder1.cpp#15)]
 [!code-csharp[System.String.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable.cs#15)]
 [!code-vb[System.String.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable.vb#15)]  
  
 文字列の値に<xref:System.Text.StringBuilder>対して複数の<xref:System.String>変更を行う操作には、クラスの代わりにクラスを使用できます。 <xref:System.String>クラスのインスタンスとは異なり<xref:System.Text.StringBuilder> 、オブジェクトは変更可能です。文字列の部分文字列を連結、追加、または削除すると、1つの文字列に対して操作が実行されます。 <xref:System.Text.StringBuilder>オブジェクトの値の変更が完了したら、 <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType>メソッドを呼び出して文字列に変換できます。 次の例では<xref:System.String> 、前の例で使用したを置き換えて、0x0001 から0x052f までの範囲に<xref:System.Text.StringBuilder>ある1000のランダム文字をオブジェクトで連結します。  
  
 [!code-cpp[System.String.Class#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder2.cpp#16)]
 [!code-csharp[System.String.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable1.cs#16)]
 [!code-vb[System.String.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable1.vb#16)]  
  
<a name="CultureSensitive"></a>   
## <a name="ordinal-vs-culture-sensitive-operations"></a>序数およびカルチャに依存する操作  
 <xref:System.String>クラスのメンバーは、オブジェクトに対して序数またはカルチャに依存した<xref:System.String> (言語) 操作を実行します。 序数操作は、各<xref:System.Char>オブジェクトの数値に対して動作します。 カルチャに依存する操作は、 <xref:System.String>オブジェクトの値に対して作用し、カルチャ固有の大文字と小文字の区別、並べ替え、書式設定、および解析の規則を考慮に入れます。 カルチャに依存する操作は、明示的に宣言されたカルチャまたは暗黙的な現在のカルチャのコンテキストで実行されます。 2種類の操作では、同じ文字列に対して実行すると、まったく異なる結果が生成される可能性があります。  
  
また、.net では、カルチャに依存しない言語文字列操作も<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>サポートしています。インバリアントカルチャ () は、地域に依存しない英語のカルチャ設定に厳密に基づいています。 他の<xref:System.Globalization.CultureInfo?displayProperty=nameWithType>設定とは異なり、インバリアントカルチャの設定は、1台のコンピューター、システムからシステム、および .net のバージョン間で一貫性が保たれていることが保証されます。 インバリアントカルチャは、すべてのカルチャでの文字列比較と順序付けの安定性を確保するブラックボックスの一種として認識されます。  
  
> [!IMPORTANT]
>  アプリケーションで、ファイル名や名前付きパイプなどのシンボル識別子、または XML ファイル内のテキストベースのデータなどの永続化されたデータに関するセキュリティ上の決定を行う場合、この操作では、カルチャに依存した比較ではなく序数の比較を使用する必要があります。 これは、カルチャに依存した比較では、有効なカルチャによって異なる結果が生成される可能性があるのに対し、序数の比較は比較対象の文字のバイナリ値のみに依存するためです。  
  
> [!IMPORTANT]
>  文字列操作を実行するほとんどのメソッドには、型<xref:System.StringComparison>のパラメーターを持つオーバーロードが含まれています。これにより、メソッドが序数またはカルチャに依存した操作を実行するかどうかを指定できます。 一般に、メソッド呼び出しの意図を明確にするには、このオーバーロードを呼び出す必要があります。 文字列に対して序数およびカルチャに依存した操作を使用するためのベストプラクティスとガイダンスについては、「[文字列を使用するためのベストプラクティス](~/docs/standard/base-types/best-practices-strings.md)」を参照してください。  
  
 [大文字と小文字](#casing)の区別、[解析と書式設定](#parsing)、[比較と並べ替え](#comparison)、および[等しいかどう](#equality)かのテストは、序数またはカルチャに依存する操作になります。 以下のセクションでは、操作の各カテゴリについて説明します。  
  
> [!TIP]
>  常にメソッドのオーバーロードを呼び出して、メソッド呼び出しの意図を明確にする必要があります。 <xref:System.String.Compare%28System.String%2CSystem.String%29>たとえば、メソッドを呼び出して、現在のカルチャの規則を使用して2つの文字列のカルチャに依存した比較を実行する代わりに、の値を<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>に指定`comparisonType`して<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>メソッドを呼び出す必要があります。引数. 詳細については、「[文字列を使用するためのベスト プラクティス](~/docs/standard/base-types/best-practices-strings.md)」を参照してください。  

Windows オペレーティング システムの並べ替え操作と比較操作で使用される文字の重みに関する情報を含む一連のテキスト ファイルである[並べ替え重みテーブル](https://www.microsoft.com/download/details.aspx?id=10921) と、Linux と macOS 用の並べ替え重みテーブルである [デフォルト Unicode 照合基本テーブル](https://www.unicode.org/Public/UCA/latest/allkeys.txt)をダウンロードできます。

<a name="casing"></a>   
### <a name="casing"></a>大文字  
 大文字と小文字の規則は、Unicode 文字の大文字と小文字を変更する方法を決定します。たとえば、小文字から大文字に変換します。 多くの場合、文字列比較の前に大文字と小文字の演算が実行されます。 たとえば、文字列を大文字に変換して、別の大文字の文字列と比較できるようにすることができます。 <xref:System.String.ToLower%2A>または<xref:System.String.ToLowerInvariant%2A>メソッドを呼び出して文字列内の文字を小文字に変換することができます。 <xref:System.String.ToUpper%2A>また、メソッドまたは<xref:System.String.ToUpperInvariant%2A>メソッドを呼び出して、文字列内の文字を大文字に変換することもできます。 また、メソッドを使用して<xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=nameWithType> 、文字列を大文字に変換することもできます。  

[!INCLUDE[platform-note](~/includes/c-and-posix-cultures.md)]  
  
 文字種の操作は、現在のカルチャ、指定されたカルチャ、またはインバリアントカルチャの規則に基づいて行うことができます。 大文字小文字の割り当ては使用されるカルチャによって異なる場合があるため、大文字と小文字の区別の結果はカルチャによって異なる場合があります。 大文字と小文字の違いには、次の3種類があります。  
  
-   ラテン文字の大文字 I (U + 0049)、ラテン小文字 I (U + 0069)、ラテン大文字文字 I (U + 0130)、およびラテン小文字 I (U + 0131) の大文字と小文字の対応付けには違いがあります。 Tr-TR (トルコ語) と az-Latn-AZ (アゼルバイジャン, Latin) カルチャで、tr、az、az-Latn ニュートラルカルチャでは、ラテン大文字の小文字 i はラテン文字の小文字 i で、ラテン小文字 i はという文字になります。上にドットが付いたラテン大文字 I。 インバリアントカルチャを含め、その他のすべてのカルチャでは、ラテン小文字 I とラテン大文字の I は小文字で、大文字に相当します。  
  
     次の例では、カルチャに依存した大文字と小文字の比較に依存している場合に、ファイルシステムへのアクセスを防止するように設計された文字列比較を実行する方法を示します。 (インバリアントカルチャの大文字と小文字の表記規則が使用されている必要があります)。  
  
     [!code-csharp[System.String.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case2.cs#17)]
     [!code-vb[System.String.Class#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case2.vb#17)]  
  
-   インバリアントカルチャと他のすべてのカルチャとの大文字と小文字のマッピングの違い。 このような場合、インバリアントカルチャの大文字と小文字の規則を使用して文字を大文字または小文字に変更すると、同じ文字が返されます。 他のすべてのカルチャでは、別の文字が返されます。 影響を受ける文字の一部を次の表に示します。  
  
    |文字|がに変更された場合|戻り値|  
    |---------------|-------------------|-------------|  
    |ミクロン記号 (U + 00B5)|大文字|ギリシャ文字ミューミュー (U +-39C)|  
    |上にドットが付いたラテン大文字 I (U + 0130)|小文字|ラテン小文字 I (U + 0069)|  
    |ラテン文字の小文字 I (U + 0131)|大文字|ラテン大文字 I (U + 0049)|  
    |ラテン小文字 (U + 017F)|大文字|ラテン大文字 S (U + 「0053」)|  
    |英小文字 Z がキャロン (U + 01C5) のラテン文字の大文字 D|小文字|ラテン小文字 DZ とキャロン (U + 01C6)|  
    |ギリシャ YPOGEGRAMMENI (U + 0345) の組み合わせ|大文字|ギリシャ文字イオータ (U + 0399)|  
  
-   2文字の大文字と小文字の組み合わせが ASCII 文字の範囲内にある場合の大文字と小文字のマッピングの違い。 ほとんどのカルチャでは、2文字の大文字と小文字の組み合わせは、等価の2文字の大文字または小文字のペアと等しくなります。 これは、次のカルチャにおける次の2文字のペアに対しては当てはまりません。これは、各ケースが digraph と比較されるためです。  
  
    -   hr-HR (クロアチア語) カルチャの "lJ" と "nJ"。  
  
    -   CS-CZ (チェコ語 (チェコ共和国)) および sk-SK (スロバキア語) カルチャの "cH"。  
  
    -   da-DK (デンマーク語 (デンマーク)) カルチャの "aA"。  
  
    -   "cS"、"dZ"、"dZS"、"nY"、"sZ"、"tY"、および hu-HU (ハンガリー語 (ハンガリー)) カルチャの "zS"。  
  
    -   es-ES_tradnl (スペイン語 (スペイン)、従来の並べ替え) カルチャの "cH" と "lL"。  
  
    -   vi-VN (ベトナム語) カルチャの "cH"、"gI"、"kH"、"nG" "nH"、"pH"、"qU"、"tH"、および "tR"。  
  
     ただし、これらのペアのカルチャに依存した比較によって問題が発生する状況が発生することは珍しくありません。これらのペアは、固定文字列または識別子では一般的ではありません。  
  
 次の例では、文字列を大文字に変換する場合のカルチャ間の大文字と小文字の違いについて説明します。  
  
 [!code-cpp[System.String.Class#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.casing.cpp#7)]
 [!code-csharp[System.String.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case1.cs#7)]
 [!code-vb[System.String.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case1.vb#7)]  
  
<a name="parsing"></a>   
### <a name="parsing-and-formatting"></a>解析と書式設定  
 書式設定と解析は逆の操作です。 書式設定規則は、日付と時刻、数値などの値を文字列形式に変換する方法を決定します。一方、解析規則は、文字列形式を日付や時刻などの値に変換する方法を決定します。 書式設定規則と解析規則は、どちらもカルチャ規則に依存します。 次の例は、カルチャ固有の日付文字列を解釈するときに発生する可能性のあるあいまいさを示しています。 日付文字列の生成に使用されたカルチャの規則を理解していなければ、03/01/2011、3/1/2011、および01/03/2011 が、2011または3月1日の2011を表しているかどうかを知ることはできません。  
  
 [!code-cpp[System.String.Class#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.format1.cpp#8)]
 [!code-csharp[System.String.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/format1.cs#8)]
 [!code-vb[System.String.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/format1.vb#8)]  
  
 同様に、次の例に示すように、1つの文字列では、解析操作で規則が使用されているカルチャに応じて異なる日付を生成できます。  
  
 [!code-cpp[System.String.Class#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.parse1.cpp#9)]
 [!code-csharp[System.String.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/parse1.cs#9)]
 [!code-vb[System.String.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/parse1.vb#9)]  
  
<a name="comparison"></a>   
### <a name="string-comparison-and-sorting"></a>文字列の比較と並べ替え  
 文字列の比較と並べ替えの規則は、カルチャによって異なります。 たとえば、並べ替え順序は、ふりがなまたは文字の視覚的表現に基づいている場合があります。 東アジア圏の言語では、文字が表意文字の画数と部首によって並べ替えられます。 また、並べ替えは、言語やカルチャで使用されているアルファベットの順序によっても異なります。 たとえば、デンマーク語の文字 "Æ" は、アルファベットでは "Z" の後に位置します。 また、比較では大文字と小文字を区別するか、大文字と小文字を区別しないことがあります。また、場合によっては、大文字と小文字を区別する規則も 一方、序数に基づく比較では、文字列の比較と並べ替えを行うときに、文字列内の個々の文字の Unicode コードポイントを使用します。  
  
 並べ替え規則は、Unicode 文字のアルファベット順と、2つの文字列の比較方法を決定します。 たとえば、メソッドは<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> 、 <xref:System.StringComparison>パラメーターに基づいて2つの文字列を比較します。 パラメーター値が<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>の場合、メソッドは、現在のカルチャの規則を使用する言語的な比較を実行します。 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>パラメーター値がの場合、メソッドは序数に基づく比較を実行します。 したがって、次の例に示すように、現在のカルチャが米国の場合、英語の場合、(カルチャに<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType>依存した比較を使用した) メソッドの最初の呼び出しでは、"a" より小さい "a" が考慮されますが、(序数による比較を使用した) 同じメソッドへの2回目の呼び出しでは、"a" より大きい "a" と見なされます。  
  
 [!code-cpp[System.String.Class#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare1.cpp#10)]
 [!code-csharp[System.String.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare1.cs#10)]
 [!code-vb[System.String.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare1.vb#10)]  
  
 .NET では、単語、文字列、および序数の並べ替え規則がサポートされています。  
  
-   単語での並べ替えでは、英数字以外の特定の Unicode 文字には特別な重みが割り当てられる、カルチャに依存した文字列の比較が行われます。 たとえば、ハイフン (-) には非常に小さな重みが割り当てられています。そのため、並べ替えられたリスト内で "co-op" と "co-op" が横に並んで表示されることがあります。 Word の並べ替え規則を<xref:System.String>使用して2つの文字列を比較するメソッドの一覧については、「[カテゴリ別の文字列操作](#ByCategory)」セクションを参照してください。  
  
-   文字列の並べ替えでは、カルチャに依存した比較も実行されます。 これは単語の並べ替えに似ていますが、特殊なケースは存在せず、英数字以外のすべての記号はすべての英数字の Unicode 文字の前に記述されます。 2つの<xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType> `options` 文字列は、値が指定されたパラメーターを持つメソッドオーバーロードを呼び出すことによって、文字列並べ替え規則を使用して<xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>比較できます。 これは、文字列の並べ替え規則を使用して2つの文字列を比較するために .NET で提供される唯一の方法です。  
  
-   序数の並べ替えでは、文字列内の各 <xref:System.Char> オブジェクトの数値に基づいて文字列を比較します。 文字の小文字と大文字のバージョンには異なるコードポイントがあるため、序数による比較では大文字と小文字が自動的に区別されます。 ただし、case が重要でない場合は、大文字と小文字を区別しない序数の比較を指定できます。 これは、インバリアントカルチャを使用して文字列を大文字に変換し、その結果に対して序数に基づく比較を実行することと同じです。 序数の並べ替え規則を<xref:System.String>使用して2つの文字列を比較するメソッドの一覧については、「[カテゴリ別の文字列操作](#ByCategory)」セクションを参照してください。  
  
 カルチャに依存した比較とは、 <xref:System.Globalization.CultureInfo> <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>プロパティによって指定されたインバリアントカルチャを含む、明示的または暗黙的にオブジェクトを使用する比較です。 暗黙のカルチャは、現在のカルチャであり、プロパティ<xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType>と<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>プロパティで指定されます。 アルファベット文字の並べ替え順序にはかなりのバリエーションがあります (つまり、 <xref:System.Char.IsLetter%2A?displayProperty=nameWithType>プロパティが返す`true`文字は、カルチャによって異なります)。 <xref:System.Globalization.CultureInfo> など<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>の文字列比較メソッドにオブジェクトを渡すことによって、特定のカルチャの規則を使用するカルチャに依存した比較を指定できます。 現在のカルチャの規則を使用するカルチャに依存した比較を指定するに<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>は<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType> <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> 、、、 <xref:System.Globalization.CompareOptions>または以外の列挙体の任意のメンバーを適切なに指定します。<xref:System.String.Compare%2A>メソッドのオーバーロード。 通常、カルチャに依存した比較は並べ替えに適していますが、序数による比較は適切ではありません。 序数に基づく比較は、通常、2つの文字列が等しいかどうかを判断する (つまり、id を決定する) 場合に適していますが、カルチャに依存した比較は区別されません。  
  
 次の例は、カルチャに依存した比較と序数による比較の違いを示しています。 この例では、3つの文字列 "Apple"、"Æble"、および "AEble" を評価します。これは、序数に基づく比較と、(各<xref:System.String.Compare%2A>メソッドが呼び出された時点での既定のカルチャである) da および en-us カルチャの規則を使用します。 デンマーク語では文字 "Æ" が個々の文字として扱われ、アルファベットの "Z" の後に並べ替えられるため、"Æble" という文字列は "Apple" よりも大きくなります。 ただし、"Æble" は "AEble" と同等とは見なされないため、"Æble" は "AEble" よりも大きくなります。 En-us カルチャでは、文字 "Æ" は含まれませんが、"AE" と等価として扱われます。 "Æble" が "Apple" より小さく、"AEble" と等しい理由を説明します。 一方、序数に基づく比較では、"Apple" は "Æble" より小さく、"Æble" は "AEble" よりも大きいと見なされます。  
  
 [!code-csharp[System.String.Class#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare4.cs#21)]
 [!code-vb[System.String.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare4.vb#21)]  
  
 次の一般的なガイドラインを使用して、適切な並べ替えまたは文字列の比較方法を選択します。  
  
-   ユーザーのカルチャに基づいて文字列を並べ替えたい場合は、現在のカルチャの規則に基づいて文字列を並べ替える必要があります。 ユーザーのカルチャが変更された場合は、並べ替えられた文字列の順序も変わります。 たとえば、類義語辞典アプリケーションでは、ユーザーのカルチャに基づいて常に単語を並べ替える必要があります。  
  
-   特定のカルチャの規則に基づいて文字列を並べ替える場合は、そのカルチャを表す<xref:System.Globalization.CultureInfo>オブジェクトを比較メソッドに渡すことによって、文字列の順序を指定する必要があります。 たとえば、特定の言語を学生に教えるように設計されたアプリケーションでは、その言語を話すカルチャのいずれかの規則に基づいて文字列を並べ替える必要があります。  
  
-   カルチャ間で文字列の順序が変更されないようにするには、インバリアントカルチャの規則に基づいて文字列を並べ替えるか、序数に基づく比較を使用する必要があります。 たとえば、序数の並べ替えを使用して、ファイル、プロセス、ミューテックス、または名前付きパイプの名前を整理します。  
  
-   セキュリティに関する決定 (ユーザー名が有効かどうかなど) に関する比較については、 <xref:System.String.Equals%2A>メソッドのオーバーロードを呼び出すことによって、常に序数テストを実行する必要があります。  
  
> [!NOTE]
>  文字列比較で使用されるカルチャに依存した並べ替えと大文字と小文字の区別の規則は、.NET のバージョンによって異なります。 [!INCLUDE[win8](~/includes/win8-md.md)]オペレーティングシステムで実行されている .NET Framework 4.5 以降のバージョンでは、並べ替え、大文字と小文字の区別、正規化、および unicode 文字の情報が unicode 6.0 標準に準拠しています。 その他の Windows オペレーティングシステムでは、Unicode 5.0 標準に準拠しています。 .NET Core では、基になるオペレーティングシステムでサポートされている Unicode 標準のバージョンによって異なります。 
  
 単語、文字列、および序数の並べ替え規則の詳細については<xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 、「」を参照してください。 各ルールを使用する場合のその他の推奨事項については、「[文字列を使用するためのベストプラクティス](~/docs/standard/base-types/best-practices-strings.md)」を参照してください。  
  
 通常、文字列の並べ替え順序を決定するため<xref:System.String.Compare%2A>になどの文字列比較メソッドを直接呼び出すことはありません。 代わりに、または<xref:System.Array.Sort%2A?displayProperty=nameWithType> <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType>などの並べ替えメソッドによって、比較メソッドが呼び出されます。 次の例では、文字列比較メソッドを明示的に呼び出すことなく、4つの異なる並べ替え操作 (現在のカルチャを使用した単語の並べ替え、インバリアントカルチャを使用した単語の並べ替え、インバリアントカルチャを使用した単語の並べ替え、インバリアントカルチャを使用した文字列の並べ替え) を実行します。ただし、使用する比較の種類を指定します。 各種類の並べ替えでは、配列内の文字列の一意の順序が生成されることに注意してください。  
  
 [!code-cpp[System.String.Class#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare2.cpp#12)]
 [!code-csharp[System.String.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare2.cs#12)]
 [!code-vb[System.String.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare2.vb#12)]  
  
> [!TIP]
>  内部的には、.NET は並べ替えキーを使用して、カルチャに依存した文字列の比較をサポートします。 文字列内の各文字には、アルファベット順、大文字と小文字の区別、発音の区別など、さまざまなカテゴリの並べ替えウェイトが指定されます。 <xref:System.Globalization.SortKey>クラスによって表される並べ替えキーは、特定の文字列に対してこれらの重みのリポジトリを提供します。 アプリが同じ文字列セットに対して多数の検索または並べ替え操作を実行する場合、使用するすべての文字列に対して並べ替えキーを生成して格納することで、パフォーマンスを向上させることができます。 並べ替えまたは比較操作が必要な場合は、文字列の代わりに並べ替えキーを使用します。 詳細については、<xref:System.Globalization.SortKey> クラスを参照してください。  
  
 文字列比較規則を指定しない場合、などの並べ替えメソッド<xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType>は、カルチャに依存し、大文字と小文字を区別する文字列の並べ替えを実行します。 次の例は、現在のカルチャを変更することによって、配列内の並べ替えられた文字列の順序に影響を与える方法を示しています。 この例では、3つの文字列の配列を作成します。 最初に、`System.Threading.Thread.CurrentThread.CurrentCulture` プロパティを en-US に設定し、<xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> メソッドを呼び出します。 これよって、英語 (米国) カルチャの並べ替え規則に基づく並べ替え順序が適用されます。 次に、`System.Threading.Thread.CurrentThread.CurrentCulture` プロパティを da-DK に設定し、再度 <xref:System.Array.Sort%2A?displayProperty=nameWithType> メソッドを呼び出します。 適用される並べ替え順序が en-US の並べ替え順序と異なる点に注意してください。これは、デンマーク語 (デンマーク) の並べ替え規則が使用されるためです。  
  
 [!code-csharp[Conceptual.Strings.Comparing#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.comparing/cs/sort1.cs#3)]
 [!code-vb[Conceptual.Strings.Comparing#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.comparing/vb/sort1.vb#3)]  
  
> [!WARNING]
>  文字列を比較する主な目的が等しいかどうかを判断するには、 <xref:System.String.Equals%2A?displayProperty=nameWithType>メソッドを呼び出す必要があります。 通常は、を使用<xref:System.String.Equals%2A>して序数による比較を実行する必要があります。 メソッド<xref:System.String.Compare%2A?displayProperty=nameWithType>は、主に文字列の並べ替えを目的としています。  
  
 文字列検索メソッド ( <xref:System.String.StartsWith%2A?displayProperty=nameWithType>や<xref:System.String.IndexOf%2A?displayProperty=nameWithType>など) では、カルチャに依存した文字列の比較も実行できます。 次の例は、 <xref:System.String.IndexOf%2A>メソッドを使用した、序数とカルチャに依存した比較の違いを示しています。 現在のカルチャが英語 (米国) であるカルチャに依存した検索では、部分文字列 "oe" が合字 "する。" と一致すると見なされます。 ソフトハイフン (U + 00ad) はゼロ幅の文字であるため、検索では、ソフトハイフンを<xref:System.String.Empty>と同等のものとして扱い、文字列の先頭で一致を検索します。 一方、序数検索では、どちらの場合も一致が見つかりません。  
  
 [!code-cpp[System.String.Class#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare3.cpp#13)]
 [!code-csharp[System.String.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare3.cs#13)]
 [!code-vb[System.String.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare3.vb#13)]  
  
### <a name="searching-strings"></a>文字列の検索  
 文字列検索メソッド (や<xref:System.String.StartsWith%2A?displayProperty=nameWithType> <xref:System.String.IndexOf%2A?displayProperty=nameWithType>など) では、カルチャに依存した文字列比較や序数の文字列比較を実行して、指定した文字列に文字または部分文字列が見つかったかどうかを判断することもできます。  
  
 メソッドなどの個々の<xref:System.String>文字<xref:System.String.IndexOfAny%2A>を検索するクラスの検索メソッド、またはメソッドなどの文字セットのいずれかで、すべて序数検索が実行されます。 <xref:System.String.IndexOf%2A> 文字に対して<xref:System.Globalization.CompareInfo> <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>カルチャに依存した検索を実行するには、や<xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>などのメソッドを呼び出す必要があります。 序数とカルチャに依存した比較を使用して文字を検索した結果は、大きく異なることに注意してください。 たとえば、カルチャによっては、カルチャに応じて、"AE" (U + 041U + 0045) のように、構成済みの Unicode 文字 ("AE" (U + 041U +) など) を検索する場合は、カルチャによって異なります。 次の例は、個々の文字<xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType>を<xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>検索するときのメソッドとメソッドの違いを示しています。 文字列 "æ" (U + 00E6) は、en-us カルチャの規則を使用する場合は文字列 "航空写真" にありますが、-DK カルチャの規則を使用する場合や序数の比較を実行する場合には見つかりません。  
  
 [!code-csharp[System.String.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/search1.cs#22)]
 [!code-vb[System.String.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/search1.vb#22)]  
  
 一方、検索オプションが<xref:System.String>型<xref:System.StringComparison>のパラメーターによって明示的に指定されていない場合、文字ではなく文字列を検索するクラスメソッドは、カルチャに依存した検索を実行します。 唯一の例外は<xref:System.String.Contains%2A>で、序数検索を実行します。  
  
<a name="equality"></a>   
### <a name="testing-for-equality"></a>等しいかどうかのテスト  
 並べ替え順序<xref:System.String.Compare%2A?displayProperty=nameWithType>において2つの文字列の関係を確認するには、メソッドを使用します。 通常、これはカルチャに依存する操作です。 これに対して、 <xref:System.String.Equals%2A?displayProperty=nameWithType>メソッドを呼び出して、等しいかどうかをテストします。 通常、等しいかどうかのテストでは、ユーザー入力と、有効なユーザー名、パスワード、またはファイルシステムパスなどの既知の文字列を比較します。これは通常、序数操作です。  
  
> [!WARNING]
>  <xref:System.String.Compare%2A?displayProperty=nameWithType>メソッドを呼び出し、戻り値が0かどうかを判断することで、等しいかどうかをテストできます。 ただし、この方法は推奨されません。 2つの文字列が等しいかどうかを判断するには、 <xref:System.String.Equals%2A?displayProperty=nameWithType>メソッドのオーバーロードのいずれかを呼び出す必要があります。 どちらのメソッドにも、比較の種類<xref:System.String.Equals%28System.String%2CSystem.StringComparison%29>を明示的に<xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29>指定する<xref:System.StringComparison?displayProperty=nameWithType>パラメーターが含まれているので、呼び出すには、インスタンスメソッドまたは静的メソッドのいずれかを使用することをお勧めします。  
  
 次の例は、序数を使用する必要がある場合に、カルチャに依存した比較を実行する危険性を示しています。 この場合、コードの目的は、"FILE://" という文字列の URL の先頭を大文字小文字を区別しない比較を実行することで、"FILE://" または "file://" で始まる Url からのファイルシステムアクセスを禁止することです。 ただし、カルチャに依存した比較が、"file://" で始まる URL でトルコ語 (トルコ) カルチャを使用して実行された場合、等値比較は失敗します。これは、小文字の "i" が "i" ではなく "i" であるためです。 その結果、ファイルシステムへのアクセスが誤って許可されます。 一方、序数に基づく比較を実行すると、等値比較が成功し、ファイルシステムアクセスが拒否されます。  
  
 [!code-cpp[System.String.Class#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.equals.cpp#11)]
 [!code-csharp[System.String.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/equality1.cs#11)]
 [!code-vb[System.String.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/equality1.vb#11)]  
  
<a name="Normalization"></a>   
## <a name="normalization"></a>正規化  
 Unicode 文字には複数の表現があります。 たとえば、次のコードポイントは、"ắ" という文字を表すことができます。  
  
-   U+1EAF  
  
-   U + 0103 U + 0301  
  
-   U + 0061 U + 0306 U + 0301  
  
 1つの文字に対して複数の表現を使用すると、検索、並べ替え、照合、およびその他の文字列操作が複雑になります。  
  
 Unicode 規格では、同等のバイナリ表現に対して Unicode 文字の1つのバイナリ表現を返す正規化と呼ばれるプロセスが定義されています。 正規化では、さまざまなルールに従って、正規化形式と呼ばれる複数のアルゴリズムを使用できます。 .NET では、Unicode 正規形 C、D、KC、および KD がサポートされています。 文字列が同じ正規化形式に正規化されている場合は、序数による比較を使用して比較できます。  
  
 序数による比較は、各文字列の対応する<xref:System.Char>オブジェクトの Unicode スカラー値のバイナリ比較です。 クラス<xref:System.String>には、次のような序数による比較を実行できるさまざまなメソッドが含まれています。  
  
-   <xref:System.String.Compare%2A> <xref:System.String.Equals%2A>パラメーターを含む<xref:System.String.EndsWith%2A>、、、、 、および<xref:System.String.LastIndexOf%2A>の各メソッドのすべてのオーバーロード。 <xref:System.String.IndexOf%2A> <xref:System.String.StartsWith%2A> <xref:System.StringComparison> このパラメーターにまたは<xref:System.StringComparison.Ordinal?displayProperty=nameWithType> <xref:System.StringComparison.OrdinalIgnoreCase>の値を指定すると、メソッドによって序数の比較が実行されます。  
  
-   <xref:System.String.CompareOrdinal%2A>メソッドのオーバーロード。  
  
-   <xref:System.String.Contains%2A> 、<xref:System.String.Replace%2A> 、<xref:System.String.Split%2A>など、既定で序数による比較を使用するメソッド。  
  
-   文字列インスタンス内の<xref:System.Char> <xref:System.Char>配列内の値または要素を検索するメソッド。 このような<xref:System.String.IndexOf%28System.Char%29>メソッド<xref:System.String.Split%28System.Char%5B%5D%29>には、とが含まれます。  
  
 <xref:System.String.IsNormalized?displayProperty=nameWithType>メソッドを呼び出すことによって文字列が正規形 C に正規化されるかどうかを判断<xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=nameWithType>できます。また、メソッドを呼び出して、文字列が指定した正規化形式に正規化されているかどうかを判断することもできます。 メソッドを呼び出して<xref:System.String.Normalize?displayProperty=nameWithType>文字列を正規形 C に変換することもできます。また、メソッドを呼び出して<xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=nameWithType> 、文字列を指定した正規化形式に変換することもできます。 文字列の正規化と比較の詳細な手順については、メソッド<xref:System.String.Normalize>と<xref:System.String.Normalize%28System.Text.NormalizationForm%29>メソッドを参照してください。  
  
 次の簡単な例は、文字列の正規化を示しています。 この例では、3つの異なる文字列の3つの異なる方法で文字 "ố" を定義し、等値比較を使用して、各文字列が他の2つの文字列と異なることを判断します。 次に、各文字列をサポートされている正規化形式に変換し、指定された正規化形式で各文字列の序数による比較を実行します。 どちらの場合も、2番目の等しいテストでは、文字列が等しいことが示されます。  
  
 [!code-cpp[System.String.Class#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.normalize.cpp#14)]
 [!code-csharp[System.String.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/normalize1.cs#14)]
 [!code-vb[System.String.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/normalize1.vb#14)]  
  
 正規化および正規化形式の詳細については<xref:System.Text.NormalizationForm?displayProperty=nameWithType>、「」 [および「Unicode 標準の付属品 #15」を参照してください。Unicode.org web サイト](https://unicode.org/reports/tr15/)での Unicode 正規形と正規化に関する[FAQ](https://www.unicode.org/faq/normalization.html) 。  
  
<a name="ByCategory"></a>   
## <a name="string-operations-by-category"></a>カテゴリ別の文字列操作  
 クラス<xref:System.String>は、文字列の比較、文字列の等価性のテスト、文字列内の文字または部分文字列の検索、文字列の変更、文字列の文字列の抽出、文字列の結合、値の書式設定、文字列のコピーを行うためのメンバーを提供します。文字列を正規化する。  
  
### <a name="comparing-strings"></a>文字列の比較  
 次<xref:System.String>のメソッドを使用すると、文字列を比較して、並べ替え順序における相対的な位置を決定できます。  
  
-   <xref:System.String.Compare%2A>並べ替え順序において、1つの文字列と2番目の文字列の関係を示す整数を返します。  
  
-   <xref:System.String.CompareOrdinal%2A>コードポイントの比較に基づいて、1つの文字列と2番目の文字列との関係を示す整数を返します。  
  
-   <xref:System.String.CompareTo%2A>並べ替え順序において、現在の文字列インスタンスと2番目の文字列との関係を示す整数を返します。 メソッド<xref:System.String.CompareTo%28System.String%29>は<xref:System.IComparable%601> 、クラス<xref:System.String>の<xref:System.IComparable>との実装を提供します。  
  
### <a name="testing-strings-for-equality"></a>文字列の等価性をテストする  
 2つの<xref:System.String.Equals%2A>文字列が等しいかどうかを判断するには、メソッドを呼び出します。 インスタンス<xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29>と静的<xref:System.String.Equals%28System.String%2CSystem.StringComparison%29>オーバーロードを使用すると、比較対象がカルチャに依存するか、序数であるか、また、大文字と小文字を区別するか無視するかを指定できます。 等しいかどうかのテストは序数で、システムリソースへのアクセスを決定する等価比較 (ファイルシステムオブジェクトなど) は常に序数である必要があります。  
  
### <a name="finding-characters-in-a-string"></a>文字列内の文字の検索  
 クラス<xref:System.String>には、次の2種類の検索メソッドが含まれています。  
  
-   特定の部分文字列<xref:System.Boolean>が文字列インスタンス内に存在するかどうかを示す値を返すメソッド。 これには<xref:System.String.Contains%2A>、 <xref:System.String.EndsWith%2A>、、 <xref:System.String.StartsWith%2A>およびの各メソッドが含まれます。  
  
-   文字列インスタンス内の部分文字列の開始位置を示すメソッド。 これには<xref:System.String.IndexOf%2A> <xref:System.String.IndexOfAny%2A> <xref:System.String.LastIndexOfAny%2A> 、、、、およびの各メソッドが含まれます。 <xref:System.String.LastIndexOf%2A>  
  
> [!WARNING]
>  特定の部分文字列ではなく特定のパターンの文字列を検索する場合は、正規表現を使用する必要があります。 詳細については、「 [.net の正規表現](~/docs/standard/base-types/regular-expressions.md)」を参照してください。  
  
### <a name="modifying-a-string"></a>文字列の変更  
 クラス<xref:System.String>には、文字列の値を変更するために表示される次のメソッドが含まれています。  
  
-   <xref:System.String.Insert%2A>現在<xref:System.String>のインスタンスに文字列を挿入します。  
  
-   <xref:System.String.PadLeft%2A>文字列の先頭に指定された文字を1回以上挿入します。  
  
-   <xref:System.String.PadRight%2A>文字列の末尾に、指定した文字を1回以上挿入します。  
  
-   <xref:System.String.Remove%2A>現在<xref:System.String>のインスタンスから部分文字列を削除します。  
  
-   <xref:System.String.Replace%2A>部分文字列を現在<xref:System.String>のインスタンス内の別の部分文字列に置き換えます。  
  
-   <xref:System.String.ToLower%2A>文字列<xref:System.String.ToLowerInvariant%2A>内のすべての文字を小文字に変換します。  
  
-   <xref:System.String.ToUpper%2A>文字列<xref:System.String.ToUpperInvariant%2A>内のすべての文字を大文字に変換します。  
  
-   <xref:System.String.Trim%2A>文字列の先頭と末尾から、出現するすべての文字を削除します。  
  
-   <xref:System.String.TrimEnd%2A>文字列の末尾から、出現するすべての文字を削除します。  
  
-   <xref:System.String.TrimStart%2A>文字列の先頭から、出現するすべての文字を削除します。  
  
> [!IMPORTANT]
>  すべての文字列変更メソッドは、 <xref:System.String>新しいオブジェクトを返します。 現在のインスタンスの値は変更されません。  
  
### <a name="extracting-substrings-from-a-string"></a>文字列からの部分文字列の抽出  
 メソッド<xref:System.String.Split%2A?displayProperty=nameWithType>は、1つの文字列を複数の文字列に分割します。 メソッドのオーバーロードを使用すると、複数の区切り記号を指定して、メソッドによって抽出される部分文字列の最大数を決定し、空の文字列 (区切り記号が隣接している場合に発生する) が返される文字列に含まれるかどうかを判断できます。  
  
### <a name="combining-strings"></a>結合 (文字列を)  
 文字列の<xref:System.String>連結には、次のメソッドを使用できます。  
  
-   <xref:System.String.Concat%2A>1つ以上の部分文字列を1つの文字列に結合します。  
  
-   <xref:System.String.Join%2A>1つ以上の部分文字列を連結して1つの要素にし、各部分文字列の間に区切り記号を追加します。  
  
### <a name="formatting-values"></a>値の書式設定  
 メソッド<xref:System.String.Format%2A?displayProperty=nameWithType>は、複合書式指定機能を使用して、文字列内の1つまたは複数のプレースホルダーを、いくつかのオブジェクトまたは値の文字列形式に置き換えます。 <xref:System.String.Format%2A>メソッドは、多くの場合、次の操作を行うために使用されます。  
  
-   数値の文字列形式を文字列に埋め込む場合は。  
  
-   日付と時刻の値の文字列形式を文字列に埋め込む場合は。  
  
-   列挙値の文字列形式を文字列に埋め込む場合は。  
  
-   <xref:System.IFormattable>インターフェイスをサポートするオブジェクトの文字列形式を文字列に埋め込む場合は。  
  
-   より大きな文字列内のフィールド内の部分文字列を右揃えまたは左揃えにする場合は。  
  
 書式設定操作と例の詳細については<xref:System.String.Format%2A> 、「オーバーロードの概要」を参照してください。  
  
### <a name="copying-a-string"></a>文字列のコピー  
 文字列のコピーを作成<xref:System.String>するには、次のメソッドを呼び出します。  
  
-   <xref:System.String.Clone%2A>既存<xref:System.String>のオブジェクトへの参照を返します。  
  
-   <xref:System.String.Copy%2A>既存の文字列のコピーを作成します。  
  
-   <xref:System.String.CopyTo%2A>文字列の一部を文字配列にコピーします。  
  
### <a name="normalizing-a-string"></a>文字列の正規化  
 Unicode では、1つの文字に複数のコードポイントを含めることができます。 正規化では、これらの同等の文字が同じバイナリ表現に変換されます。 メソッド<xref:System.String.Normalize%2A?displayProperty=nameWithType>は正規化を実行し、メソッド<xref:System.String.IsNormalized%2A?displayProperty=nameWithType>は文字列が正規化されているかどうかを判断します。  
  
 詳細と例については、このトピックで前述した「[正規化](#Normalization)」セクションを参照してください。  

 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://www.microsoft.com/download/details.aspx?id=10921">Windows オペレーティングシステムの重みテーブルの並べ替え</related>
    <related type="ExternalDocumentation" href="https://www.unicode.org/Public/UCA/latest/allkeys.txt">Linux および macOS 用の既定の Unicode 照合順序要素の表</related>
    <threadsafe>この型はスレッド セーフです。</threadsafe>
    <altmember cref="T:System.IComparable" />
    <altmember cref="T:System.ICloneable" />
    <altmember cref="T:System.IConvertible" />
    <altmember cref="T:System.Collections.IEnumerable" />
    <altmember cref="T:System.Text.StringBuilder" />
    <altmember cref="T:System.Globalization.CultureInfo" />
    <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET での型の書式設定</related>
    <related type="Article" href="https://msdn.microsoft.com/library/b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7">.NET Framework で文字列を使用するためのベスト プラクティス</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.String" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このセクションの内容:  
  
 [オーバーロードされたコンストラクターの構文](#Syntax)   
 [パラメータ](#Params)   
 [例外](#Exceptions)   
 [どの方法を呼び出すか。](#Tasks)   
 [作成 (文字列を)](#Creating_Strings)   
 [反復する文字列の処理](#Repetitive)   
 文字列のインスタンス化の例を次に示します。   
 [文字列割り当ての使用](#Ctor1_Example)  
 [文字配列の使用](#Ctor2_Example)  
 [文字配列の一部を使用して1つの文字を繰り返す](#Ctor3_Example)  
 [文字配列へのポインターの使用](#Ctor4_Example)  
 [ポインターと配列の範囲の使用](#Ctor5_Example)  
 [符号付きバイト配列へのポインターの使用](#Ctor6_Example)  
[バージョン情報](#Versions)  
  
<a name="Syntax"></a>   
## <a name="overloaded-constructor-syntax"></a>オーバーロードされたコンストラクターの構文  
 文字列コンストラクターは、ポインターパラメーターを持たない2つのカテゴリと、ポインターパラメーターを持つ2つのカテゴリに分類されます。 ポインターを使用するコンストラクターは CLS に準拠していません。 また、Visual Basic はポインターの使用をサポートしC#ていません。また、ポインターを使用して unsafe コンテキストで実行するコードが必要です。 詳しくは、「[unsafe](~/docs/csharp/language-reference/keywords/unsafe.md)」をご覧ください。  
  
 オーバーロードの選択に関するその他のガイダンスについては、「[呼び出すメソッド](#Tasks)」を参照してください。  
  
 `String(Char[] value)`  
 Unicode 文字の配列によって示される値に新しいインスタンスを初期化します。 このコンストラクターは、Unicode 文字 ([例](#Ctor2_Example)) をコピーします。  
  
 `String(Char[] value, Int32 startIndex, Int32 length)`  
 新しいインスタンスを、Unicode 文字の配列、配列内の開始文字位置、および長さ ([例](#Ctor3_Example)) で示される値に初期化します。  
  
 `String(Char c, Int32 count)`  
 指定した回数 ([例](#Ctor3_Example)) を繰り返して、指定した Unicode 文字で示される値に新しいインスタンスを初期化します。  
  
 `String(char* value)`  
 **(CLS に準拠していません)** Null 文字 (U + 0000 または ' \ 0 ') で終わる Unicode 文字の配列を指すポインターによって示される値に新しいインスタンスを初期化します。 ([例](#Ctor4_Example))。  
  
 アクセス許可<xref:System.Security.SecurityCriticalAttribute>:、は、直前の呼び出し元に対して完全な信頼を必要とします。 このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。  
  
 `String(char* value, Int32 startIndex, Int32 length)`  
 **(CLS に準拠していません)** Unicode 文字の配列へのポインター、配列内の開始文字位置、および長さによって示される値に、新しいインスタンスを初期化します。 コンストラクターは、 `value`インデックス`length` `startIndex`  +  [](#Ctor5_Example)から開始してインデックス-1 で終了する Unicode 文字をコピーします (例:)。 `startIndex`  
  
 アクセス許可<xref:System.Security.SecurityCriticalAttribute>:、は、直前の呼び出し元に対して完全な信頼を必要とします。 このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。  
  
 `String(SByte* value)`  
 **(CLS に準拠していません)** 新しいインスタンスを、8ビット符号付き整数の配列へのポインターによって示される値に初期化します。 配列は、現在のシステムコードページ (で<xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>指定されたエンコーディング) を使用してエンコードされた文字列を表すと見なされます。 コンストラクターは、null 文字`value` (0x00) に到達するまでポインターによって指定された位置から文字を処理します ([例](#Ctor6_Example))。  
  
 アクセス許可<xref:System.Security.SecurityCriticalAttribute>:、は、直前の呼び出し元に対して完全な信頼を必要とします。 このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。  
  
 `String(SByte* value, Int32 startIndex, Int32 length)`  
 **(CLS に準拠していません)** 新しいインスタンスを、8ビット符号付き整数の配列へのポインター、配列内の開始位置、および長さによって示される値に初期化します。  配列は、現在のシステムコードページ (で<xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>指定されたエンコーディング) を使用してエンコードされた文字列を表すと見なされます。 コンストラクターは、 `startIndex`から始まる値の文字を処理し、-1 ([例](#Ctor6_Example)) で`startIndex`  +  `length`終わります。  
  
 アクセス許可<xref:System.Security.SecurityCriticalAttribute>:、は、直前の呼び出し元に対して完全な信頼を必要とします。 このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。  
  
 `String(SByte* value, Int32 startIndex, Int32 length, Encoding enc)`  
 **(CLS に準拠していません)** 新しいインスタンスを、8ビット符号付き整数の配列へのポインター、配列内の開始位置、長さ、および<xref:System.Text.Encoding>オブジェクトによって示される値に初期化します。  
  
 アクセス許可<xref:System.Security.SecurityCriticalAttribute>:、は、直前の呼び出し元に対して完全な信頼を必要とします。 このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。  
  
<a name="Params"></a>   
## <a name="parameters"></a>パラメーター  
 ポインターパラメーターを含まないコンストラクターによって<xref:System.String>使用されるパラメーターの完全な一覧を次に示します。 各オーバーロードによって使用されるパラメーターについては、上記のオーバーロード構文を参照してください。  
  
|パラメーター|型|説明|  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>[]|Unicode 文字の配列。|  
|`c`|<xref:System.Char>|Unicode 文字。|  
|`startIndex`|<xref:System.Int32>|新しい文字列の最初`value`の文字の開始位置。<br /><br /> ［既定値］:0|  
|`length`|<xref:System.Int32>|新しい文字列に含めるの`value`文字数。<br /><br /> 既定値: <xref:System.Array.Length%2A?displayProperty=nameWithType>|  
|`count`|<xref:System.Int32>|新しい文字列で文字`c`が繰り返される回数。 が`count` 0 の場合、新しいオブジェクトの値は<xref:System.String.Empty?displayProperty=nameWithType>になります。|  
  
 ポインターパラメーターを含むコンストラクターによって<xref:System.String>使用されるパラメーターの完全な一覧を次に示します。 各オーバーロードによって使用されるパラメーターについては、上記のオーバーロード構文を参照してください。  
  
|パラメーター|型|説明|  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>*<br /><br /> - または -<br /><br /> <xref:System.SByte>\*|Null で終わる Unicode 文字配列または8ビット符号付き整数の配列へのポインター。 <xref:System.String.Empty?displayProperty=nameWithType>が`value` または空の配列の場合、新しい文字列の値はになります。`null`|  
|`startIndex`|<xref:System.Int32>|新しい文字列の最初の文字を定義する配列要素のインデックス。<br /><br /> ［既定値］:0|  
|`length`|<xref:System.Int32>|新しい文字列を作成するために使用する配列要素の数。 Length が0の場合、コンストラクターは値がで<xref:System.String.Empty?displayProperty=nameWithType>ある文字列を作成します。<br /><br /> 既定値: <xref:System.Array.Length%2A?displayProperty=nameWithType>|  
|`enc`|<xref:System.Text.Encoding>|配列の`value`エンコード方法を指定するオブジェクト。<br /><br /> 既定値: <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>、またはシステムの現在の ANSI コードページ|  
  
<a name="Exceptions"></a>   
## <a name="exceptions"></a>例外  
 ポインターパラメーターを含まないコンストラクターによってスローされる例外の一覧を次に示します。  
  
|例外|条件|スロー者|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentNullException>|`value` は `null`です。|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
|<xref:System.ArgumentOutOfRangeException>|`startIndex`、`length`、また`count`はが0未満です。<br /><br /> または<br /><br /> `startIndex` と `length` の合計が、`value` にある要素の数を超えています。<br /><br /> - または -<br /><br /> `count` が 0 未満です。|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
  
 ポインターパラメーターを含むコンストラクターによってスローされる例外の一覧を次に示します。  
  
|例外|条件|スロー者|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentException>|`value`無効な Unicode 文字を含む配列を指定します。<br /><br /> - または -<br /><br /> `value`また`value`は +  が64k未満のアドレスを指定し`startIndex`ています。<br /><br /> - または -<br /><br /> 既定の<xref:System.String>コードページエンコーディングが使用さ`value`れてい`value`ないため、新しいインスタンスをバイト配列から初期化できませんでした。|ポインターを持つすべてのコンストラクター。|  
|<xref:System.ArgumentNullException>|`value` が null です。|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|<xref:System.ArgumentOutOfRangeException>|現在のプロセスは、アドレス指定されたすべての文字に対する読み取りアクセス権を持っているわけではありません。<br /><br /> - または -<br /><br /> `startIndex` または `length` が 0 未満であるか、`value` + `startIndex` によりポインターのオーバーフローが発生するか、または現在のプロセスにはすべてのアドレス指定された文字に対する読み取りアクセス許可がありません。<br /><br /> - または -<br /><br /> 新しい文字列の長さが大きすぎて割り当てられません。|ポインターを持つすべてのコンストラクター。|  
|<xref:System.AccessViolationException>|`value`、、 `value`または +  `startIndex` - 1が無効なアドレスを指定しています。 +  `length`|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
  
<a name="Tasks"></a>   
## <a name="which-method-do-i-call"></a>どの方法を呼び出すか。  
  
|終了|呼び出しまたは使用|  
|--------|-----------------|  
|文字列を作成します。|文字列リテラルまたは既存の文字列からの割り当て ([例](#Ctor1_Example))|  
|文字配列全体から文字列を作成します。|<xref:System.String.%23ctor%28System.Char%5B%5D%29>([例](#Ctor2_Example))|  
|文字配列の一部から文字列を作成します。|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>([例](#Ctor3_Example))|  
|同じ文字を複数回繰り返す文字列を作成します。|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29>([例](#Ctor3_Example))|  
|Unicode またはワイド文字配列へのポインターから文字列を作成します。|<xref:System.String.%23ctor%28System.Char%2A%29>|  
|ポインターを使用して、Unicode またはワイド文字配列の一部から文字列を作成します。|<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>|  
|`char`配列からC++文字列を作成します。|<xref:System.String.%23ctor%28System.SByte%2A%29>、 <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> - または -<br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|ASCII 文字から文字列を作成します。|<xref:System.Text.ASCIIEncoding.GetString%2A?displayProperty=nameWithType>|  
  
<a name="Creating_Strings"></a>   
## <a name="creating-strings"></a>作成 (文字列を)  
 プログラムによって文字列を作成するために最もよく使用される手法は、[この例](#Ctor1_Example)に示すように単純な代入です。 クラス<xref:System.String>には、次の値から文字列を作成できる4種類のコンストラクターオーバーロードも含まれています。  
  
-   文字配列から (UTF-16 でエンコードされた文字の配列)。 配列全体またはその<xref:System.String>一部の文字から新しいオブジェクトを作成できます。 コンストラクター <xref:System.String.%23ctor%28System.Char%5B%5D%29>は、配列内のすべての文字を新しい文字列にコピーします。 コンストラクター <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>は、インデックス`startIndex`からインデックス`startIndex`  +  - 1への文字を新しい文字列にコピーします。`length` が`length` 0 の場合、新しい文字列の値は<xref:System.String.Empty?displayProperty=nameWithType>になります。  
  
     同じ値を持つ文字列をコードで繰り返しインスタンス化する場合は、文字列を作成する別の方法を使用して、アプリケーションのパフォーマンスを向上させることができます。 詳細については、「[反復する文字列の処理](#Repetitive)」を参照してください。  
  
-   <xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29>コンストラクターを使用して、0回、1回、または複数回複製された単一の文字から。 が`count` 0 の場合、新しい文字列の値は<xref:System.String.Empty?displayProperty=nameWithType>になります。  
  
-   <xref:System.String.%23ctor%28System.Char%2A%29>または<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>コンストラクターを使用して、null で終わる文字配列へのポインターから。 文字列を初期化するために、配列全体または指定された範囲を使用できます。 コンストラクターは、指定されたポインター、または指定されたポインター `startIndex`から始まる Unicode 文字のシーケンスをコピーし、配列の末尾`length`または文字を続けます。 が`value` null ポインターの場合、 `length`またはがゼロの場合、コンストラクターは値が<xref:System.String.Empty?displayProperty=nameWithType>である文字列を作成します。 コピー操作が配列の末尾に進み、配列が null で終了していない場合、コンストラクターの動作はシステムに依存します。 このような状況では、アクセス違反が発生する可能性があります。  
  
     配列に埋め込まれた null 文字 (U + 0000 または ' \ 0 ') <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>が含まれていて、オーバーロードが呼び出された場合、文字列インスタンスには埋め込まれた null を含む文字が含まれ`length`ます。 次の例は、2つの null 文字を含む10個の要素の配列へのポインターが<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>メソッドに渡された場合の動作を示しています。 アドレスが配列の先頭で、配列内のすべての要素が文字列に追加されるため、コンストラクターは、2つの埋め込み null を含む10文字の文字列をインスタンス化します。 一方、同じ配列が<xref:System.String.%23ctor%28System.Char%2A%29>コンストラクターに渡された場合、結果は、最初の null 文字を含まない4文字の文字列になります。  
  
     [!code-cpp[System.String.ctor#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/chptrctor_null.cpp#5)]
     [!code-csharp[System.String.ctor#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/chptrctor_null.cs#5)]  
  
     配列には Unicode 文字を含める必要があります。 でC++は、これは、文字配列をマネージ<xref:System.Char>[] 型またはアンマネージ`wchar_t`[] 型として定義する必要があることを意味します。  
  
     `startIndex` <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> `length`  + オーバーロードが呼び出され、配列が null で終了していない場合、またはオーバーロードが呼び出され、-1 が文字シーケンスに割り当てられたメモリの外側にある範囲を含む場合は、 <xref:System.String.%23ctor%28System.Char%2A%29>コンストラクターの動作はシステムに依存し、アクセス違反が発生する可能性があります。 さらに、Intel Itanium プロセッサでは、コンストラクターの<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>呼び出しによって<xref:System.DataMisalignedException>例外がスローされる場合があります。 このエラーが発生した<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>場合は、代わりにを呼び出します。  
  
-   符号付きバイト配列へのポインターから。 文字列を初期化するために、配列全体または指定された範囲を使用できます。 バイトシーケンスは、既定のコードページエンコーディングを使用して解釈できます。また、コンストラクター呼び出しでエンコーディングを指定することもできます。 コンストラクターが、null で終了しない配列全体からの文字列のインスタンス化を試行する場合`value` 、またはから +  `value`  +  `startIndex`へ`startIndex`  +  の配列の範囲がの場合は。`length` -1 は配列に割り当てられたメモリの範囲外です。このコンストラクターの動作はシステムに依存し、アクセス違反が発生する可能性があります。  
  
     次の例に示すように、パラメーターとして符号付きバイト配列を含むC++ `char` 3 つのコンストラクターは、主に配列を文字列に変換するように設計されています。  
  
     [!code-cpp[System.String.Ctor#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/sbyte_ctor1.cpp#4)]  
  
     配列に null 文字 (' \ 0 ')、または値が 0 <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29>でオーバーロードが呼び出されるバイトが含まれている場合、文字列インスタンスには埋め込まれた null を含む文字が含まれ`length`ます。 次の例は、2つの null 文字を含む10個の要素の配列へのポインターが<xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29>メソッドに渡された場合の動作を示しています。 アドレスが配列の先頭で、配列内のすべての要素が文字列に追加されるため、コンストラクターは、2つの埋め込み null を含む10文字の文字列をインスタンス化します。 一方、同じ配列が<xref:System.String.%23ctor%28System.SByte%2A%29>コンストラクターに渡された場合、結果は、最初の null 文字を含まない4文字の文字列になります。  
  
     [!code-cpp[System.String.ctor#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/ptrctor_null.cpp#6)]
     [!code-csharp[System.String.ctor#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ptrctor_null.cs#6)]  
  
     コンストラクターと<xref:System.String.%23ctor%28System.SByte%2A%29> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29>コンストラクターは既定`value`の ANSI コードページを使用して解釈されるため、同じバイト配列を使用してこれらのコンストラクターを呼び出すと、異なるシステムで異なる値を持つ文字列が作成される可能性があります。  
  
<a name="Repetitive"></a>   
## <a name="handling-repetitive-strings"></a>反復する文字列の処理  
 テキストストリームを解析またはデコードするアプリでは<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 、多くの<xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType>場合、コンストラクターまたはメソッドを使用して、文字のシーケンスを文字列に変換します。 1つの文字列を作成して再利用する代わりに、同じ値を使用して新しい文字列を繰り返し作成すると、メモリが浪費されます。 <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>コンストラクターを呼び出して同じ文字列値を繰り返し作成する可能性が高い場合は、その同じ文字列値を事前に把握していなくても、参照テーブルを使用できます。  
  
 たとえば、XML タグと属性を含むファイルから文字のストリームを読み取って解析したとします。 ストリームを解析すると、特定のトークン (つまり、シンボルの意味を持つ文字のシーケンス) が繰り返し発生します。 文字列 "0"、"1"、"true"、および "false" に相当するトークンは、XML ストリームで頻繁に発生する可能性があります。  
  
 各トークンを新しい文字列に変換するのではなく、一般的<xref:System.Xml.NameTable?displayProperty=nameWithType>に発生する文字列を保持するオブジェクトを作成できます。 オブジェクト<xref:System.Xml.NameTable>を使用すると、一時メモリを割り当てずに格納されている文字列を取得するため、パフォーマンスが向上します。 トークンが見つかった場合は、 <xref:System.Xml.NameTable.Get%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType>メソッドを使用してテーブルからトークンを取得します。 トークンが存在する場合、メソッドは対応する文字列を返します。 トークンが存在しない場合は、 <xref:System.Xml.NameTable.Add%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType>メソッドを使用してトークンをテーブルに挿入し、対応する文字列を取得します。  
  
<a name="Ctor1_Example"></a>   
## <a name="example-1-using-string-assignment"></a>例 1: 文字列割り当ての使用  
 次の例では、文字列リテラルを割り当てることによって新しい文字列を作成します。 最初の文字列の値を割り当てることによって、2番目の文字列を作成します。 これらは、新しい<xref:System.String>オブジェクトをインスタンス化する最も一般的な2つの方法です。  
  
 [!code-cpp[System.String.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/assignment.cpp#1)]
 [!code-csharp[System.String.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.String.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.ctor/vb/ctor1.vb#1)]  
  
<a name="Ctor2_Example"></a>   
## <a name="example-2-using-a-character-array"></a>例 2:文字配列の使用  
 次の例は、文字配列から新しい<xref:System.String>オブジェクトを作成する方法を示しています。  
  
 [!code-cpp[stringexample1#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#1)]
 [!code-csharp[stringexample1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#1)]
 [!code-vb[stringexample1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#1)]  
  
<a name="Ctor3_Example"></a>   
## <a name="example-3-using-a-portion-of-a-character-array-and-repeating-a-single-character"></a>例 3: 文字配列の一部を使用して1つの文字を繰り返す  
 次の例では、文字配列の<xref:System.String>一部から新しいオブジェクトを作成する方法と、1つの文字の<xref:System.String>複数の出現箇所を含む新しいオブジェクトを作成する方法を示します。  
  
 [!code-cpp[stringexample1#3](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#3)]
 [!code-csharp[stringexample1#3](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#3)]
 [!code-vb[stringexample1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#3)]  
  
<a name="Ctor4_Example"></a>   
## <a name="example-4-using-a-pointer-to-a-character-array"></a>例 4:文字配列へのポインターの使用  
 次の例は、文字の配列へ<xref:System.String>のポインターから新しいオブジェクトを作成する方法を示しています。 このC#例は、 `/unsafe`コンパイラスイッチを使用してコンパイルする必要があります。  
  
 [!code-cpp[System.String.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char1_ctor.cpp#2)]
 [!code-csharp[System.String.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor2.cs#2)]  
  
<a name="Ctor5_Example"></a>   
## <a name="example-5-instantiating-a-string-from-a-pointer-and-a-range-of-an-array"></a>例 5:ポインターと配列の範囲からの文字列のインスタンス化  
 次の例では、ピリオドまたは感嘆符のいずれかの文字配列の要素を調べます。 見つかった場合は、区切り記号の前にある配列内の文字から文字列をインスタンス化します。 そうでない場合は、配列の内容全体を含む文字列がインスタンス化されます。 このC#例は、 `/unsafe`コンパイラスイッチを使用してコンパイルする必要があります。  
  
 [!code-cpp[System.String.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char2_ctor.cpp#3)]
 [!code-csharp[System.String.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/char2_ctor.cs#3)]  
  
<a name="Ctor6_Example"></a>   
## <a name="example-6-instantiating-a-string-from-a-pointer-to-a-signed-byte-array"></a>例 6:符号付きバイト配列へのポインターからの文字列のインスタンス化  
 次の例は、 <xref:System.String> <xref:System.String.%23ctor%28System.SByte%2A%29>コンストラクターを使用してクラスのインスタンスを作成する方法を示しています。  
  
 [!code-cpp[stringexample1#2](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#2)]
 [!code-csharp[stringexample1#2](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#2)]  
  
<a name="Versions"></a>   
## <a name="version-information"></a>バージョン情報  
 .NET Framework  
 次のすべてのオーバーロードがサポートされています。4.5、4、3.5、3.0、2.0、1.1、1.0  
  
 .NET Framework Client Profile  
 次のすべてのオーバーロードがサポートされています。4、3.5 SP1  
  
 ポータブル クラス ライブラリ  
 `*`パラメーターのない<xref:System.SByte>すべてのオーバーロードがサポートされています  
  
 Windows ストア アプリ用 .NET  
 `*`パラメーターのない<xref:System.SByte>すべてのオーバーロードは、でサポートされています。Windows 8  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
      </Parameters>
      <Docs>
        <param name="value">Unicode 文字の null で終わる配列へのポインター。</param>
        <summary><see cref="T:System.String" /> クラスの新しいインスタンスを初期化し、指定した Unicode 文字配列を指すポインターにより示される値に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  このコンストラクターと他の`String`コンストラクターのオーバーロードに関する例と包括的な使用方法については、 <xref:System.String.%23ctor%2A> 「コンストラクターの概要」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">現在のプロセスは、アドレス指定されたすべての文字に対する読み取りアクセス権を持っているわけではありません。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> が正しくない Unicode 文字を含む配列を指定しているか、<paramref name="value" /> が 64000 未満のアドレスを指定しています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に完全信頼が必要です。 このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="new string : char[] -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">Unicode 文字の配列。</param>
        <summary><see cref="T:System.String" /> クラスの新しいインスタンスを初期化し、Unicode 文字の配列により示される値に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  このコンストラクターと他の`String`コンストラクターのオーバーロードに関する例と包括的な使用方法については、 <xref:System.String.%23ctor%2A> 「コンストラクターの概要」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Char))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="new string : ReadOnlySpan&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">終端が null の 8 ビット符号付き整数の配列へのポインター。 整数は、現在のシステム コード ページ エンコーディング (つまり、<see cref="P:System.Text.Encoding.Default" /> が指定したエンコーディング) を使用して解釈されます。</param>
        <summary><see cref="T:System.String" /> クラスの新しいインスタンスを初期化し、8 ビット符号付き整数の配列を指すポインターにより示される値に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  このコンストラクターと他の`String`コンストラクターのオーバーロードに関する例と包括的な使用方法については、 <xref:System.String.%23ctor%2A> 「コンストラクターの概要」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><see cref="T:System.String" /> の新しいインスタンス を、<paramref name="value" /> を使用して初期化できませんでした。<paramref name="value" /> が ANSI でエンコードされていると想定しています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="value" /> の Null 終端文字によって決定される初期化する新しい文字列の長さが、大きすぎて割り当てられません。</exception>
        <exception cref="T:System.AccessViolationException"><paramref name="value" /> に指定されたアドレスが正しくありません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に完全信頼が必要です。 このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char c, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char c, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (c As Char, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char c, int count);" />
      <MemberSignature Language="F#" Value="new string : char * int -&gt; string" Usage="new System.string (c, count)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="c">Unicode 文字。</param>
        <param name="count"><paramref name="c" /> の発生回数。</param>
        <summary><see cref="T:System.String" /> クラスの新しいインスタンスを初期化し、指定した回数だけ繰り返した指定の Unicode 文字が示す値に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  このコンストラクターと他の`String`コンストラクターのオーバーロードに関する例と包括的な使用方法については、 <xref:System.String.%23ctor%2A> 「コンストラクターの概要」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> が 0 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Unicode 文字の配列を指すポインター。</param>
        <param name="startIndex"><paramref name="value" /> 内の開始位置。</param>
        <param name="length">使用する <paramref name="value" /> 内の文字数。</param>
        <summary><see cref="T:System.String" /> クラスの新しいインスタンスを初期化し、Unicode 文字の配列を指す指定のポインター、配列内の開始文字位置、および長さにより示される値に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  このコンストラクターと他の`String`コンストラクターのオーバーロードに関する例と包括的な使用方法については、 <xref:System.String.%23ctor%2A> 「コンストラクターの概要」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> または <paramref name="length" /> が 0 未満であるか、<paramref name="value" /> + <paramref name="startIndex" /> によりポインターのオーバーフローが発生するか、または現在のプロセスにはすべてのアドレス指定された文字に対する読み取りアクセス許可がありません。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> が正しくない Unicode 文字を含む配列を指定しているか、<paramref name="value" /> + <paramref name="startIndex" /> が 64000 未満のアドレスを指定しています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に完全信頼が必要です。 このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : char[] * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Unicode 文字の配列。</param>
        <param name="startIndex"><paramref name="value" /> 内の開始位置。</param>
        <param name="length">使用する <paramref name="value" /> 内の文字数。</param>
        <summary><see cref="T:System.String" /> クラスの新しいインスタンスを初期化し、Unicode 文字の配列、配列内の開始文字位置、および長さにより示される値に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  このコンストラクターと他の`String`コンストラクターのオーバーロードに関する例と包括的な使用方法については、 <xref:System.String.%23ctor%2A> 「コンストラクターの概要」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> または <paramref name="length" /> が 0 未満です。  
  
または 
<paramref name="startIndex" /> と <paramref name="length" /> の合計が、<paramref name="value" /> にある要素の数を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">8 ビット符号付き整数の配列へのポインター。 整数は、現在のシステム コード ページ エンコーディング (つまり、<see cref="P:System.Text.Encoding.Default" /> が指定したエンコーディング) を使用して解釈されます。</param>
        <param name="startIndex"><paramref name="value" /> 内の開始位置。</param>
        <param name="length">使用する <paramref name="value" /> 内の文字数。</param>
        <summary><see cref="T:System.String" /> クラスの新しいインスタンスを初期化し、8 ビット符号付き整数の配列を指す指定のポインター、配列内の開始位置、および長さにより示される値に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  このコンストラクターと他の`String`コンストラクターのオーバーロードに関する例と包括的な使用方法については、 <xref:System.String.%23ctor%2A> 「コンストラクターの概要」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> または <paramref name="length" /> が 0 未満です。  
  
または 
<paramref name="value" /> + <paramref name="startIndex" /> で指定されたアドレスが現在のプラットフォームにとって大きすぎて、アドレス計算がオーバーフローしました。  
  
- または - 
初期化する新しい文字列の長さが大きすぎて割り当てられません。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> + <paramref name="startIndex" /> で指定されるアドレスは 64 K 未満です。  
  
または 
<see cref="T:System.String" /> の新しいインスタンスを、<paramref name="value" /> を使用して初期化できませんでした (<paramref name="value" /> が ANSI でエンコードされていると想定)。</exception>
        <exception cref="T:System.AccessViolationException"><paramref name="value" />、<paramref name="startIndex" />、<paramref name="length" /> 全体で、正しくないアドレスを指定しています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に完全信頼が必要です。 このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length, System.Text.Encoding enc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length, class System.Text.Encoding enc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length, System::Text::Encoding ^ enc);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int * System.Text.Encoding -&gt; string" Usage="new System.string (value, startIndex, length, enc)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="enc" Type="System.Text.Encoding" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">8 ビット符号付き整数の配列へのポインター。</param>
        <param name="startIndex"><paramref name="value" /> 内の開始位置。</param>
        <param name="length">使用する <paramref name="value" /> 内の文字数。</param>
        <param name="enc"><paramref name="value" /> が参照する配列のエンコード方法を指定するオブジェクト。 <paramref name="enc" /> が <see langword="null" /> の場合は、ANSI エンコーディングが指定されていると見なされます。</param>
        <summary><see cref="T:System.String" /> クラスの新しいインスタンスを初期化し、8 ビット符号付き整数の配列を指す指定のポインター、配列内の開始位置、長さ、および <see cref="T:System.Text.Encoding" /> オブジェクトにより示される値に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  このコンストラクターと他の`String`コンストラクターのオーバーロードに関する例と包括的な使用方法については、 <xref:System.String.%23ctor%2A> 「コンストラクターの概要」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> または <paramref name="length" /> が 0 未満です。  
  
- または - 
<paramref name="value" /> + <paramref name="startIndex" /> で指定されたアドレスが現在のプラットフォームにとって大きすぎて、アドレス計算がオーバーフローしました。  
  
または 
初期化する新しい文字列の長さが大きすぎて割り当てられません。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> + <paramref name="startIndex" /> で指定されるアドレスは 64 K 未満です。  
  
- または - 
<see cref="T:System.String" /> の新しいインスタンスを、<paramref name="value" /> を使用して初期化できませんでした。<paramref name="value" /> が <paramref name="enc" /> の指定に従ってエンコードされていると想定しています。</exception>
        <exception cref="T:System.AccessViolationException"><paramref name="value" />、<paramref name="startIndex" />、<paramref name="length" /> 全体で、正しくないアドレスを指定しています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に完全信頼が必要です。 このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[Index index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(valuetype System.Index)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Index)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Chars(index As Index) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[Index] { char get(Index index); };" />
      <MemberSignature Language="F#" Value="member this.Chars(Index) : char" Usage="System.string.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Index" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Chars(int) : char" Usage="System.string.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">現在の文字列内の位置。</param>
        <summary>現在の <see cref="T:System.String" /> オブジェクト内の指定された位置にある <see cref="T:System.Char" /> オブジェクトを取得します。</summary>
        <value><paramref name="index" /> 位置にあるオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `index`パラメーターは0から始まります。  
  
 このプロパティは、 <xref:System.Char> `index`パラメーターによって指定された位置にあるオブジェクトを返します。 ただし、Unicode 文字は複数の文字で<xref:System.Char>表される場合があります。 <xref:System.Char>オブジェクトで<xref:System.Globalization.StringInfo?displayProperty=nameWithType>はなく Unicode 文字を操作するには、クラスを使用します。 詳細については、「クラスの<xref:System.String>概要」の「Char オブジェクトと Unicode 文字」セクションを参照してください。  
  
 でC#は、プロパティはインデクサー<xref:System.String.Chars%2A>です。 Visual Basic では、これは<xref:System.String>クラスの既定のプロパティです。 文字列<xref:System.Char>内の各オブジェクトには、次のようなコードを使用してアクセスできます。  
  
 [!code-csharp[System.String.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.chars/cs/chars1.cs#1)]
 [!code-vb[System.String.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.chars/vb/chars1.vb#1)]  
  
   
  
## Examples  
 次の例では、ルーチンでこのインデクサーを使用して文字列を検証する方法を示します。  
  
 [!code-cpp[Uri_IsHexDigit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Uri_IsHexDigit/CPP/uri_ishexdigit.cpp#1)]
 [!code-csharp[Uri_IsHexDigit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Uri_IsHexDigit/CS/uri_ishexdigit.cs#1)]
 [!code-vb[Uri_IsHexDigit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Uri_IsHexDigit/VB/uri_ishexdigit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> がこのオブジェクトの長さ以上か、0 未満です。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.GetEnumerator" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public string this[Range range] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Chars(valuetype System.Range)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Range)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Chars(range As Range) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ default[Range] { System::String ^ get(Range range); };" />
      <MemberSignature Language="F#" Value="member this.Chars(Range) : string" Usage="System.string.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Range" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="range">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="string.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この <see cref="T:System.String" />インスタンスへの参照を返します。</summary>
        <returns>この <see cref="T:System.String" /> のインスタンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 戻り値は、このインスタンスの独立したコピーではありません。これは、単に同じデータの別のビューです。 このインスタンス<xref:System.String.Copy%2A>と<xref:System.String.CopyTo%2A>同じ値を持つ別<xref:System.String>のオブジェクトを作成するには、メソッドまたはメソッドを使用します。  
  
 メソッドは<xref:System.String.Clone%2A> 、既存の文字列インスタンスを返すだけなので、直接呼び出す理由はほとんどありません。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Copy(System.String)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Compare">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した 2 つの <see cref="T:System.String" /> オブジェクトを比較し、それらの相対位置を並べ替え順序で示す整数を返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Compare%2A> メソッドのすべてのオーバーロードは、2 つの比較対照値の構文上の関係を示す 32 ビット符号付き整数を返します。  
  
|[値]|条件|  
|-----------|---------------|  
|0 より小さい値|最初の部分文字列は、並べ替え順序の2番目の部分文字列の前にあります。|  
|0|部分文字列は並べ替え順序で同じ位置で発生するか、`length` はゼロです。|  
|0 より大きい値|最初の部分文字列は、並べ替え順序において2番目の部分文字列の後に続きます。|  
  
> [!WARNING]
>  可能な限り、パラメーターを<xref:System.String.Compare%2A> <xref:System.StringComparison>含むメソッドのオーバーロードを呼び出す必要があります。 詳細については、「[文字列を使用するためのベスト プラクティス](~/docs/standard/base-types/best-practices-strings.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7">.NET Framework で文字列を使用するためのベスト プラクティス</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string -&gt; int" Usage="System.string.Compare (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">比較する最初の文字列。</param>
        <param name="strB">比較する 2 番目の文字列。</param>
        <summary>指定した 2 つの <see cref="T:System.String" /> オブジェクトを比較し、それらの相対位置を並べ替え順序で示す整数を返します。</summary>
        <returns>2 つの比較対照値の構文上の関係を示す 32 ビット符号付き整数。  
  
 <list type="table"><listheader><term> [値] 
 </term><description> 条件 
 </description></listheader><item><term> 0 より小さい値 
 </term><description>並べ替え順序において<paramref name="strA" /> は <paramref name="strB" /> の前になります。  
  
 </description></item><item><term> 0 
 </term><description><paramref name="strA" /> は並べ替え順序で、 <paramref name="strB" /> と同じ位置に出現します。  
  
 </description></item><item><term> 0 より大きい値 
 </term><description>並べ替え順序において <paramref name="strA" /> は <paramref name="strB" /> の後ろになります。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この比較では、現在のカルチャを使用して、大文字と小文字の規則や個々の文字のアルファベット順などのカルチャ固有の情報を取得します。 たとえば、カルチャは、文字の特定の組み合わせを1つの文字として扱うように指定したり、大文字と小文字の区別を特定の方法で比較したり、文字の並べ替え順序がの前または後の文字に依存するように指定したりすることができます。フォローします。  
  
 比較は、word の並べ替え規則を使用して実行されます。 単語、文字列、および序数の並べ替えの詳細について<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>は、「」を参照してください。  
  
> [!WARNING]
>  文字列を比較する場合は、 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>メソッドを呼び出す必要があります。そのためには、メソッドが使用する文字列比較の種類を明示的に指定する必要があります。 詳細については、「[文字列を使用するためのベスト プラクティス](~/docs/standard/base-types/best-practices-strings.md)」を参照してください。  
  
 一方または両方の比較対照値`null`をにすることができます。 定義上、空の文字列 ("") を含む任意の文字列は、null 参照より大きいと比較します。2つの null 参照が互いに等しいかどうかを比較します。  
  
 比較は、非等値が検出された場合、または両方の文字列が比較された場合に終了します。 ただし、2つの文字列が1つの文字列の末尾と等しい場合、もう一方の文字列の文字数が残っている場合は、残りの文字を含む文字列が大きいと見なされます。 戻り値は、最後に実行された比較の結果です。  
  
 カルチャ固有の大文字と小文字の規則によって比較が影響を受ける場合、予期しない結果が発生することがあります。 たとえば、トルコ語の場合、次の例では、トルコ語のファイルシステムでは、"file" の文字 "i" に言語の文字種の規則が使用されないため、間違った結果が生成されます。  
  
 [!code-cpp[System.String.Compare#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#10)]
 [!code-csharp[System.String.Compare#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#10)]
 [!code-vb[System.String.Compare#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#10)]  
  
 序数の比較を使用してパス名を "file" と比較します。 これを行うための正しいコードは次のとおりです。  
  
 [!code-cpp[System.String.Compare#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#11)]
 [!code-csharp[System.String.Compare#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#11)]
 [!code-vb[System.String.Compare#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#11)]  
  
   
  
## Examples  
 次の例では<xref:System.String.Compare%28System.String%2CSystem.String%29> 、メソッドを呼び出して、3つの文字列のセットを比較しています。  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 次の例では、 `ReverseStringComparer`クラスは、 <xref:System.String.Compare%2A>メソッドを使用して2つの文字列を評価する方法を示しています。  
  
 [!code-cpp[ArrayList#7](~/samples/snippets/cpp/VS_Snippets_CLR/ArrayList/CPP/ArrayListSample.cpp#7)]
 [!code-csharp[ArrayList#7](~/samples/snippets/csharp/VS_Snippets_CLR/ArrayList/CS/ArrayListSample.cs#7)]
 [!code-vb[ArrayList#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/ArrayList/VB/ArrayListSample.vb#7)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>文字セットには無視できる文字が含まれています。 メソッド<see cref="M:System.String.Compare(System.String,System.String)" />では、カルチャに依存した比較を実行するときに、このような文字は考慮されません。 たとえば、以降で[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]次のコードが実行されている場合、カルチャに依存した "animal" と "ani-正しくない" (ソフトハイフンまたは U + 00ad を使用) は、2つの文字列が等価であることを示します。  
  
[!code-csharp[System.String.Compare#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare21.cs#21)] [!code-vb[System.String.Compare#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare21.vb#21)] 
文字列比較で無視できる文字を認識するには<see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> 、メソッドを呼び出し、 `comparisonType`パラメーターに<see cref="F:System.Globalization.CompareOptions.Ordinal" />また<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />はのいずれかの値を指定します。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA">比較する最初の文字列。</param>
        <param name="strB">比較する 2 番目の文字列。</param>
        <param name="ignoreCase">比較時に大文字と小文字の区別を無視する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>指定した 2 つの <see cref="T:System.String" /> オブジェクトを比較し、並べ替え順序におけるそれらの相対位置を示す整数を返します。比較時に、大文字と小文字を区別するかどうかを設定できます。</summary>
        <returns>2 つの比較対照値の構文上の関係を示す 32 ビット符号付き整数。  
  
 <list type="table"><listheader><term> [値] 
 </term><description> 条件 
 </description></listheader><item><term> 0 より小さい値 
 </term><description>並べ替え順序において<paramref name="strA" /> は <paramref name="strB" /> の前になります。  
  
 </description></item><item><term> 0 
 </term><description><paramref name="strA" /> は並べ替え順序で、 <paramref name="strB" /> と同じ位置に出現します。  
  
 </description></item><item><term> 0 より大きい値 
 </term><description>並べ替え順序において <paramref name="strA" /> は <paramref name="strB" /> の後ろになります。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この比較では、現在のカルチャを使用して、大文字と小文字の規則や個々の文字のアルファベット順などのカルチャ固有の情報を取得します。 たとえば、カルチャは、文字の特定の組み合わせを1つの文字として扱うように指定したり、大文字と小文字の区別を特定の方法で比較したり、文字の並べ替え順序がの前または後の文字に依存するように指定したりすることができます。フォローします。  
  
 比較は、word の並べ替え規則を使用して実行されます。 単語、文字列、および序数の並べ替えの詳細について<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>は、「」を参照してください。  
  
> [!WARNING]
>  文字列を比較する場合は、 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>メソッドを呼び出す必要があります。そのためには、メソッドが使用する文字列比較の種類を明示的に指定する必要があります。 詳細については、「[文字列を使用するためのベスト プラクティス](~/docs/standard/base-types/best-practices-strings.md)」を参照してください。  
  
 一方または両方の比較対照値`null`をにすることができます。 定義上、空の文字列 ("") を含む任意の文字列は、null 参照より大きいと比較します。2つの null 参照が互いに等しいかどうかを比較します。  
  
 比較は、非等値が検出された場合、または両方の文字列が比較された場合に終了します。 ただし、2つの文字列が1つの文字列の末尾と等しい場合、もう一方の文字列の文字数が残っている場合は、残りの文字を含む文字列が大きいと見なされます。 戻り値は、最後に実行された比較の結果です。  
  
 カルチャ固有の大文字と小文字の規則によって比較が影響を受ける場合、予期しない結果が発生することがあります。 たとえば、トルコ語の場合、次の例では、トルコ語のファイルシステムでは、"file" の文字 "i" に言語の文字種の規則が使用されないため、間違った結果が生成されます。  
  
 [!code-cpp[System.String.Compare#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#12)]
 [!code-csharp[System.String.Compare#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#12)]
 [!code-vb[System.String.Compare#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#12)]  
  
 序数の比較を使用してパス名を "file" と比較します。 これを行うための正しいコードは次のとおりです。  
  
 [!code-cpp[System.String.Compare#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#13)]
 [!code-csharp[System.String.Compare#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#13)]
 [!code-vb[System.String.Compare#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#13)]  
  
   
  
## Examples  
 次の例では、 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Boolean%29>文字列を比較するとき<xref:System.String.ToUpper%2A>に<xref:System.String.ToLower%2A>またはを使用するのと同じメソッドであることを示しています。  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>文字セットには無視できる文字が含まれています。 メソッド<see cref="M:System.String.Compare(System.String,System.String,System.Boolean)" />では、カルチャに依存した比較を実行するときに、このような文字は考慮されません。 たとえば、以降で[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]次のコードが実行された場合、カルチャに依存し、大文字小文字を区別しない "animal" と "Ani-0" の比較 (ソフトハイフンまたは U + 00ad を使用) は、2つの文字列が等価であることを示します。  
  
[!code-csharp[System.String.Compare#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare22.cs#22)] [!code-vb[System.String.Compare#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare22.vb#22)] 
文字列比較で無視できる文字を認識するには<see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> 、メソッドを呼び出し、 <paramref name="comparisonType" />パラメーターに<see cref="F:System.Globalization.CompareOptions.Ordinal" />また<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />はのいずれかの値を指定します。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * StringComparison -&gt; int" Usage="System.string.Compare (strA, strB, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA">比較する最初の文字列。</param>
        <param name="strB">比較する 2 番目の文字列。</param>
        <param name="comparisonType">比較で使用する規則を指定する列挙値の 1 つ。</param>
        <summary>指定した規則を使用して、指定した 2 つの <see cref="T:System.String" /> オブジェクトを比較し、並べ替え順序におけるそれらの相対位置を示す整数を返します。</summary>
        <returns>2 つの比較対照値の構文上の関係を示す 32 ビット符号付き整数。  
  
 <list type="table"><listheader><term> [値] 
 </term><description> 条件 
 </description></listheader><item><term> 0 より小さい値 
 </term><description>並べ替え順序において<paramref name="strA" /> は <paramref name="strB" /> の前になります。  
  
 </description></item><item><term> 0 
 </term><description><paramref name="strA" /> は並べ替え順序で、 <paramref name="strB" /> と同じ位置にあります。  
  
 </description></item><item><term> 0 より大きい値 
 </term><description>並べ替え順序において <paramref name="strA" /> は <paramref name="strB" /> の後ろになります。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 パラメーター `comparisonType`は、比較で現在のカルチャまたはインバリアントカルチャを使用するか、比較対照値の大文字と小文字の区別を無視するか、または単語 (カルチャに依存する) または序数 (カルチャに依存しない) の並べ替え規則を使用するかを示します。  
  
 一方または両方の比較対照値`null`をにすることができます。 定義上、空の文字列 ("") を含む任意の文字列は、null 参照より大きいと比較します。2つの null 参照が互いに等しいかどうかを比較します。  
  
 比較は、非等値が検出された場合、または両方の文字列が比較された場合に終了します。 ただし、2つの文字列が1つの文字列の末尾と等しい場合、もう一方の文字列の文字数が残っていると、残りの文字を含む文字列は大きいと見なされます。 戻り値は、最後に実行された比較の結果です。  
  
 カルチャ固有の大文字と小文字の規則によって比較が影響を受ける場合、予期しない結果が発生することがあります。 たとえば、トルコ語の場合、次の例では、トルコ語のファイルシステムでは、"file" の文字 "i" に言語の文字種の規則が使用されないため、間違った結果が生成されます。  
  
 [!code-cpp[System.String.Compare#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#16)]
 [!code-csharp[System.String.Compare#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#16)]
 [!code-vb[System.String.Compare#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#16)]  
  
 序数の比較を使用してパス名を "file" と比較します。 これを行うための正しいコードは次のとおりです。  
  
 [!code-cpp[System.String.Compare#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#17)]
 [!code-csharp[System.String.Compare#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#17)]
 [!code-vb[System.String.Compare#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#17)]  
  
   
  
## Examples  
 次の例では、文字 "I" の3つのバージョンを比較しています。 結果は、カルチャの選択、case が無視されるかどうか、および序数に基づく比較が実行されるかどうかによって影響を受けます。  
  
 [!code-cpp[System.String.CompareCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.CompareCmp/cpp/cmpcmp.cpp#1)]
 [!code-csharp[System.String.CompareCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.CompareCmp/cs/cmpcmp.cs#1)]
 [!code-vb[System.String.CompareCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.CompareCmp/vb/cmpcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> が <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.StringComparison" /> がサポートされていません。</exception>
        <block subset="none" type="usage"><para>文字セットには無視できる文字が含まれています。 メソッド<see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" />では、カルチャに依存した比較を実行するときに、このような文字は考慮されません。 比較で無視できる文字を認識するには、 <see cref="F:System.StringComparison.Ordinal" /> <paramref name="comparisonType" />パラメーターに<see cref="F:System.StringComparison.OrdinalIgnoreCase" />またはの値を指定します。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="strA">比較する最初の文字列。</param>
        <param name="strB">比較する 2 番目の文字列。</param>
        <param name="ignoreCase">比較時に大文字と小文字の区別を無視する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="culture">カルチャ固有の比較情報を提供するオブジェクト。</param>
        <summary>指定した 2 つの <see cref="T:System.String" /> オブジェクトを比較し、並べ替え順序におけるそれらの相対位置を示す整数を返します。比較時に、大文字と小文字を区別するかどうかを指定し、比較に影響を及ぼすカルチャ固有の情報を使用します。</summary>
        <returns>2 つの比較対照値の構文上の関係を示す 32 ビット符号付き整数。  
  
 <list type="table"><listheader><term> [値] 
 </term><description> 条件 
 </description></listheader><item><term> 0 より小さい値 
 </term><description>並べ替え順序において<paramref name="strA" /> は <paramref name="strB" /> の前になります。  
  
 </description></item><item><term> 0 
 </term><description><paramref name="strA" /> は並べ替え順序で、 <paramref name="strB" /> と同じ位置に出現します。  
  
 </description></item><item><term> 0 より大きい値 
 </term><description>並べ替え順序において <paramref name="strA" /> は <paramref name="strB" /> の後ろになります。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この比較では`culture` 、パラメーターを使用して、大文字と小文字の規則や個々の文字のアルファベット順などのカルチャ固有の情報を取得します。 たとえば、カルチャは、文字の特定の組み合わせを1つの文字として扱うように指定したり、大文字と小文字の区別を特定の方法で比較したり、文字の並べ替え順序がの前または後の文字に依存するように指定したりすることができます。フォローします。  
  
 比較は、word の並べ替え規則を使用して実行されます。 単語、文字列、および序数の並べ替えの詳細について<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>は、「」を参照してください。  
  
 一方または両方の比較対照値`null`をにすることができます。 定義上、空の文字列 ("") を含む任意の文字列は、null 参照より大きいと比較します。2つの null 参照が互いに等しいかどうかを比較します。  
  
 比較は、非等値が検出された場合、または両方の文字列が比較された場合に終了します。 ただし、2つの文字列が1つの文字列の末尾と等しい場合、もう一方の文字列の文字数が残っている場合は、残りの文字を含む文字列が大きいと見なされます。 戻り値は、最後に実行された比較の結果です。  
  
 カルチャ固有の大文字と小文字の規則によって比較が影響を受ける場合、予期しない結果が発生することがあります。 たとえば、トルコ語の場合、次の例では、トルコ語のファイルシステムでは、"file" の文字 "i" に言語の文字種の規則が使用されないため、間違った結果が生成されます。  
  
 [!code-cpp[System.String.Compare#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#14)]
 [!code-csharp[System.String.Compare#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#14)]
 [!code-vb[System.String.Compare#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#14)]  
  
 序数の比較を使用してパス名を "file" と比較します。 これを行うための正しいコードは次のとおりです。  
  
 [!code-cpp[System.String.Compare#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#15)]
 [!code-csharp[System.String.Compare#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#15)]
 [!code-vb[System.String.Compare#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#15)]  
  
   
  
## Examples  
 次の例では、カルチャが比較に与える影響について説明します。 チェコ語-チェコ共和国カルチャでは、"ch" は "d" より大きい1文字です。 ただし、英語米国カルチャでは、"ch" は2つの文字で構成され、"c" は "d" よりも小さくなります。  
  
 [!code-cpp[string.comp4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.comp4/CPP/string.comp4.cpp#1)]
 [!code-csharp[string.comp4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.comp4/CS/string.comp4.cs#1)]
 [!code-vb[string.comp4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.comp4/VB/string.comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> は <see langword="null" />です。</exception>
        <block subset="none" type="usage"><para>文字セットには無視できる文字が含まれています。 メソッド<see cref="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />では、カルチャに依存した比較を実行するときに、このような文字は考慮されません。 たとえば、以降で[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]次のコードが実行されている場合、インバリアントカルチャを使用する "animal" と "Ani------------------" を使用した "animal" の比較では、2つの文字列が等価であることが示されます。  
  
[!code-csharp[System.String.Compare#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare23.cs#23)] [!code-vb[System.String.Compare#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare23.vb#23)] 
文字列比較で無視できる文字を認識するには<see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> 、メソッドを呼び出し、 <paramref name="options" />パラメーターに<see cref="F:System.Globalization.CompareOptions.Ordinal" />また<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />はのいずれかの値を指定します。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, strB, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="strA">比較する最初の文字列。</param>
        <param name="strB">比較する 2 番目の文字列。</param>
        <param name="culture">カルチャ固有の比較情報を提供するカルチャ。</param>
        <param name="options">比較の実行時に使用するオプション (大文字と小文字の違いや記号を無視するなど)。</param>
        <summary>指定した 2 つの <see cref="T:System.String" /> オブジェクトを比較し、2 つの文字列の互いのリレーションシップを並べ替え順序で示す整数を返します。比較時に、指定した比較オプションと、比較に影響を及ぼすカルチャ固有の情報を使用します。</summary>
        <returns><paramref name="strA" /> と <paramref name="strB" /> との構文上の関係を示す 32 ビット符号付き整数。次の表を参照してください。 
 <list type="table"><listheader><term> [値] 
 </term><description> 条件 
 </description></listheader><item><term> 0 より小さい値 
 </term><description>並べ替え順序において<paramref name="strA" /> は <paramref name="strB" /> の前になります。  
  
 </description></item><item><term> 0 
 </term><description><paramref name="strA" /> は並べ替え順序で、 <paramref name="strB" /> と同じ位置に出現します。  
  
 </description></item><item><term> 0 より大きい値 
 </term><description>並べ替え順序において <paramref name="strA" /> は <paramref name="strB" /> の後ろになります。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この比較では`culture` 、パラメーターを使用して、大文字と小文字の規則や個々の文字のアルファベット順など、カルチャ固有の情報を取得します。 たとえば、特定のカルチャでは、特定の文字の組み合わせを1つの文字として扱うように指定したり、大文字と小文字を特定の方法で比較したり、文字の並べ替え順序が文字によって異なることを指定したりすることができます。前または後に実行します。  
  
> [!CAUTION]
>  この<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>メソッドは、主に並べ替え操作または alphabetizing 操作で使用するために設計されています。 メソッド呼び出しの主な目的が、2つの文字列が等価であるかどうかを判断する場合 (つまり、メソッド呼び出しの目的が0の戻り値をテストする場合) は使用しないでください。 2つの文字列が等しいかどうかを<xref:System.String.Equals%2A>判断するには、メソッドを呼び出します。  
  
 比較は、 <xref:System.Globalization.CompareOptions>列挙体の1つ`options`以上のメンバーで構成されるパラメーターでさらに指定できます。 ただし、このメソッドの目的はカルチャに依存した文字列比較を実行することで<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>ある<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>ため、値と値は効果がありません。  
  
 いずれかまたは両方の`null`比較対照値をにすることができます。 定義上、を含む<xref:System.String.Empty?displayProperty=nameWithType>任意の文字列は、null 参照よりも大きいかどうかを比較し、2つの null 参照は互いに等しいかどうかを比較します。  
  
 比較は、非等値が検出された場合、または両方の文字列が比較された場合に終了します。 ただし、2つの文字列が1つの文字列の末尾と等しい場合、もう一方の文字列の文字数が残っていると、残りの文字を含む文字列は大きいと見なされます。  
  
   
  
## Examples  
 次の例では、2つの文字列を比較して、en-us カルチャの言語的な比較を使用しています。en-us カルチャでの言語的な大文字と小文字を区別する比較の使用序数による比較を使用します。 ここでは、3つの比較方法によって3つの異なる結果が生成される方法を示します。  
  
 [!code-cpp[System.String.Compare#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/example.cpp#1)]
 [!code-csharp[System.String.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/Example.cs#1)]
 [!code-vb[System.String.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> が <see cref="T:System.Globalization.CompareOptions" /> 値ではありません。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> は <see langword="null" />です。</exception>
        <block subset="none" type="usage"><para>文字セットには無視できる文字が含まれています。これらの文字は、言語またはカルチャに依存した比較を実行する際には考慮されません。 メソッド<see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />では、カルチャに依存した比較を実行するときに、このような文字は考慮されません。 比較で無視できる文字を認識するには、 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> <paramref name="options" />パラメーターに<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />またはの値を指定します。</para></block>
        <altmember cref="Overload:System.String.CompareOrdinal" />
        <altmember cref="Overload:System.String.CompareTo" />
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">比較で使用する最初の文字列。</param>
        <param name="indexA"><paramref name="strA" /> 内の部分文字列の位置。</param>
        <param name="strB">比較で使用する 2 番目の文字列。</param>
        <param name="indexB"><paramref name="strB" /> 内の部分文字列の位置。</param>
        <param name="length">比較する各部分文字列の最大文字数。</param>
        <summary>指定した 2 つの <see cref="T:System.String" /> オブジェクトの部分文字列を比較し、それらの相対位置を並べ替え順序で示す整数を返します。</summary>
        <returns>2 つの比較対照値の構文上の関係を示す 32 ビット符号付き整数。  
  
 <list type="table"><listheader><term> [値] 
 </term><description> 条件 
 </description></listheader><item><term> 0 より小さい値 
 </term><description> <paramref name="strA" /> 内の部分文字列は <paramref name="strB" /> 内の部分文字列に並べ替え順序において先行します。  
  
 </description></item><item><term> 0 
 </term><description> 部分文字列は並べ替え順序で同じ位置で発生するか、<paramref name="length" /> はゼロです。  
  
 </description></item><item><term> 0 より大きい値 
 </term><description> 並べ替え順序で、<paramref name="strA" /> 内の部分文字列は <paramref name="strB" /> 内の部分文字列の後ろになります。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 比較する部分文字列は、 `strA`の`indexA`との`strB`位置`indexB`で開始されます。 と`indexA` `strA` `strB`はどちらも0から始まります。つまり、との最初の文字は0の位置にあります。 `indexB` 最初の部分文字列の長さは、負の`strA` 1 を引い`indexA`た長さと同じです。 2番目の部分文字列の長さは、負`strB` `indexB`の正符号1の長さと同じです。  
  
 比較する文字数は、と`length`の2つの部分文字列の長さのうち、小さい方になります。 、 `indexA` 、`indexB`および`length`の各パラメーターは、負ではない必要があります。  
  
 この比較では、現在のカルチャを使用して、大文字と小文字の規則や個々の文字のアルファベット順などのカルチャ固有の情報を取得します。 たとえば、カルチャは、文字の特定の組み合わせを1つの文字として扱うように指定したり、大文字と小文字の区別を特定の方法で比較したり、文字の並べ替え順序がの前または後の文字に依存するように指定したりすることができます。フォローします。  
  
 比較は、word の並べ替え規則を使用して実行されます。 単語、文字列、および序数の並べ替えの詳細について<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>は、「」を参照してください。  
  
> [!WARNING]
>  文字列を比較する場合は、 <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29>メソッドを呼び出す必要があります。そのためには、メソッドが使用する文字列比較の種類を明示的に指定する必要があります。 詳細については、「[文字列を使用するためのベスト プラクティス](~/docs/standard/base-types/best-practices-strings.md)」を参照してください。  
  
 一方または両方の比較対照値`null`をにすることができます。 定義上、空の文字列 ("") を含む任意の文字列は、null 参照より大きいと比較します。2つの null 参照が互いに等しいかどうかを比較します。  
  
 比較は、非等値が検出された場合、または両方の部分文字列が比較された場合に終了します。 ただし、2つの文字列が1つの文字列の末尾と等しい場合、もう一方の文字列の文字数が残っている場合は、残りの文字を含む文字列が大きいと見なされます。 戻り値は、最後に実行された比較の結果です。  
  
 カルチャ固有の大文字と小文字の規則によって比較が影響を受ける場合、予期しない結果が発生することがあります。 たとえば、トルコ語の場合、次の例では、トルコ語のファイルシステムでは、"file" の文字 "i" に言語の文字種の規則が使用されないため、間違った結果が生成されます。  
  
 [!code-cpp[System.String.Compare#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#2)]
 [!code-csharp[System.String.Compare#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#2)]
 [!code-vb[System.String.Compare#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#2)]  
  
 序数の比較を使用してパス名を "file" と比較します。 これを行うための正しいコードは次のとおりです。  
  
 [!code-cpp[System.String.Compare#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#3)]
 [!code-csharp[System.String.Compare#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#3)]
 [!code-vb[System.String.Compare#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#3)]  
  
   
  
## Examples  
 次の例では、2つの部分文字列を比較します。  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indexA" /> が <paramref name="strA" />.<see cref="P:System.String.Length" /> より大きくなっています。  
  
または 
 <paramref name="indexB" /> が <paramref name="strB" />.<see cref="P:System.String.Length" /> より大きくなっています。  
  
- または - 
 <paramref name="indexA" />、 <paramref name="indexB" />、または <paramref name="length" /> が負の値です。  
  
または 
<paramref name="indexA" /> または <paramref name="indexB" /> のいずれかが <see langword="null" /> であり、<paramref name="length" /> が 0 より大きいです。</exception>
        <block subset="none" type="usage"><para>文字セットには無視できる文字が含まれています。 この<see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" />メソッドでは、言語的な比較やカルチャに依存した比較を実行するときに、これらの文字は考慮されません。 比較で無視できる文字を認識するには<see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> 、メソッドを呼び出し、 <paramref name="comparisonType" />パラメーター <see cref="F:System.Globalization.CompareOptions.Ordinal" />に<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />またはの値を指定します。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="strA">比較で使用する最初の文字列。</param>
        <param name="indexA"><paramref name="strA" /> 内の部分文字列の位置。</param>
        <param name="strB">比較で使用する 2 番目の文字列。</param>
        <param name="indexB"><paramref name="strB" /> 内の部分文字列の位置。</param>
        <param name="length">比較する各部分文字列の最大文字数。</param>
        <param name="ignoreCase">比較時に大文字と小文字の区別を無視する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>指定した 2 つの <see cref="T:System.String" /> オブジェクトの部分文字列を比較し、並べ替え順序におけるそれらの相対位置を示す整数を返します。比較時に、大文字と小文字を区別するかどうかを設定できます。</summary>
        <returns>2 つの比較対照値の構文上の関係を示す 32 ビット符号付き整数。  
  
 <list type="table"><listheader><term> [値] 
 </term><description> 条件 
 </description></listheader><item><term> 0 より小さい値 
 </term><description> <paramref name="strA" /> 内の部分文字列は <paramref name="strB" /> 内の部分文字列に並べ替え順序において先行します。  
  
 </description></item><item><term> 0 
 </term><description> 部分文字列は並べ替え順序で同じ位置で発生するか、<paramref name="length" /> はゼロです。  
  
 </description></item><item><term> 0 より大きい値 
 </term><description> 並べ替え順序で、<paramref name="strA" /> 内の部分文字列は <paramref name="strB" /> 内の部分文字列の後ろになります。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `strA` `indexA`とでの開始位置を比較する部分文字列。`strB` `indexB` と`indexA` `strA` `strB`はどちらも0から始まります。つまり、との最初の文字は0の位置にあります。 `indexB` 最初の部分文字列の長さは、負の`strA` 1 を引い`indexA`た長さと同じです。 2番目の部分文字列の長さは、負`strB` `indexB`の正符号1の長さと同じです。  
  
 比較する文字数は、と`length`の2つの部分文字列の長さのうち、小さい方になります。 、 `indexA` 、`indexB`および`length`の各パラメーターは、負ではない必要があります。  
  
 この比較では、現在のカルチャを使用して、大文字と小文字の規則や個々の文字のアルファベット順などのカルチャ固有の情報を取得します。 たとえば、カルチャは、文字の特定の組み合わせを1つの文字として扱うように指定したり、大文字と小文字の区別を特定の方法で比較したり、文字の並べ替え順序がの前または後の文字に依存するように指定したりすることができます。フォローします。  
  
 比較は、word の並べ替え規則を使用して実行されます。 単語、文字列、および序数の並べ替えの詳細について<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>は、「」を参照してください。  
  
> [!WARNING]
>  文字列を比較する場合は、 <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29>メソッドを呼び出す必要があります。そのためには、メソッドが使用する文字列比較の種類を明示的に指定する必要があります。 詳細については、「[文字列を使用するためのベスト プラクティス](~/docs/standard/base-types/best-practices-strings.md)」を参照してください。  
  
 一方または両方の比較対照値`null`をにすることができます。 定義上、空の文字列 ("") を含む任意の文字列は、null 参照より大きいと比較します。2つの null 参照が互いに等しいかどうかを比較します。  
  
 比較は、非等値が検出された場合、または両方の部分文字列が比較された場合に終了します。 ただし、2つの文字列が1つの文字列の末尾と等しい場合、もう一方の文字列の文字数が残っている場合は、残りの文字を含む文字列が大きいと見なされます。 戻り値は、最後に実行された比較の結果です。  
  
 カルチャ固有の大文字と小文字の規則によって比較が影響を受ける場合、予期しない結果が発生することがあります。 たとえば、トルコ語の場合、次の例では、トルコ語のファイルシステムでは、"file" の文字 "i" に言語の文字種の規則が使用されないため、間違った結果が生成されます。  
  
 [!code-cpp[System.String.Compare#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#4)]
 [!code-csharp[System.String.Compare#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#4)]
 [!code-vb[System.String.Compare#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#4)]  
  
 パス名は、不変の方法で比較する必要があります。 これを行うための正しいコードは次のとおりです。  
  
 [!code-cpp[System.String.Compare#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#5)]
 [!code-csharp[System.String.Compare#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#5)]
 [!code-vb[System.String.Compare#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#5)]  
  
   
  
## Examples  
 次の例では、大文字と小文字が異なる2つの部分文字列の2つの比較を実行します。 最初の比較では case が無視され、2番目の比較では case が考慮されます。  
  
 [!code-cpp[string.compare4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare4/CPP/comp4.cpp#1)]
 [!code-csharp[string.compare4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare4/CS/comp4.cs#1)]
 [!code-vb[string.compare4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare4/VB/comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indexA" /> が <paramref name="strA" />.<see cref="P:System.String.Length" /> より大きくなっています。  
  
- または - 
 <paramref name="indexB" /> が <paramref name="strB" />.<see cref="P:System.String.Length" /> より大きくなっています。  
  
- または - 
 <paramref name="indexA" />、 <paramref name="indexB" />、または <paramref name="length" /> が負の値です。  
  
- または - 
<paramref name="indexA" /> または <paramref name="indexB" /> のいずれかが <see langword="null" /> であり、<paramref name="length" /> が 0 より大きいです。</exception>
        <block subset="none" type="usage"><para>文字セットには無視できる文字が含まれています。 この<see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" />メソッドでは、言語的な比較やカルチャに依存した比較を実行するときに、これらの文字は考慮されません。 比較で無視できる文字を認識するには<see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> 、メソッドを呼び出し、 <paramref name="comparisonType" />パラメーター <see cref="F:System.Globalization.CompareOptions.Ordinal" />に<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />またはの値を指定します。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * StringComparison -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="5" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA">比較で使用する最初の文字列。</param>
        <param name="indexA"><paramref name="strA" /> 内の部分文字列の位置。</param>
        <param name="strB">比較で使用する 2 番目の文字列。</param>
        <param name="indexB"><paramref name="strB" /> 内の部分文字列の位置。</param>
        <param name="length">比較する各部分文字列の最大文字数。</param>
        <param name="comparisonType">比較で使用する規則を指定する列挙値の 1 つ。</param>
        <summary>指定した規則を使用して、指定した 2 つの <see cref="T:System.String" /> オブジェクトの部分文字列を比較し、並べ替え順序におけるそれらの相対位置を示す整数を返します。</summary>
        <returns>2 つの比較対照値の構文上の関係を示す 32 ビット符号付き整数。  
  
 <list type="table"><listheader><term> [値] 
 </term><description> 条件 
 </description></listheader><item><term> 0 より小さい値 
 </term><description> <paramref name="strA" /> 内の部分文字列は <paramref name="strB" /> 内の部分文字列に並べ替え順序において先行します。  
  
 </description></item><item><term> 0 
 </term><description> 部分文字列は並べ替え順序で同じ位置に出現するか、<paramref name="length" /> パラメーターはゼロです。  
  
 </description></item><item><term> 0 より大きい値 
 </term><description> 並べ替え順序で、<paramref name="strA" /> 内の部分文字列は <paramref name="strB" /> 内の部分文字列の後ろになります。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 比較する部分文字列は、 `strA`の`indexA`との`strB`位置`indexB`で開始されます。 と`indexA` `strA` `strB`はどちらも0から始まります。つまり、との最初の文字は0から始まり、位置は0になります。 `indexB` 最初の部分文字列の長さは、負の`strA` 1 を引い`indexA`た長さと同じです。 2番目の部分文字列の長さは、負`strB` `indexB`の正符号1の長さと同じです。  
  
 比較する文字数は、と`length`の2つの部分文字列の長さのうち、小さい方になります。 、 `indexA` 、`indexB`および`length`の各パラメーターは、負ではない必要があります。  
  
 パラメーター `comparisonType`は、比較で現在のカルチャまたはインバリアントカルチャを使用するか、比較対照値の大文字と小文字の区別を無視するか、または単語 (カルチャに依存する) または序数 (カルチャに依存しない) の並べ替え規則を使用するかを示します。  
  
 一方または両方の比較対照値`null`をにすることができます。 定義上、空の文字列 ("") を含む任意の文字列は、null 参照より大きいと比較します。2つの null 参照が互いに等しいかどうかを比較します。  
  
 比較は、非等値が検出された場合、または両方の部分文字列が比較された場合に終了します。 ただし、2つの文字列が1つの文字列の末尾と等しい場合、もう一方の文字列の文字数が残っていると、残りの文字を含む文字列は大きいと見なされます。 戻り値は、最後に実行された比較の結果です。  
  
 カルチャ固有の大文字と小文字の規則によって比較が影響を受ける場合、予期しない結果が発生することがあります。 たとえば、トルコ語の場合、次の例では、トルコ語のファイルシステムでは、"file" の文字 "i" に言語の文字種の規則が使用されないため、間違った結果が生成されます。  
  
 [!code-cpp[System.String.Compare#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#8)]
 [!code-csharp[System.String.Compare#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#8)]
 [!code-vb[System.String.Compare#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#8)]  
  
 序数の比較を使用してパス名を "file" と比較します。 これを行うための正しいコードは次のとおりです。  
  
 [!code-cpp[System.String.Compare#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#9)]
 [!code-csharp[System.String.Compare#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#9)]
 [!code-vb[System.String.Compare#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#9)]  
  
   
  
## Examples  
 次の例では、2つの部分文字列を比較します。  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indexA" /> が <paramref name="strA" />.<see cref="P:System.String.Length" /> より大きくなっています。  
  
- または - 
 <paramref name="indexB" /> が <paramref name="strB" />.<see cref="P:System.String.Length" /> より大きくなっています。  
  
- または - 
 <paramref name="indexA" />、 <paramref name="indexB" />、または <paramref name="length" /> が負の値です。  
  
または 
<paramref name="indexA" /> または <paramref name="indexB" /> のいずれかが <see langword="null" /> であり、<paramref name="length" /> が 0 より大きいです。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> が <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <block subset="none" type="usage"><para>文字セットには無視できる文字が含まれています。 この<see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />メソッドでは、言語的な比較やカルチャに依存した比較を実行するときに、これらの文字は考慮されません。 比較で無視できる文字を認識するには、 <see cref="F:System.StringComparison.Ordinal" /> <paramref name="comparisonType" />パラメーターに<see cref="F:System.StringComparison.OrdinalIgnoreCase" />またはの値を指定します。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="strA">比較で使用する最初の文字列。</param>
        <param name="indexA"><paramref name="strA" /> 内の部分文字列の位置。</param>
        <param name="strB">比較で使用する 2 番目の文字列。</param>
        <param name="indexB"><paramref name="strB" /> 内の部分文字列の位置。</param>
        <param name="length">比較する各部分文字列の最大文字数。</param>
        <param name="ignoreCase">比較時に大文字と小文字の区別を無視する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="culture">カルチャ固有の比較情報を提供するオブジェクト。</param>
        <summary>指定した 2 つの <see cref="T:System.String" /> オブジェクトの部分文字列を比較し、並べ替え順序におけるそれらの相対位置を示す整数を返します。比較時に、大文字と小文字を区別するかどうかを指定し、比較に影響を及ぼすカルチャ固有の情報を使用します。</summary>
        <returns>2 つの比較対照値の構文上の関係を示す整数。  
  
 <list type="table"><listheader><term> [値] 
 </term><description> 条件 
 </description></listheader><item><term> 0 より小さい値 
 </term><description> <paramref name="strA" /> 内の部分文字列は <paramref name="strB" /> 内の部分文字列に並べ替え順序において先行します。  
  
 </description></item><item><term> 0 
 </term><description> 部分文字列は並べ替え順序で同じ位置で発生するか、<paramref name="length" /> はゼロです。  
  
 </description></item><item><term> 0 より大きい値 
 </term><description> 並べ替え順序で、<paramref name="strA" /> 内の部分文字列は <paramref name="strB" /> 内の部分文字列の後ろになります。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `strA` `indexA`とでの開始位置を比較する部分文字列。`strB` `indexB` と`indexA` `strA` `strB`はどちらも0から始まります。つまり、との最初の文字は0から始まり、位置は0になります。 `indexB` 最初の部分文字列の長さは、負の`strA` 1 を引い`indexA`た長さと同じです。 2番目の部分文字列の長さは、負`strB` `indexB`の正符号1の長さと同じです。  
  
 比較する文字数は、と`length`の2つの部分文字列の長さのうち、小さい方になります。 、 `indexA` 、`indexB`および`length`の各パラメーターは、負ではない必要があります。  
  
 この比較では`culture` 、パラメーターを使用して、大文字と小文字の規則や個々の文字のアルファベット順などのカルチャ固有の情報を取得します。 たとえば、カルチャは、文字の特定の組み合わせを1つの文字として扱うように指定したり、大文字と小文字の区別を特定の方法で比較したり、文字の並べ替え順序がの前または後の文字に依存するように指定したりすることができます。フォローします。  
  
 比較は、word の並べ替え規則を使用して実行されます。 単語、文字列、および序数の並べ替えの詳細について<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>は、「」を参照してください。  
  
 一方または両方の比較対照値`null`をにすることができます。 定義上、空の文字列 ("") を含む任意の文字列は、null 参照より大きいと比較します。2つの null 参照が互いに等しいかどうかを比較します。  
  
 比較は、非等値が検出された場合、または両方の部分文字列が比較された場合に終了します。 ただし、2つの文字列が1つの文字列の末尾と等しい場合、もう一方の文字列の文字数が残っている場合は、残りの文字を含む文字列が大きいと見なされます。 戻り値は、最後に実行された比較の結果です。  
  
 カルチャ固有の大文字と小文字の規則によって比較が影響を受ける場合、予期しない結果が発生することがあります。 たとえば、トルコ語の場合、次の例では、トルコ語のファイルシステムでは、"file" の文字 "i" に言語の文字種の規則が使用されないため、間違った結果が生成されます。  
  
 [!code-cpp[System.String.Compare#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#6)]
 [!code-csharp[System.String.Compare#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#6)]
 [!code-vb[System.String.Compare#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#6)]  
  
 序数の比較を使用してパス名を "file" と比較します。 これを行うための正しいコードは次のとおりです。  
  
 [!code-cpp[System.String.Compare#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#7)]
 [!code-csharp[System.String.Compare#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#7)]
 [!code-vb[System.String.Compare#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#7)]  
  
   
  
## Examples  
 次の例では、異なるカルチャを使用して2つの部分文字列を比較し、部分文字列の大文字と小文字を区別します。 カルチャの選択は、文字 "I" の比較方法に影響します。  
  
 [!code-cpp[string.compare5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare5/CPP/comp5.cpp#1)]
 [!code-csharp[string.compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare5/CS/comp5.cs#1)]
 [!code-vb[string.compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare5/VB/comp5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indexA" /> が <paramref name="strA" />.<see cref="P:System.String.Length" /> より大きくなっています。  
  
または 
 <paramref name="indexB" /> が <paramref name="strB" />.<see cref="P:System.String.Length" /> より大きくなっています。  
  
または 
 <paramref name="indexA" />、 <paramref name="indexB" />、または <paramref name="length" /> が負の値です。  
  
- または - 
<paramref name="strA" /> または <paramref name="strB" /> のいずれかが <see langword="null" /> であり、<paramref name="length" /> が 0 を超えています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> は <see langword="null" />です。</exception>
        <block subset="none" type="usage"><para>文字セットには無視できる文字が含まれています。 この<see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" />メソッドでは、言語的な比較やカルチャに依存した比較を実行するときに、これらの文字は考慮されません。 比較で無視できる文字を認識するには<see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> 、メソッドを呼び出し、 <paramref name="options" />パラメーター <see cref="F:System.Globalization.CompareOptions.Ordinal" />に<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />またはの値を指定します。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="strA">比較で使用する最初の文字列。</param>
        <param name="indexA"><paramref name="strA" /> 内の部分文字列の開始位置。</param>
        <param name="strB">比較で使用する 2 番目の文字列。</param>
        <param name="indexB"><paramref name="strB" /> 内の部分文字列の開始位置。</param>
        <param name="length">比較する各部分文字列の最大文字数。</param>
        <param name="culture">カルチャ固有の比較情報を提供するオブジェクト。</param>
        <param name="options">比較の実行時に使用するオプション (大文字と小文字の違いや記号を無視するなど)。</param>
        <summary>指定した 2 つの <see cref="T:System.String" /> オブジェクトの部分文字列を比較し、2 つの部分文字列の互いのリレーションシップを並べ替え順序で示す整数を返します。比較時に、指定した比較オプションと、比較に影響を及ぼすカルチャ固有の情報を使用します。</summary>
        <returns>2 つの部分文字列の構文上の関係を示す整数。次の表を参照してください。  
  
 <list type="table"><listheader><term> [値] 
 </term><description> 条件 
 </description></listheader><item><term> 0 より小さい値 
 </term><description> <paramref name="strA" /> 内の部分文字列は <paramref name="strB" /> 内の部分文字列に並べ替え順序において先行します。  
  
 </description></item><item><term> 0 
 </term><description> 部分文字列は並べ替え順序で同じ位置で発生するか、<paramref name="length" /> はゼロです。  
  
 </description></item><item><term> 0 より大きい値 
 </term><description> 並べ替え順序で、<paramref name="strA" /> 内の部分文字列は <paramref name="strB" /> 内の部分文字列の後ろになります。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 位置`strA` `strB`と位置の`indexB`両方で開始される比較対象の部分文字列。 `indexA` 最初の`strA`部分文字列の長さは、からを引い`indexA`た長さです。 2番目の部分文字列の長さは、 `strB`から`indexB`を引いた長さです。  
  
 比較する文字数は、と`length`の2つの部分文字列の長さのうち、小さい方になります。 、 `indexA` 、`indexB`および`length`の各パラメーターは、負ではない必要があります。  
  
 この比較では`culture` 、パラメーターを使用して、大文字と小文字の規則や個々の文字のアルファベット順など、カルチャ固有の情報を取得します。 たとえば、特定のカルチャでは、特定の文字の組み合わせを1つの文字として扱うように指定したり、大文字と小文字を特定の方法で比較したり、文字の並べ替え順序が文字によって異なることを指定したりすることができます。前または後に実行します。  
  
> [!CAUTION]
>  この<xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>メソッドは、主に並べ替え操作または alphabetizing 操作で使用するために設計されています。 メソッド呼び出しの主な目的が、2つの部分文字列が等しいかどうかを判断するためには使用しないでください (つまり、メソッド呼び出しの目的が0の戻り値をテストする場合)。 2つの文字列が等しいかどうかを<xref:System.String.Equals%2A>判断するには、メソッドを呼び出します。  
  
 と`null` `strA` の一方または両方をにすることができます。`strB` 定義上、を含む<xref:System.String.Empty?displayProperty=nameWithType>任意の文字列は、null 参照よりも大きいかどうかを比較し、2つの null 参照は互いに等しいかどうかを比較します。  
  
 比較は、 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>列挙体の1つ`options`以上のメンバーで構成されるパラメーターでさらに指定できます。 ただし、このメソッドの目的はカルチャに依存した文字列比較を実行することで<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>ある<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>ため、値と値は効果がありません。  
  
 比較は、非等値が検出された場合、または両方の部分文字列が比較された場合に終了します。 ただし、2つの文字列が1つの文字列の末尾と等しい場合、もう一方の文字列の文字数が残っていると、残りの文字を含む文字列は大きいと見なされます。 戻り値は、最後に実行された比較の結果です。  
  
   
  
## Examples  
 次の例では<xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> 、メソッドを使用して、2人の人の姓を比較します。 次に、アルファベット順に一覧表示します。  
  
 [!code-csharp[System.String.Compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare5/cs/Example.cs#1)]
 [!code-vb[System.String.Compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare5/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> が <see cref="T:System.Globalization.CompareOptions" /> 値ではありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indexA" /> は <paramref name="strA" /><see langword=".Length" /> より大きいです。  
  
- または - 
 <paramref name="indexB" /> は <paramref name="strB" /><see langword=".Length" /> より大きいです。  
  
または 
 <paramref name="indexA" />、 <paramref name="indexB" />、または <paramref name="length" /> が負の値です。  
  
- または - 
<paramref name="strA" /> または <paramref name="strB" /> のいずれかが <see langword="null" /> であり、<paramref name="length" /> が 0 を超えています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> は <see langword="null" />です。</exception>
        <block subset="none" type="usage"><para>文字セットには無視できる文字が含まれています。 この<see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />メソッドでは、言語的な比較やカルチャに依存した比較を実行するときに、これらの文字は考慮されません。 比較で無視できる文字を認識するには、 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> <paramref name="options" />パラメーターに<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />またはの値を指定します。</para></block>
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareOrdinal">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>それぞれの文字列の対応する <see cref="T:System.String" /> オブジェクトの数値を評価することで、2 つの <see cref="T:System.Char" /> を比較します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * string -&gt; int" Usage="System.string.CompareOrdinal (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">比較する最初の文字列。</param>
        <param name="strB">比較する 2 番目の文字列。</param>
        <summary>それぞれの文字列の対応する <see cref="T:System.String" /> オブジェクトの数値を評価することで、指定した 2 つの <see cref="T:System.Char" /> を比較します。</summary>
        <returns>2 つの比較対照値の構文上の関係を示す整数。  
  
 <list type="table"><listheader><term> [値] 
 </term><description> 条件 
 </description></listheader><item><term> 0 より小さい値 
 </term><description><paramref name="strA" /> は <paramref name="strB" /> より小さい値です。  
  
 </description></item><item><term> 0 
 </term><description><paramref name="strA" /> と <paramref name="strB" /> が等しい。  
  
 </description></item><item><term> 0 より大きい値 
 </term><description><paramref name="strA" /> が <paramref name="strB" /> より大きくなっています。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、序数の並べ替え規則を使用して、大文字と小文字を区別した比較を実行します。 単語、文字列、および序数の並べ替えの詳細について<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>は、「」を参照してください。 序数の並べ替え規則を使用して大文字と小文字を<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>区別しない`comparisonType`比較を実行<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>するには、引数をに設定してメソッドを呼び出します。  
  
 は<xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29>静的`strB` `null`メソッドであるため、をにすることができます。`strA` 両方の値が`null`の場合、メソッドは 0 (ゼロ) を返します`strA` 。 `strB`これは、とが等しいことを示します。 値の1つだけが`null`の場合、メソッドは null 以外の値が大きいと見なされます。  
  
   
  
## Examples  
 次の例では、大文字と小文字が異なる2つの文字列を比較して、序数の比較を実行します。  
  
 [!code-cpp[string.compareordinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compareordinal/CPP/comp0.cpp#1)]
 [!code-csharp[string.compareordinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compareordinal/CS/comp0.cs#1)]
 [!code-vb[string.compareordinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compareordinal/VB/comp0.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * int * string * int * int -&gt; int" Usage="System.string.CompareOrdinal (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">比較で使用する最初の文字列。</param>
        <param name="indexA"><paramref name="strA" /> 内の部分文字列の開始インデックス。</param>
        <param name="strB">比較で使用する 2 番目の文字列。</param>
        <param name="indexB"><paramref name="strB" /> 内の部分文字列の開始インデックス。</param>
        <param name="length">比較する各部分文字列の最大文字数。</param>
        <summary>それぞれの部分文字列の対応する <see cref="T:System.Char" /> オブジェクトの数値を評価することにより、指定した 2 つの <see cref="T:System.String" /> オブジェクトの部分文字列を比較します。</summary>
        <returns>2 つの比較対照値の構文上の関係を示す 32 ビット符号付き整数。  
  
 <list type="table"><listheader><term> [値] 
 </term><description> 条件 
 </description></listheader><item><term> 0 より小さい値 
 </term><description> <paramref name="strA" /> 内の部分文字列が <paramref name="strB" /> 内の部分文字列より小さいです。  
  
 </description></item><item><term> 0 
 </term><description> これらの部分文字列が等しいか、または <paramref name="length" /> が 0 です。  
  
 </description></item><item><term> 0 より大きい値 
 </term><description> <paramref name="strA" /> 内の部分文字列が <paramref name="strB" /> 内の部分文字列より大きいです。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 、 `indexA` 、`indexB`および`length`の各パラメーターは、負ではない必要があります。  
  
 比較する文字数`strA`は、小さい方の長さ、の長さ`indexA` `strB` `indexB`、および`length`の長さよりも短くなります。  
  
 このメソッドは、序数の並べ替え規則を使用して、大文字と小文字を区別した比較を実行します。 単語、文字列、および序数の並べ替えの詳細について<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>は、「」を参照してください。 序数の並べ替え規則を使用して大文字と小文字を<xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29>区別しない`comparisonType`比較を実行<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>するには、引数をに設定してメソッドを呼び出します。  
  
 は<xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29>静的`strB` `null`メソッドであるため、をにすることができます。`strA` 両方の値が`null`の場合、メソッドは 0 (ゼロ) を返します`strA` 。 `strB`これは、とが等しいことを示します。 値の1つだけが`null`の場合、メソッドは null 以外の値が大きいと見なされます。  
  
   
  
## Examples  
 次の例では<xref:System.String.CompareOrdinal%2A> 、 <xref:System.String.Compare%2A>とは異なる並べ替え順序を使用しています。  
  
 [!code-cpp[StringCompareOrdinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareOrdinal/CPP/stringcompareordinal.cpp#1)]
 [!code-csharp[StringCompareOrdinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareOrdinal/CS/stringcompareordinal.cs#1)]
 [!code-vb[StringCompareOrdinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareOrdinal/VB/stringcompareordinal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="strA" /> は <see langword="null" /> でありません。また <paramref name="indexA" /> が <paramref name="strA" />.<see cref="P:System.String.Length" /> を超えています。  
  
- または - 
 <paramref name="strB" /> は <see langword="null" /> でありません。また <paramref name="indexB" /> が <paramref name="strB" />.<see cref="P:System.String.Length" />を超えています。  
  
- または - 
 <paramref name="indexA" />、<paramref name="indexB" />、または <paramref name="length" /> が負の値です。</exception>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このインスタンスと指定したオブジェクトまたは <see cref="T:System.String" /> とを比較し、並べ替え順序において、このインスタンスの位置が指定したオブジェクトまたは <see cref="T:System.String" /> の前、後ろ、または同じのいずれであるかを示す整数を返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.CompareTo%2A>メソッドの両方のオーバーロードは、カルチャに依存し、大文字と小文字を区別する比較を実行します。 このメソッドを使用して、カルチャを認識しないまたは序数による比較を実行することはできません。 コードをわかりやすくするために、 <xref:System.String.CompareTo%2A>メソッドを使用せずに<xref:System.String.Compare%2A>メソッドを呼び出すことをお勧めします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="string.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.String" /> に評価されるオブジェクト。</param>
        <summary>このインスタンスと指定した <see cref="T:System.Object" /> とを比較し、並べ替え順序において、このインスタンスの位置が指定した <see cref="T:System.Object" /> の前、後ろ、または同じのいずれであるかを示します。</summary>
        <returns>並べ替え順序において、このインスタンスの位置が <paramref name="value" /> パラメーターよりも前、後ろ、または同じのいずれであるかを示す 32 ビット符号付き整数。  
  
 <list type="table"><listheader><term> [値] 
 </term><description> 条件 
 </description></listheader><item><term> 0 より小さい値 
 </term><description> このインスタンスの位置が <paramref name="value" /> よりも前です。  
  
 </description></item><item><term> 0 
 </term><description> このインスタンスの位置が、並べ替え順序において <paramref name="value" /> と同じです。  
  
 </description></item><item><term> 0 より大きい値 
 </term><description> このインスタンスの位置が <paramref name="value" /> よりも後ろです。  
  
- または - 
 <paramref name="value" /> が <see langword="null" /> です。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value`<xref:System.String>はオブジェクトである必要があります。  
  
> [!CAUTION]
>  この<xref:System.String.CompareTo%2A>メソッドは、主に並べ替え操作または alphabetizing 操作で使用するように設計されています。 2つの文字列が等価かどうかを判断するために、メソッド呼び出しの主な目的がである場合は、使用しないでください。 2つの文字列が等しいかどうかを<xref:System.String.Equals%2A>判断するには、メソッドを呼び出します。  
  
 このメソッドは、現在のカルチャを使用して、単語 (大文字と小文字を区別し、カルチャに依存する) 比較を実行します。 単語、文字列、および序数の並べ替えの詳細について<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>は、「」を参照してください。  
  
 このメソッドの動作の詳細については、 <xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType>メソッドの「解説」を参照してください。  
  
   
  
## Examples  
 次の例では<xref:System.String.CompareTo%2A> 、メソッドを<xref:System.Object>と共に使用します。 <xref:System.String>インスタンスをオブジェクトと`TestClass`比較しようとするため、メソッドはをスロー <xref:System.ArgumentException>します。  
  
 [!code-cpp[ExToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ExToString/CPP/extostring.cpp#1)]
 [!code-csharp[ExToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ExToString/CS/extostring.cs#1)]
 [!code-vb[ExToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ExToString/VB/extostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> が <see cref="T:System.String" /> ではありません。</exception>
        <block subset="none" type="usage"><para>文字セットには無視できる文字が含まれています。 メソッド<see cref="M:System.String.CompareTo(System.Object)" />では、カルチャに依存した比較を実行するときに、このような文字は考慮されません。 たとえば、次のコードが以降で[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]実行されている場合、"animal" を "ani-正しくない" (ソフトハイフンまたは U + 00ad を使用) と比較すると、2つの文字列が等価であることが示されます。  
  
[!code-csharp[System.String.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto1.cs#1)] [!code-vb[System.String.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto1.vb#1)] 
文字列比較で無視できる文字を認識するには<see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> 、メソッドを呼び出します。</para></block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::String ^ strB);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : string -&gt; int&#xA;override this.CompareTo : string -&gt; int" Usage="string.CompareTo strB" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strB">このインスタンスと比較する文字列。</param>
        <summary>このインスタンスと指定した <see cref="T:System.String" /> オブジェクトとを比較し、並べ替え順序において、このインスタンスの位置が指定した文字列の前、後ろ、または同じのいずれであるかを示します。</summary>
        <returns>並べ替え順序において、このインスタンスの位置が <paramref name="strB" /> パラメーターよりも前、後ろ、または同じのいずれであるかを示す 32 ビット符号付き整数。  
  
 <list type="table"><listheader><term> [値] 
 </term><description> 条件 
 </description></listheader><item><term> 0 より小さい値 
 </term><description> このインスタンスの位置が <paramref name="strB" /> よりも前です。  
  
 </description></item><item><term> 0 
 </term><description> このインスタンスの位置が、並べ替え順序において <paramref name="strB" /> と同じです。  
  
 </description></item><item><term> 0 より大きい値 
 </term><description> このインスタンスの位置が <paramref name="strB" /> よりも後ろです。  
  
または 
 <paramref name="strB" /> は <see langword="null" />です。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、現在のカルチャを使用して、単語 (大文字と小文字を区別し、カルチャに依存する) 比較を実行します。 単語、文字列、および序数の並べ替えの詳細について<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>は、「」を参照してください。  
  
> [!CAUTION]
>  この<xref:System.String.CompareTo%2A>メソッドは、主に並べ替え操作または alphabetizing 操作で使用するように設計されています。 2つの文字列が等価かどうかを判断するために、メソッド呼び出しの主な目的がである場合は、使用しないでください。 2つの文字列が等しいかどうかを<xref:System.String.Equals%2A>判断するには、メソッドを呼び出します。  
  
 このメソッドの動作の詳細については、 <xref:System.String.Compare%28System.String%2CSystem.String%29>メソッドの「解説」を参照してください。  
  
 このメソッドは、 <xref:System.IComparable%601?displayProperty=nameWithType>インターフェイスを実装し、 <xref:System.String.CompareTo%28System.Object%29?displayProperty=nameWithType>メソッドよりも若干優れています。これは、 `strB`引数が変更可能な値型であり、ボックス化する必要があるかどうかを判断する必要がなく、<xref:System.Object> から<xref:System.String>へのパラメーター。  
  
   
  
## Examples  
 次の例では<xref:System.String.CompareTo%2A> 、メソッドを使用して、現在の文字列インスタンスを別の文字列と比較します。  
  
 [!code-cpp[stringcompareto#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareTo/CPP/stringcompareto.cpp#1)]
 [!code-csharp[stringcompareto#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareTo/CS/stringcompareto.cs#1)]
 [!code-vb[stringcompareto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareTo/VB/stringcompareto.vb#1)]  
  
 次の例は、いくつかの値および参照型に対する CompareTo メソッドのジェネリックバージョンと非ジェネリックバージョンを示しています。  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>文字セットには無視できる文字が含まれています。 メソッド<see cref="M:System.String.CompareTo(System.String)" />では、カルチャに依存した比較を実行するときに、このような文字は考慮されません。 たとえば、次のコードが以降で[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]実行されている場合、"animal" を "ani-正しくない" (ソフトハイフンまたは U + 00ad を使用) と比較すると、2つの文字列が等価であることが示されます。  
  
[!code-csharp[System.String.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto2.cs#2)] [!code-vb[System.String.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto2.vb#2)] 
文字列比較で無視できる文字を認識するには<see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> 、メソッドを呼び出します。</para></block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Concat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.String" /> の 1 つ以上のインスタンス、または <see cref="T:System.String" /> の 1 つ以上のインスタンスの <see cref="T:System.Object" /> 形式の値を連結します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

> [!NOTE]
>  言語の文字列`+`連結演算子 (in C#、 `&` `+` Visual Basic のなど) を使用して文字列を連結することもできます。 どちらのコンパイラも、連結演算子をの`String.Concat`オーバーロードの1つの呼び出しに変換します。 

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;string&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="values"><see cref="T:System.Collections.Generic.IEnumerable`1" /> を実装し、ジェネリック型引数が <see cref="T:System.String" /> であるコレクション オブジェクト。</param>
        <summary><see cref="T:System.Collections.Generic.IEnumerable`1" /> 型の構築された <see cref="T:System.String" /> コレクションのメンバーを連結します。</summary>
        <returns><paramref name="values" /> 内の文字列の連結結果。または、<paramref name="values" /> が空の <see langword="IEnumerable(Of String)" /> である場合は <see cref="F:System.String.Empty" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドは、内の各`values`オブジェクトを連結します。区切り記号は追加されません。 の`values`各メンバーの間に区切り記号を指定する<xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29>には、メソッドを呼び出します。  
  
 文字列は、内`values`の null 要素の代わりに使用されます。 <xref:System.String.Empty>  
  
 If `values` である場合は `IEnumerable(Of String)`の場合、メソッドは <xref:System.String.Empty?displayProperty=nameWithType>です。 <xref:System.ArgumentNullException>が`values` の場合、メソッドは例外を`null`スローします。  
  
 <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29>は、要素を最初に文字列配列に変換せず`IEnumerable(Of String)`に、コレクション内の各要素を連結できる便利なメソッドです。 これは、統合言語クエリ (LINQ) クエリ式で特に便利です。 次の例では`List(Of String)` 、アルファベットの大文字または小文字を含むオブジェクトを、特定の文字以上の文字 (例では "M") を選択するラムダ式に渡します。 メソッドによって返される`IEnumerable(Of String)`コレクションは、結果を1つの文字列として表示するためにメソッドに渡されます。<xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType>  
  
 [!code-csharp[System.String.Concat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat2.cs#3)]
 [!code-vb[System.String.Concat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat2.vb#3)]  
  
   
  
## Examples  
 次の例では、ありアルゴリズムのエラトステネスを使用して、100以下の素数を計算します。 結果を型<xref:System.Collections.Generic.List%601> <xref:System.String>のオブジェクトに代入し、次に<xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29>メソッドに渡します。  
  
 [!code-csharp[System.String.Concat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat1.cs#2)]
 [!code-vb[System.String.Concat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Concat : obj -&gt; string" Usage="System.string.Concat arg0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">表現するオブジェクトまたは <see langword="null" />。</param>
        <summary>指定されたオブジェクトの文字列形式を作成します。</summary>
        <returns><paramref name="arg0" /> の値の文字列形式。<see cref="F:System.String.Empty" /> が <paramref name="arg0" /> の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.String.Concat%28System.Object%29>は、 `arg0`パラメーターなし`ToString`のメソッドを呼び出すことによって、文字列としてを表します。  
  
   
  
## Examples  
 メソッドの<xref:System.String.Concat%2A>例を次に示します。  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Concat : obj[] -&gt; string" Usage="System.string.Concat args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">連結する要素を格納しているオブジェクト配列。</param>
        <summary>指定された <see cref="T:System.Object" /> 配列の要素の文字列表記を連結します。</summary>
        <returns><paramref name="args" /> の各要素の値を連結した文字列表記。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドは、そのオブジェクトの`args`パラメーターなし`ToString`のメソッドを呼び出すことによって、内の各オブジェクトを連結します。区切り記号は追加されません。  
  
 <xref:System.String.Empty?displayProperty=nameWithType>は、配列内の null オブジェクトの代わりに使用されます。  
  
   
  
## Examples  
 次の例では、 <xref:System.String.Concat%2A> <xref:System.Object>配列を使用してメソッドを使用する方法を示します。  
  
 [!code-csharp[stringconcat1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat1/CS/stringconcat1.cs#1)]
 [!code-vb[stringconcat1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat1/VB/stringconcat1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="args" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.OutOfMemoryException">メモリが不足しています。</exception>
        <block subset="none" type="usage"><para>このメソッドは、コードにC++よって呼び出されません。 コンパイラC++は、の呼び出し<see cref="Overload:System.String.Concat" /> <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />として、4つ以上のオブジェクトパラメーターを持つの呼び出しを解決します。</para></block>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray values As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : string[] -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="values">文字列インスタンスの配列。</param>
        <summary>指定した <see cref="T:System.String" /> 配列の要素を連結します。</summary>
        <returns>連結された <paramref name="values" /> の要素。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドは、内の各`values`オブジェクトを連結します。区切り記号は追加されません。  
  
 <xref:System.String.Empty>文字列は、配列内の null オブジェクトの代わりに使用されます。  
  
   
  
## Examples  
 次の例では、 <xref:System.String.Concat%2A> <xref:System.String>配列を使用してメソッドを使用する方法を示します。  
  
 [!code-cpp[stringconcat3#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat3/CPP/stringconcat3.cpp#1)]
 [!code-csharp[stringconcat3#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat3/CS/stringconcat3.cs#1)]
 [!code-vb[stringconcat3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat3/VB/stringconcat3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.OutOfMemoryException">メモリが不足しています。</exception>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">連結する最初のオブジェクト。</param>
        <param name="arg1">連結する 2 番目のオブジェクト。</param>
        <summary>指定した 2 つのオブジェクトの文字列形式を連結します。</summary>
        <returns><paramref name="arg0" /> および <paramref name="arg1" /> の値の文字列形式を連結した結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドは、 `arg0`と`arg1`のパラメーターなし`ToString` `arg0` の`arg1`メソッドを呼び出すことによってとを連結します。区切り記号は追加されません。  
  
 <xref:System.String.Empty?displayProperty=nameWithType>は、null 引数の代わりに使用されます。  
  
 場合か、引数の配列参照は、メソッドは、そのメンバー (たとえば、"System.String[]") 代わりに、その配列を表す文字列を連結します。  
  
   
  
## Examples  
 メソッドの<xref:System.String.Concat%2A>例を次に示します。  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(valuetype System.ReadOnlySpan`1&lt;char&gt; str0, valuetype System.ReadOnlySpan`1&lt;char&gt; str1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As ReadOnlySpan(Of Char), str1 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1);" />
      <MemberSignature Language="F#" Value="static member Concat : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.string.Concat (str0, str1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="str0">連結する最初の読み取り専用文字スパン。</param>
        <param name="str1">連結する 2 番目の読み取り専用文字スパン。</param>
        <summary>2 つの指定された読み取り専用文字スパンの文字列形式を連結します。</summary>
        <returns><paramref name="str0" /> および <paramref name="str1" /> の値の文字列形式を連結した結果。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string -&gt; string" Usage="System.string.Concat (str0, str1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">連結する最初の文字列。</param>
        <param name="str1">連結する 2 番目の文字列。</param>
        <summary>指定した 2 つの <see cref="T:System.String" /> インスタンスを連結します。</summary>
        <returns><paramref name="str0" /> と <paramref name="str1" /> の連結。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドはと`str0`を`str1`連結します。区切り記号は追加されません。  
  
 Null 引数の代わりに文字列を使用します。<xref:System.String.Empty>  
  
## Examples  
 次の例では、ユーザーの姓、ミドルネーム、および姓を連結しています。  
  
 [!code-cpp[stringconcat4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat4/CPP/stringconcat4.cpp#1)]
 [!code-csharp[stringconcat4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat4/CS/stringconcat4.cs#1)]
 [!code-vb[stringconcat4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat4/VB/stringconcat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">連結する最初のオブジェクト。</param>
        <param name="arg1">連結する 2 番目のオブジェクト。</param>
        <param name="arg2">連結する 3 番目のオブジェクト。</param>
        <summary>指定した 3 つのオブジェクトの文字列形式を連結します。</summary>
        <returns><paramref name="arg0" />、<paramref name="arg1" /> および <paramref name="arg2" /> の値の文字列形式を連結した結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドは、 `arg0` `arg1`各オブジェクトの`arg2`パラメーターなし`ToString`のメソッドを呼び出すことによって、、およびを連結します。区切り記号は追加されません。  
  
 <xref:System.String.Empty?displayProperty=nameWithType>は、null 引数の代わりに使用されます。  
  
   
  
## Examples  
 メソッドの<xref:System.String.Concat%2A>例を次に示します。  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(valuetype System.ReadOnlySpan`1&lt;char&gt; str0, valuetype System.ReadOnlySpan`1&lt;char&gt; str1, valuetype System.ReadOnlySpan`1&lt;char&gt; str2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As ReadOnlySpan(Of Char), str1 As ReadOnlySpan(Of Char), str2 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2);" />
      <MemberSignature Language="F#" Value="static member Concat : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.string.Concat (str0, str1, str2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="str0">連結する最初の読み取り専用文字スパン。</param>
        <param name="str1">連結する 2 番目の読み取り専用文字スパン。</param>
        <param name="str2">連結する 3 番目の読み取り専用の文字スパン。</param>
        <summary>3 つの指定された読み取り専用文字スパンの文字列形式を連結します。</summary>
        <returns><paramref name="str0" />、<paramref name="str1" />、および <paramref name="str2" /> の値の文字列形式を連結した結果。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">連結する最初の文字列。</param>
        <param name="str1">連結する 2 番目の文字列。</param>
        <param name="str2">連結する 3 番目の文字列。</param>
        <summary><see cref="T:System.String" /> の指定した 3 つのインスタンスを連結します。</summary>
        <returns><paramref name="str0" />、<paramref name="str1" />、および <paramref name="str2" /> の連結。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドは、 `str0` `str1`、、および`str2`を連結します。区切り記号は追加されません。  
  
## Examples  
 次の例では<xref:System.String.Concat%2A> 、メソッドを使用して、3つの文字列を連結し、結果を表示します。  
  
 [!code-cpp[System.String.Concat#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.concat/cpp/Concat6.cpp#6)]
 [!code-csharp[System.String.Concat#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/Concat6.cs#6)]
 [!code-vb[System.String.Concat#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/Concat6.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object, arg3 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2, System::Object ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg3" Type="System.Object" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="arg0">連結する最初のオブジェクト。</param>
        <param name="arg1">連結する 2 番目のオブジェクト。</param>
        <param name="arg2">連結する 3 番目のオブジェクト。</param>
        <param name="arg3">連結する 4 番目のオブジェクト。</param>
        <summary>4 つの指定したオブジェクトと、オプションの可変長パラメーター リストで指定した任意のオブジェクトの文字列表現を連結します。</summary>
        <returns>パラメーター リスト内の各値の文字列を連結した結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  この API は、CLS に準拠していません。 CLS 準拠の代わりとして <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType> を使用できます。 およびC# Visual Basic コンパイラは、このメソッドへの呼び出しをの呼び出し<xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>として自動的に解決します。  
  
 メソッドは、パラメーターなし`ToString`のメソッドを呼び出すことによって、パラメーターリスト内の各オブジェクトを連結します。区切り記号は追加されません。  
  
 <xref:System.String.Empty?displayProperty=nameWithType>は、null 引数の代わりに使用されます。  
  
> [!NOTE]
>  <xref:System.String.Concat%2A>メソッドの最後のパラメーターは、連結する1つ以上の追加オブジェクトのコンマ区切りのリストです (省略可能)。  
  
   
  
## Examples  
 次の例は、 <xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29>メソッドを使用して、変数パラメーターの一覧を連結する方法を示しています。 この場合、メソッドは9個のパラメーターを使用して呼び出されます。  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>このメソッドは、 <see langword="vararg" />キーワードでマークされています。これは、可変個のパラメーターをサポートしていることを意味します。 メソッドはビジュアルC++から呼び出すことができますが、または Visual Basic C#コードから呼び出すことはできません。 およびC# Visual Basic コンパイラは、の呼び出し<see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /> <see cref="M:System.String.Concat(System.Object[])" />としての呼び出しを解決します。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2, ReadOnlySpan&lt;char&gt; str3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(valuetype System.ReadOnlySpan`1&lt;char&gt; str0, valuetype System.ReadOnlySpan`1&lt;char&gt; str1, valuetype System.ReadOnlySpan`1&lt;char&gt; str2, valuetype System.ReadOnlySpan`1&lt;char&gt; str3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As ReadOnlySpan(Of Char), str1 As ReadOnlySpan(Of Char), str2 As ReadOnlySpan(Of Char), str3 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2, ReadOnlySpan&lt;char&gt; str3);" />
      <MemberSignature Language="F#" Value="static member Concat : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.string.Concat (str0, str1, str2, str3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="3" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="str0">連結する最初の読み取り専用文字スパン。</param>
        <param name="str1">連結する 2 番目の読み取り専用文字スパン。</param>
        <param name="str2">連結する 3 番目の読み取り専用の文字スパン。</param>
        <param name="str3">連結する 4 番目の読み取り専用の文字スパン。</param>
        <summary>4 つの指定された読み取り専用文字スパンの文字列形式を連結します。</summary>
        <returns><paramref name="str0" />、<paramref name="str1" />、<paramref name="str2" />、および <paramref name="str3" /> の値の文字列形式を連結した結果。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2, string str3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2, string str3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String, str3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2, System::String ^ str3);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2, str3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
        <Parameter Name="str3" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">連結する最初の文字列。</param>
        <param name="str1">連結する 2 番目の文字列。</param>
        <param name="str2">連結する 3 番目の文字列。</param>
        <param name="str3">連結する 4 番目の文字列。</param>
        <summary>指定した 4 つの <see cref="T:System.String" /> インスタンスを連結します。</summary>
        <returns><paramref name="str0" />、<paramref name="str1" />、<paramref name="str2" />、および <paramref name="str3" /> の連結。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `str0`メソッドは`str1` `str3`、、、、およびを連結します。区切り記号は追加されません。 `str2`  
  
## Examples  
 次の例では、4文字の単語の配列を定義し、それらの文字をスクランブルするために文字列配列に格納します。 次に、メソッド<xref:System.String.Concat%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29>を呼び出して、スクランブルされた単語を再アセンブルします。  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Concat&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat(Of T) (values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;'T&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><paramref name="values" /> のメンバーの型。</typeparam>
        <param name="values"><see cref="T:System.Collections.Generic.IEnumerable`1" /> インターフェイスを実装するコレクション オブジェクト。</param>
        <summary><see cref="T:System.Collections.Generic.IEnumerable`1" /> 実装のメンバーを連結します。</summary>
        <returns><paramref name="values" /> 内のメンバーの連結結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドは、内の各`values`オブジェクトを連結します。区切り記号は追加されません。  
  
 Null 引数の代わりに文字列を使用します。<xref:System.String.Empty>  
  
 <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>は、最初に要素を文字列に変換せずに<xref:System.Collections.Generic.IEnumerable%601> 、コレクション内の各要素を連結できる便利なメソッドです。 この例に示すように、統合言語クエリ (LINQ) クエリ式では特に便利です。 <xref:System.Collections.Generic.IEnumerable%601>コレクション内の各オブジェクトの文字列形式は、そのオブジェクトの`ToString`メソッドを呼び出すことによって派生されます。  
  
   
  
## Examples  
 次の例では、動物`Animal`の名前とそれが属する順序を含む非常に単純なクラスを定義しています。 次に、複数<xref:System.Collections.Generic.List%601>の`Animal`オブジェクトを格納するオブジェクトを定義します。 拡張<xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType>メソッドは、 `Order`プロパティが "げっ歯類`Animal` " と等しいオブジェクトを抽出するために呼び出されます。 結果は<xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>メソッドに渡され、コンソールに表示されます。  
  
 [!code-csharp[System.String.Concat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat3.cs#4)]
 [!code-vb[System.String.Concat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> は <see langword="null" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value);" />
      <MemberSignature Language="F#" Value="member this.Contains : char -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">検索対象の文字。</param>
        <summary>指定した文字がこの文字列内に存在するかどうかを示す値を返します。</summary>
        <returns><paramref name="value" /> パラメーターがこの文字列内で発生する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Contains : string -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <summary>指定した部分文字列がこの文字列内に存在するかどうかを示す値を返します。</summary>
        <returns><paramref name="value" /> パラメーターがこの文字列内に存在するか、<paramref name="value" /> が空の文字列 ("") の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、序数 (大文字と小文字を区別し、カルチャに依存しない) の比較を実行します。 検索は、この文字列の最初の文字位置から開始され、最後の文字位置まで続きます。  
  
 序数による比較 (カルチャに依存した比較、または大文字と小文字を区別しない比較など) を使用して文字列に指定した部分文字列が含まれているかどうかを確認するには、カスタムメソッドを作成します。 このような方法の例を次に示します。 これは、 <xref:System.String>パラメーターを<xref:System.StringComparison>含む拡張メソッドを定義し、指定された形式の文字列比較を使用する場合に文字列に部分文字列が含まれるかどうかを示します。  
  
 [!code-csharp[System.String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#1)]
 [!code-vb[System.String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#1)]  
  
 次の例では、 `Contains`拡張メソッドを呼び出して、序数による比較と大文字と小文字を区別しない序数比較を使用する場合に、文字列内で部分文字列が見つかったかどうかを判断します。  
  
 [!code-csharp[System.String.Contains#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#2)]
 [!code-vb[System.String.Contains#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#2)]  
  
 現在のインスタンス内の部分文字列`value`の位置を知りたい場合は、 <xref:System.String.IndexOf%2A>メソッドを呼び出して最初に出現する位置を取得します。または、メソッドを呼び出し<xref:System.String.LastIndexOf%2A>て、その開始位置を取得することもできます。最後に発生した。 この例では、文字列インスタンス<xref:System.String.IndexOf%28System.String%29>で部分文字列が見つかった場合のメソッドの呼び出しが含まれています。  
  
   
  
## Examples  
 次の例では、文字列 "fox" が、使い慣れた引用符の部分文字列であるかどうかを判断します。 文字列内に "fox" が見つかった場合は、その開始位置も表示されます。  
  
 [!code-cpp[String.Contains#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.contains/CPP/cont.cpp#1)]
 [!code-csharp[String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.contains/CS/cont.cs#1)]
 [!code-vb[String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.contains/VB/cont.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> が <see langword="null" /> です。</exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : char * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">検索対象の文字。</param>
        <param name="comparisonType">比較で使用する規則を指定する列挙値の 1 つ。</param>
        <summary>指定された比較規則を使用して、指定された文字がこの文字列内に含まれるかどうかを示す値を返します。</summary>
        <returns><paramref name="value" /> パラメーターがこの文字列内で発生する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : string * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <param name="comparisonType">比較で使用する規則を指定する列挙値の 1 つ。</param>
        <summary>指定された比較規則を使用して、指定された文字列がこの文字列内に含まれるかどうかを示す値を返します。</summary>
        <returns><paramref name="value" /> パラメーターがこの文字列内に存在するか、<paramref name="value" /> が空の文字列 ("") の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static string Copy (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Copy(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Copy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Copy (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Copy(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Copy : string -&gt; string" Usage="System.string.Copy str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This API should not be used to create mutable strings. See https://go.microsoft.com/fwlink/?linkid=2084035 for alternatives.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="str">コピーする文字列。</param>
        <summary>指定した <see cref="T:System.String" /> と同じ値を使用して、<see cref="T:System.String" /> の新しいインスタンスを作成します。</summary>
        <returns><paramref name="str" /> と同じ値を持つ新しい文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

メソッド`Copy`は、元<xref:System.String>の文字列と同じ値を持ち、別のオブジェクト参照を表すオブジェクトを返します。 これは代入演算とは異なり、既存の文字列参照を追加のオブジェクト変数に代入します。

> [!IMPORTANT]
>  .NET Core 3.0 以降では、このメソッドは互換性のために残されています。 ただし、.NET の実装では使用しないことをお勧めします。 特に、.net Core 3.0 では文字列インターンが変更されているため、 `Copy`メソッドは新しい文字列を作成せず、単に既存のインターン文字列への参照を返す場合があります。   

`Copy`メソッドを呼び出す理由に応じて、いくつかの代替手段があります。

- 文字列を変更する操作で別の文字列インスタンスを使用する場合は、元の文字列インスタンスを使用します。 文字列は不変であるため、文字列操作は新しい文字列インスタンスを作成し、元の文字列は影響を受けません。 この場合、元の文字列変数に新しい文字列参照を割り当てないでください。 具体的な例を次に示します。

  [!code-csharp[Performing a string operation](~/samples/snippets/csharp/api/system/string/copy/program.cs#1)]
  [!code-vb[Performing a string operation](~/samples/snippets/visualbasic/api/system/string/copy/program.vb#1)]  
  
   この場合、メソッドを呼び出す`Copy`前<xref:System.String.Substring%2A>に新しい文字列を作成するためにメソッドを呼び出すと、新しい文字列インスタンスが不必要に作成されます。 

- 元の文字列と同じ内容の変更可能なバッファーを作成する場合<xref:System.String.ToCharArray%2A?displayProperty=nameWithType>は、コンストラクターまたは<xref:System.Text.StringBuilder.%23ctor(System.String)?displayProperty=nameWithType>コンストラクターを呼び出します。 次に例を示します。

  [!code-csharp[Performing a string operation](~/samples/snippets/csharp/api/system/string/copy/program.cs#2)]
  [!code-vb[Performing a string operation](~/samples/snippets/visualbasic/api/system/string/copy/program.vb#2)]  

- アンセーフコードを使用して文字列の内容を変更できるように、文字列の変更可能なコピーを作成する<xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType>場合は、メソッドを使用します。 次の例では<xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType> 、メソッドを使用して、アンマネージメモリ内のコピーされた文字列の位置へのポインターを取得し、文字列内の各文字の Unicode コードポイントを1だけインクリメントし、結果の文字列をマネージ文字列にコピーします。

  [!code-csharp[Performing a string operation](~/samples/snippets/csharp/api/system/string/copy/program.cs#3)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> は <see langword="null" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * char[] * int * int -&gt; unit" Usage="string.CopyTo (sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">コピーする、このインスタンス内の最初の文字のインデックス。</param>
        <param name="destination">このインスタンスの文字のコピー先となる Unicode 文字の配列。</param>
        <param name="destinationIndex">コピー操作を開始する <paramref name="destination" /> のインデックス。</param>
        <param name="count"><paramref name="destination" /> へコピーされるこのインスタンスの文字の数。</param>
        <summary>このインスタンスの指定位置から指定した数の文字を、Unicode 文字の配列内の指定位置へコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは`count` 、このインスタンス`sourceIndex` `destinationIndex`の位置から文字配列の`destination`位置に文字をコピーします。 このメソッドは、文字配列`destination`のサイズを変更しません。コピーされた文字を格納するのに十分な数<xref:System.ArgumentOutOfRangeException>の要素が必要です。または、メソッドがをスローします。  
  
 `sourceIndex`と`destinationIndex`は、0から始まります。  
  
   
  
## Examples  
 メソッドの<xref:System.String.CopyTo%2A>例を次に示します。  
  
 [!code-cpp[stringcopyto#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringcopyto/CPP/stringcopyto.cpp#1)]
 [!code-csharp[stringcopyto#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringcopyto/CS/stringcopyto.cs#1)]
 [!code-vb[stringcopyto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringcopyto/VB/stringcopyto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="destination" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" />、 <paramref name="destinationIndex" />、または <paramref name="count" /> が負の値です。 
- または - 
 <paramref name="sourceIndex" /> が現在のインスタンス内の位置を識別していません。  
  
- または - 
 <paramref name="destinationIndex" /> が、 <paramref name="destination" /> 配列内の有効なインデックスを識別していません。  
  
または 
 <paramref name="count" /> は、このインスタンスの <paramref name="sourceIndex" /> から末尾までの部分文字列の長さを超えています。 
- または - 
 <paramref name="count" /> は、 <paramref name="destinationIndex" /> 配列の <paramref name="destination" /> から末尾までの部分配列の長さを超えています。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Create&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static string Create&lt;TState&gt; (int length, TState state, System.Buffers.SpanAction&lt;char,TState&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Create&lt;TState&gt;(int32 length, !!TState state, class System.Buffers.SpanAction`2&lt;char, !!TState&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Create``1(System.Int32,``0,System.Buffers.SpanAction{System.Char,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create(Of TState) (length As Integer, state As TState, action As SpanAction(Of Char, TState)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static System::String ^ Create(int length, TState state, System::Buffers::SpanAction&lt;char, TState&gt; ^ action);" />
      <MemberSignature Language="F#" Value="static member Create : int * 'State * System.Buffers.SpanAction&lt;char, 'State&gt; -&gt; string" Usage="System.string.Create (length, state, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="length" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="TState" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="action" Type="System.Buffers.SpanAction&lt;System.Char,TState&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <param name="length">To be added.</param>
        <param name="state">To be added.</param>
        <param name="action">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static readonly string Empty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string Empty" />
      <MemberSignature Language="DocId" Value="F:System.String.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Empty As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ Empty;" />
      <MemberSignature Language="F#" Value=" staticval mutable Empty : string" Usage="System.string.Empty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>空の文字列を表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このフィールドの値は、長さが0の文字列 "" です。  
  
 アプリケーションコードでは、このフィールドは、文字列変数を空の文字列に初期化するために割り当てで最もよく使用されます。 文字列の値がまたはのどちら`null`であるかをテストするには<xref:System.String.Empty?displayProperty=nameWithType>、 <xref:System.String.IsNullOrEmpty%2A>メソッドを使用します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="EndsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>この文字列インスタンスの末尾が、指定した文字列と一致するかどうかを判断します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(char value);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : char -&gt; bool" Usage="string.EndsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string -&gt; bool" Usage="string.EndsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">このインスタンスの末尾の部分文字列と比較する文字列。</param>
        <summary>この文字列インスタンスの末尾が、指定した文字列と一致するかどうかを判断します。</summary>
        <returns>このインスタンスの末尾が <paramref name="value" /> と一致する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは`value` 、と`value`同じ長さで、このインスタンスの末尾の部分文字列と比較し、等しいかどうかを示す値を返します。 と等しい場合は`value` 、この同じインスタンスへの参照であるか、またはこのインスタンスの末尾と一致する必要があります。  
  
 このメソッドは、現在のカルチャを使用して、単語 (大文字と小文字を区別し、カルチャに依存する) 比較を実行します。  
  
   
  
## Examples  
 次の例では、配列内の各文字列の末尾がピリオド (".") であるかどうかを示します。  
  
 [!code-csharp[System.String.EndsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.EndsWith/cs/EndsWith1.cs#1)]
 [!code-vb[System.String.EndsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.EndsWith/vb/EndsWith1.vb#1)]  
  
 次の例では`StripEndTags` 、 <xref:System.String.EndsWith%28System.String%29>メソッドを使用して、行の末尾から HTML 終了タグを削除するメソッドを定義しています。 このメソッドは`StripEndTags` 、行の末尾にある複数の HTML 終了タグが削除されるように、再帰的に呼び出されることに注意してください。  
  
 [!code-cpp[stringendswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringendswith/CPP/stringendswith.cpp#1)]
 [!code-csharp[stringendswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringendswith/CS/stringendswith.cs#1)]
 [!code-vb[stringendswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringendswith/VB/stringendswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> は <see langword="null" />です。</exception>
        <block subset="none" type="usage"><para>「[文字列を使用するためのベストプラクティス](~/docs/standard/base-types/best-practices-strings.md)」で説明したように、既定値を置き換える文字列比較メソッドを呼び出さずに、パラメーターを明示的に指定する必要があるメソッドを呼び出すことを避けることをお勧めします。 現在のカルチャの文字列比較規則を使用して、文字列が特定の<see cref="M:System.String.EndsWith(System.String,System.StringComparison)" /> <see cref="F:System.StringComparison.CurrentCulture" />部分文字列で終わるかどうかを確認するには、 <paramref name="comparisonType" />パラメーターの値を指定してメソッドオーバーロードを呼び出します。</para></block>
        <altmember cref="M:System.String.StartsWith(System.String)" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * StringComparison -&gt; bool" Usage="string.EndsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">このインスタンスの末尾の部分文字列と比較する文字列。</param>
        <param name="comparisonType">この文字列と <paramref name="value" /> との比較方法を決定する列挙値の 1 つ。</param>
        <summary>指定された比較オプションを使って比較した場合に、この文字列インスタンスの末尾が、指定された文字列と一致するかどうかを判断します。</summary>
        <returns><paramref name="value" /> パラメーターがこの文字列の末尾と一致する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.String.EndsWith%2A>は、 `value`パラメーターをこの文字列の末尾の部分文字列と比較し、等しいかどうかを示す値を返します。 と等しい場合は`value` 、この同じ文字列への参照であるか、空の文字列 ("") であるか、またはこの文字列の末尾と一致する必要があります。 <xref:System.String.EndsWith%2A>メソッドによって実行される比較の種類は、 `comparisonType`パラメーターの値によって異なります。  
  
   
  
## Examples  
 次の例では、文字列が特定の部分文字列で終わるかどうかを判断します。 結果は、カルチャの選択、case が無視されるかどうか、および序数に基づく比較が実行されるかどうかによって影響を受けます。  
  
 [!code-cpp[System.String.EndsWithCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cpp/ewcmp.cpp#1)]
 [!code-csharp[System.String.EndsWithCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cs/ewcmp.cs#1)]
 [!code-vb[System.String.EndsWithCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.EndsWithCmp/vb/ewcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> が <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.EndsWith (value, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">このインスタンスの末尾の部分文字列と比較する文字列。</param>
        <param name="ignoreCase">比較時に大文字と小文字の区別を無視する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="culture">このインスタンスと <paramref name="value" /> との比較方法を決定するカルチャ情報。 <paramref name="culture" /> が <see langword="null" /> の場合は、現在のカルチャが使用されます。</param>
        <summary>指定されたカルチャを使って比較した場合に、この文字列インスタンスの末尾が、指定された文字列と一致するかどうかを判断します。</summary>
        <returns><paramref name="value" /> パラメーターがこの文字列の末尾と一致する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、 `value`パラメーターをこの文字列の末尾にあるのと`value`同じ長さの部分文字列と比較し、等しいかどうかを示す値を返します。 等しい場合は、 `value`この同じインスタンスへの参照であるか、またはこの文字列の末尾と一致している必要があります。  
  
 このメソッドは、指定された大文字と小文字の区別とカルチャを使用して、単語 (カルチャに依存した) 比較を実行します。  
  
   
  
## Examples  
 次の例では、文字列が別の文字列の末尾にあるかどうかを判断します。 大文字と小文字の区別、大文字小文字の区別、および検索結果に影響を与えるさまざまなカルチャを使用して、メソッドが複数回呼び出されます。<xref:System.String.EndsWith%2A>  
  
 [!code-csharp[system.string.EndsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.EndsWithCI/cs/ewci.cs#1)]
 [!code-vb[system.string.EndsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.EndsWithCI/vb/ewci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> が <see langword="null" /> です。</exception>
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <Member MemberName="EnumerateRunes">
      <MemberSignature Language="C#" Value="public System.Text.StringRuneEnumerator EnumerateRunes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Text.StringRuneEnumerator EnumerateRunes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EnumerateRunes" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateRunes () As StringRuneEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringRuneEnumerator EnumerateRunes();" />
      <MemberSignature Language="F#" Value="member this.EnumerateRunes : unit -&gt; System.Text.StringRuneEnumerator" Usage="string.EnumerateRunes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringRuneEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この文字列から <see cref="T:System.Text.Rune" /> の列挙体を返します。</summary>
        <returns>文字列ルーン列挙子。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

### Remarks

無効なシーケンスは、によって<xref:System.Text.Rune.ReplacementChar?displayProperty=nameWithType>列挙体で表されます。

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>2 つの <see cref="T:System.String" /> オブジェクトの値が同一かどうかを判断します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="string.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">このインスタンスと比較する文字列。</param>
        <summary>このインスタンスと、指定したオブジェクトの値が同一かどうかを判断します。<see cref="T:System.String" /> オブジェクトを指定する必要があります。</summary>
        <returns><see langword="true" /> が <paramref name="obj" /> で、このインスタンスと同じ値を保持している場合は <see cref="T:System.String" />。それ以外の場合は <see langword="false" />。  <paramref name="obj" /> が <see langword="null" /> の場合、メソッドは <see langword="false" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、序数 (大文字と小文字を区別し、カルチャに依存しない) の比較を実行します。  
  
   
  
## Examples  
 メソッドの<xref:System.String.Equals%2A>例を次に示します。  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::String ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : string -&gt; bool" Usage="string.Equals value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">このインスタンスと比較する文字列。</param>
        <summary>このインスタンスと、指定した別の <see cref="T:System.String" /> の値が同一かどうかを判断します。</summary>
        <returns><see langword="true" /> パラメーターの値がこのインスタンスの値と同じ場合は <paramref name="value" />。それ以外の場合は <see langword="false" />。 <paramref name="value" /> が <see langword="null" /> の場合、メソッドは <see langword="false" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、序数 (大文字と小文字を区別し、カルチャに依存しない) の比較を実行します。  
  
   
  
## Examples  
 メソッドの<xref:System.String.Equals%2A>例を次に示します。 タイトルの大文字と小文字の "File" を、それと等価な単語、小文字の小文字、大文字、およびラテン小文字 I (U + 0069) ではなく、ラテン文字の小文字の I (U + 0131) を含む単語と比較します。 メソッドは<xref:System.String.Equals%28System.String%29>序数による比較を実行するため、同一の単語と`true`の比較のみが返されます。  
  
 [!code-csharp[System.String.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equalsex1.cs#2)]
 [!code-vb[System.String.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equalsex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string -&gt; bool" Usage="System.string.Equals (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">比較する最初の文字列または <see langword="null" />。</param>
        <param name="b">比較する 2 番目の文字列または <see langword="null" />。</param>
        <summary>指定した 2 つの <see cref="T:System.String" /> オブジェクトの値が同一かどうかを判断します。</summary>
        <returns><paramref name="a" /> の値が <paramref name="b" /> の値と同じ場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 <paramref name="a" /> と <paramref name="b" /> の両方が <see langword="null" /> の場合、メソッドは <see langword="true" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、序数 (大文字と小文字を区別し、カルチャに依存しない) の比較を実行します。  
  
   
  
## Examples  
 メソッドの<xref:System.String.Equals%2A>例を次に示します。  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.Equals : string * StringComparison -&gt; bool" Usage="string.Equals (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">このインスタンスと比較する文字列。</param>
        <param name="comparisonType">文字列の比較方法を指定する列挙値の 1 つ。</param>
        <summary>この文字列と、指定した <see cref="T:System.String" /> オブジェクトの値が同一かどうかを判断します。 比較に使用するカルチャ、大文字と小文字の区別、および、並べ替え規則をパラメーターで指定します。</summary>
        <returns><see langword="true" /> パラメーターの値がこの文字列と同じ場合は <paramref name="value" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 パラメーター `comparisonType`は、比較で現在のカルチャまたはインバリアントカルチャを使用するか、比較する2つの文字列の大文字と小文字の区別を無視するか、または単語または序数の並べ替え規則を使用するかを示します。  
  
   
  
## Examples  
 次の例では、大文字の "I"、小文字の "i"、およびドットではない "ı" で構成される文字列配列を作成します。 次に、 <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29>メソッドを呼び出して、考えられる<xref:System.StringComparison>各列挙値を使用して比較します。  
  
 [!code-csharp[System.String.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/eqcmp.cs#1)]
 [!code-vb[System.String.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/eqcmp.vb#1)]  
  
 次の例では、 <xref:System.StringComparison>列挙体の各メンバーを使用して、4つの単語セットを比較します。  この比較では、英語 (米国) カルチャとサーミ語 (Upper スウェーデン) カルチャの規則が使用されます。 文字列 "encyclopædia" および "encyclopaedia" は、en-us カルチャでは等価と見なされますが、サーミ語 (北スウェーデン) カルチャでは考慮されないことに注意してください。  
  
 [!code-csharp[System.String.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex4.cs#4)]
 [!code-vb[System.String.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> が <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string * StringComparison -&gt; bool" Usage="System.string.Equals (a, b, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="b" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="a">比較する最初の文字列または <see langword="null" />。</param>
        <param name="b">比較する 2 番目の文字列または <see langword="null" />。</param>
        <param name="comparisonType">比較の規則を指定する列挙値の 1 つ。</param>
        <summary>指定した 2 つの <see cref="T:System.String" /> オブジェクトの値が同一かどうかを判断します。 比較に使用するカルチャ、大文字と小文字の区別、および、並べ替え規則をパラメーターで指定します。</summary>
        <returns><see langword="true" /> パラメーターの値が <paramref name="a" /> パラメーターの値に等しい場合は <paramref name="b" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 パラメーター `comparisonType`は、比較で現在のカルチャまたはインバリアントカルチャを使用するか、比較する2つの文字列の大文字と小文字の区別を無視するか、または単語または序数の並べ替え規則を使用するかを示します。  
  
   
  
## Examples  
 次の例では、 <xref:System.StringComparison>列挙体の各メンバーを使用して、4つの単語セットを比較します。  この比較では、英語 (米国) カルチャとサーミ語 (Upper スウェーデン) カルチャの規則が使用されます。 文字列 "encyclopædia" および "encyclopaedia" は、en-us カルチャでは等価と見なされますが、サーミ語 (北スウェーデン) カルチャでは考慮されないことに注意してください。  
  
 [!code-csharp[System.String.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex3.cs#3)]
 [!code-vb[System.String.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> が <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Format">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定された形式に基づいてオブジェクトの値を文字列に変換し、別の文字列に挿入します。  
  
`String.Format` メソッドを初めて使用する場合は、「[Get started with the String.Format method](#Starting)」(String.Format メソッドの概要) セクションを参照して、概要をご確認ください。  
  
`String.Format` メソッドの全般的な説明については、「[Remarks](#remarks-top)」 (解説) セクションを参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
<a name="remarks-top"></a>   
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
 
 このセクションの内容:  
  
 [String. Format メソッドの概要](#Starting)   
 [どの方法を呼び出すか。](#FTaskList)   
 [Format メソッド (brief)](#Format_Brief)   
 [書式項目](#FormatItem)   
 [引数の書式設定](#HowFormatted)   
 [同じインデックスを持つ項目を書式設定する](#SameIndex)   
 [書式設定とカルチャ](#Format_Culture)   
 [カスタムの書式設定操作](#Format_Custom)   
 [文字列。 Q & A を書式設定します。](#QA)  
  
<a name="Starting"></a>   
## <a name="get-started-with-the-stringformat-method"></a>String. Format メソッドの概要  
 オブジェクト<xref:System.String.Format%2A?displayProperty=nameWithType> 、変数、または式の値を別の文字列に挿入する必要がある場合は、を使用します。 たとえば、 <xref:System.Decimal>値の値を文字列に挿入して、1つの文字列としてユーザーに表示することができます。  
  
 [!code-cpp[System.String.Format#35](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#35)]
 [!code-csharp-interactive[System.String.Format#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#35)]
 [!code-vb[System.String.Format#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#35)]  
  
 また、その値の書式設定を制御することもできます。  
  
 [!code-cpp[System.String.Format#36](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#36)]
 [!code-csharp[System.String.Format#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#36)]
 [!code-vb[System.String.Format#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#36)]  
  
 書式設定だけでなく、配置や間隔を制御することもできます。  
  
 ### <a name="inserting-a-string"></a>文字列の挿入  

 <xref:System.String.Format%2A?displayProperty=nameWithType>書式指定文字列から開始し、その後に1つ以上のオブジェクトまたは式を指定して、文字列に変換し、書式文字列内の指定した場所に挿入します。 次に例を示します。  
  
 [!code-cpp[System.String.Format#30](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#30)]
 [!code-csharp-interactive[System.String.Format#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#30)]
 [!code-vb[System.String.Format#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#30)]  
  
 書式`{0}`指定文字列のは、書式指定項目です。 `0`文字列値がその位置に挿入されるオブジェクトのインデックスを指定します。 (インデックスは0から始まります)。挿入するオブジェクトが文字列`ToString`でない場合は、メソッドが呼び出され、結果文字列に挿入される前にそのオブジェクトが1つに変換されます。  
  
 2つの書式項目とオブジェクトリスト内の2つのオブジェクトを使用するもう1つの例を次に示します。  
  
 [!code-cpp[System.String.Format#31](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#31)]
 [!code-csharp[System.String.Format#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#31)]
 [!code-vb[System.String.Format#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#31)]  
  
 各書式指定項目のインデックスのオブジェクトリストに一致するオブジェクトがある限り、任意の数の書式項目と、オブジェクトリスト内のオブジェクトの数を指定できます。 また、どのオーバーロードを呼び出すかについて心配する必要もありません。適切なものがコンパイラによって選択されます。  
  
 ### <a name="controlling-formatting"></a>書式設定の制御  
 書式指定文字列を含む書式指定項目のインデックスに従うと、オブジェクトの書式設定方法を制御できます。 たとえば、は`{0:d}` 、オブジェクトリストの最初のオブジェクトに "d" 書式指定文字列を適用します。 次に、1つのオブジェクトと2つの書式設定項目を使用した例を示します。  
  
 [!code-cpp[System.String.Format#32](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#32)]
 [!code-csharp[System.String.Format#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#32)]
 [!code-vb[System.String.Format#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#32)]  
  
 多くの型は、書式指定文字列をサポートしています。これには、すべての数値型 ([標準](~/docs/standard/base-types/standard-numeric-format-strings.md)と[カスタム](~/docs/standard/base-types/custom-numeric-format-strings.md)の書式指定文字列の両方)、すべての日付と時刻 ([標準](~/docs/standard/base-types/standard-date-and-time-format-strings.md)と[カスタム](~/docs/standard/base-types/custom-date-and-time-format-strings.md)の書式指定文字列の両方)、および時間間隔 ([標準](~/docs/standard/base-types/standard-timespan-format-strings.md)と[カスタム](~/docs/standard/base-types/custom-timespan-format-strings.md)書式指定文字列)、すべての列挙型の[列挙](~/docs/standard/base-types/enumeration-format-strings.md)型、および[guid](https://msdn.microsoft.com/library/97af8hh4.aspx)。 書式指定文字列のサポートを独自の型に追加することもできます。  
  
 ### <a name="controlling-spacing"></a>制御 (間隔を)  
 `{0,12}`たとえば、12文字の文字列を挿入するなどの構文を使用して、結果文字列に挿入される文字列の幅を定義できます。 この場合、最初のオブジェクトの文字列表現は、12文字のフィールドでは右に並べられています。  (最初のオブジェクトの文字列表現の長さが12文字を超えている場合、優先フィールドの幅は無視され、文字列全体が結果の文字列に挿入されます)。  
  
 次の例では、文字列 "Year" といくつかの文字列を保持する6文字のフィールドと、"母集団" と "いくつかの人口データ" を格納する15文字のフィールドを定義しています。 この文字は、フィールドでは右から右に並べられていることに注意してください。  
  
 [!code-cpp[System.String.Format#33](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#33)]
 [!code-csharp[System.String.Format#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting3.cs#33)]
 [!code-vb[System.String.Format#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#33)]  
  
 ### <a name="controlling-alignment"></a>制御 (配置を)  
 既定では、フィールドの幅を指定した場合、文字列はフィールド内で右から右に並べられます。 フィールド内の文字列を左揃えにするには、フィールドの幅の先頭に負の符号`{0,-12}`を付けます。たとえば、12文字の左揃えのフィールドを定義します。  
  
 次の例は前の例と似ていますが、ラベルとデータの両方を左揃えにしている点が異なります。  
  
 [!code-cpp[System.String.Format#34](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#34)]
 [!code-csharp[System.String.Format#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#34)]
 [!code-vb[System.String.Format#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#34)]  
  
 <xref:System.String.Format%2A?displayProperty=nameWithType>複合書式指定機能を使用します。 詳細については、「[複合書式指定](~/docs/standard/base-types/composite-formatting.md)」をご覧ください。  
  
<a name="FTaskList"></a>   
## <a name="which-method-do-i-call"></a>どの方法を呼び出すか。  
  
|終了|Call|  
|--------|----------|  
|現在のカルチャの規則を使用して、1つまたは複数のオブジェクトの書式を設定します。|`provider`パラメーターを含むオーバーロードを除き、残り<xref:System.String.Format%2A>のオーバーロードには、パラメーター <xref:System.String>の後に1つ以上のオブジェクトパラメーターが続きます。 このため、どの<xref:System.String.Format%2A>オーバーロードを呼び出す必要があるかを判断する必要はありません。 言語コンパイラは、引数リストに基づいて、 `provider`パラメーターを持たないオーバーロードの中から適切なオーバーロードを選択します。 たとえば、引数リストに5つの引数がある場合、コンパイラは<xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29>メソッドを呼び出します。|  
|特定のカルチャの規則を使用して1つ以上のオブジェクトの書式を設定します。|パラメーターで始まる各<xref:System.String.Format%2A>オーバーロードには、パラメーターと1つ以上のオブジェクトパラメーターが続きます。<xref:System.String> `provider` このため、呼び出す特定<xref:System.String.Format%2A>のオーバーロードを判断する必要はありません。 言語コンパイラは、引数リストに基づいて、 `provider`パラメーターを持つオーバーロードの中から適切なオーバーロードを選択します。 たとえば、引数リストに5つの引数がある場合、コンパイラは<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29>メソッドを呼び出します。|  
|<xref:System.ICustomFormatter> 実装<xref:System.IFormattable>または実装を使用して、カスタム書式設定操作を実行します。|パラメーターを`provider`持つ4つのオーバーロードのいずれか。 コンパイラは、引数リストに基づいて、 `provider`パラメーターを持つオーバーロードの中から適切なオーバーロードを選択します。|  
  
<a name="Format_Brief"></a>   
## <a name="the-format-method-in-brief"></a>Format メソッド (brief) 

 <xref:System.String.Format%2A>メソッドの各オーバーロードは、[複合書式指定機能](~/docs/standard/base-types/composite-formatting.md)を使用して、*書式指定項目*と呼ばれる0から始まるインデックス付きプレースホルダーを複合書式指定文字列に含めます。 実行時に、各書式指定項目は、パラメーターリスト内の対応する引数の文字列形式に置き換えられます。 引数の値が`null`の場合、書式項目はに<xref:System.String.Empty?displayProperty=nameWithType>置き換えられます。 <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29>たとえば、メソッドの次の呼び出しには、3つの書式項目 ( {0}、 {1}、および{2}) を含む書式指定文字列と、3つの項目を持つ引数リストが含まれています。  
  
 [!code-cpp[System.String.Format#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload1.cpp#8)]
 [!code-csharp[System.String.Format#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload1.cs#8)]
 [!code-vb[System.String.Format#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload1.vb#8)]  
  
<a name="FormatItem"></a>   
## <a name="the-format-item"></a>書式項目  
 書式指定項目の構文は次のとおりです。  
  
```  
{index[,alignment][:formatString]}  
```  
 
 角かっこは省略可能な要素を表します。 左中かっこと終わりかっこが必要です。 書式指定文字列にリテラルの始めかっこまたは右中かっこを含めるには、「[複合書式指定](~/docs/standard/base-types/composite-formatting.md)」の記事の「[エスケープ中かっこ](~/docs/standard/base-types/composite-formatting.md#escaping-braces)」セクションを参照してください。  
  
 たとえば、通貨値を書式設定するための書式項目は、次のように表示されることがあります。  
  
 [!code-cpp[System.String.Format#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatsyntax1.cpp#12)]
 [!code-csharp[System.String.Format#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatsyntax1.cs#12)]  
 [!code-vb[System.String.Format#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatsyntax1.vb#12)]  

 書式指定項目には、次の要素があります。  
  
 *index*  
 文字列表記が文字列内のこの位置に含まれる引数の0から始まるインデックス。 この引数が`null`の場合、文字列内のこの位置に空の文字列が含まれます。  
  
 *alignment*  
 任意。 引数が挿入されるフィールドの合計長と、その引数が右揃え (正の整数) または左揃え (負の整数) であるかどうかを示す符号付き整数。 *Alignment*を省略した場合、対応する引数の文字列形式は、先頭または末尾のスペースのないフィールドに挿入されます。  
  
 *Alignment*の値が挿入する引数の長さよりも小さい場合、*アラインメント*は無視され、引数の文字列形式の長さがフィールドの幅として使用されます。  
  
 *formatString*  
 任意。 対応する引数の結果文字列の形式を指定する文字列。 *FormatString*を省略した場合、対応する引数`ToString`のパラメーターなしのメソッドが呼び出され、その文字列形式が生成されます。 *FormatString*を指定する場合、書式指定項目によって参照される<xref:System.IFormattable>引数は、インターフェイスを実装する必要があります。 書式指定文字列をサポートする型は次のとおりです。  
  
-   すべての整数型と浮動小数点型。 (「[標準の数値書式指定文字列](~/docs/standard/base-types/standard-numeric-format-strings.md)」および「[カスタム数値書式指定文字列](~/docs/standard/base-types/custom-numeric-format-strings.md)」を参照してください)。  
  
-   <xref:System.DateTime> および <xref:System.DateTimeOffset>。 (「[標準の日付と時刻の書式指定文字列](~/docs/standard/base-types/standard-date-and-time-format-strings.md)」および「[カスタム日時書式指定文字列](~/docs/standard/base-types/custom-date-and-time-format-strings.md)」を参照してください)。  
  
-   すべての列挙型。 (「[列挙型書式指定文字列](~/docs/standard/base-types/enumeration-format-strings.md)」を参照してください)。  
  
-   <xref:System.TimeSpan> 値。 (「[標準の Timespan 書式指定文字列](~/docs/standard/base-types/standard-timespan-format-strings.md)」および「[カスタム TimeSpan 書式指定文字列](~/docs/standard/base-types/custom-timespan-format-strings.md)」を参照してください)。  
  
-   GUID。 (メソッドを<xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType>参照してください)。  
  
 ただし、カスタム型では、既存の<xref:System.IFormattable>型の<xref:System.IFormattable>実装を実装または拡張できることに注意してください。  
  
 次の例では`alignment` 、 `formatString`引数と引数を使用して、書式設定された出力を生成します。  
  
 [!code-cpp[System.String.Format#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload2.cpp#9)]
 [!code-csharp[System.String.Format#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload2.cs#9)]
 [!code-vb[System.String.Format#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload2.vb#9)]  
  
<a name="HowFormatted"></a>   
## <a name="how-arguments-are-formatted"></a>引数の書式設定  
 書式項目は、文字列の先頭から順番に処理されます。 各書式指定項目には、メソッドの引数リスト内のオブジェクトに対応するインデックスがあります。 メソッド<xref:System.String.Format%2A>は、引数を取得し、文字列形式を次のように派生させることができます。  
  
-   引数が`null`の場合、メソッドは結果<xref:System.String.Empty?displayProperty=nameWithType>の文字列にを挿入します。 Null 引数<xref:System.NullReferenceException>のの処理について心配する必要はありません。 
  
-   <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29>オーバーロードを呼び出し、オブジェクトの<xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType>実装`provider`が null <xref:System.ICustomFormatter>以外の実装を返した場合、引数は<xref:System.ICustomFormatter.Format%28System.String%2CSystem.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType>メソッドに渡されます。 書式指定項目に*formatString*引数が含まれている場合は、メソッドに最初の引数として渡されます。 <xref:System.ICustomFormatter>実装が使用可能で、null 以外の文字列を生成する場合は、その文字列が引数の文字列形式として返されます。それ以外の場合は、次の手順が実行されます。  
  
-   引数が<xref:System.IFormattable>インターフェイスを実装している<xref:System.IFormattable.ToString%2A?displayProperty=nameWithType>場合は、その実装が呼び出されます。  
  
-   オーバーライドするか、 `ToString`基底クラスの実装から継承する、引数のパラメーターなしのメソッドが呼び出されます。  
  
 <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType>メソッドへの呼び出しをインターセプトし、複合書式指定文字列の書式指定項目ごと<xref:System.String.Format%2A>にメソッドが書式指定メソッドに渡す情報を確認できる例については[、「例:インターセプトプロバイダーとローマ数字フォーマッタ](#Format7_Example)。  

 詳細については、「[複合書式指定](~/docs/standard/base-types/composite-formatting.md)」の「[処理順序](~/docs/standard/base-types/composite-formatting.md##processing-order)」セクションを参照してください。  
  
<a name="SameIndex"></a>   
## <a name="format-items-that-have-the-same-index"></a>同じインデックスを持つ項目を書式設定する  
 インデックス<xref:System.String.Format%2A>項目のインデックス<xref:System.FormatException>が引数リスト内の引数の数以上の場合、メソッドは例外をスローします。 ただし、 `format`複数の書式指定項目のインデックスが同じである限り、には引数よりも多くの書式項目を含めることができます。 次の例のメソッド<xref:System.String.Format%28System.String%2CSystem.Object%29>の呼び出しでは、引数リストに1つの引数がありますが、書式指定文字列には2つの書式項目が含まれています。1つは数値の10進値を表示し、もう1つは16進数値を表示します。  
  
 [!code-csharp-interactive[System.String.Format2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example1.cs#1)]
 [!code-vb[System.String.Format2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example1.vb#1)]  
  
<a name="Format_Culture"></a>   
## <a name="formatting-and-culture"></a>書式設定とカルチャ  
 通常、引数リスト内のオブジェクトは、現在のカルチャの規則を使用して文字列形式に変換されます。これ<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>は、プロパティによって返されます。 この動作を制御するには、パラメーターを<xref:System.String.Format%2A> `provider`含むのオーバーロードのいずれかを呼び出します。 パラメーターは、書式設定プロセスをモデレートするために使用されるカスタムおよびカルチャ固有の書式設定情報を提供するの実装です。<xref:System.IFormatProvider> `provider`  
  
 インターフェイス<xref:System.IFormatProvider>には、1つの<xref:System.IFormatProvider.GetFormat%2A>メンバーがあります。これは、書式設定情報を提供するオブジェクトを返す役割を担います。 .Net には<xref:System.IFormatProvider> 、カルチャ固有の書式設定を提供する3つの実装があります。  
  
-   <xref:System.Globalization.CultureInfo>。 このメソッドは、数値を書式<xref:System.Globalization.NumberFormatInfo>設定するためのカルチャ固有のオブジェクト、および<xref:System.Globalization.DateTimeFormatInfo>日付と時刻の値を書式設定するためのカルチャ固有のオブジェクトを返します。 <xref:System.Globalization.CultureInfo.GetFormat%2A>  
  
-   <xref:System.Globalization.DateTimeFormatInfo>。日付と時刻の値のカルチャ固有の書式設定に使用されます。 その<xref:System.Globalization.DateTimeFormatInfo.GetFormat%2A>メソッドは、それ自体を返します。  
  
-   <xref:System.Globalization.NumberFormatInfo>。数値のカルチャ固有の書式設定に使用されます。 その<xref:System.Globalization.NumberFormatInfo.GetFormat%2A>プロパティは、それ自体を返します。 

<a name="Format_Custom"></a>   
## <a name="custom-formatting-operations"></a>カスタムの書式設定操作  
 また、型<xref:System.String.Format%2A> `provider`のパラメーターを持つメソッドの任意のオーバーロードを呼び出して、カスタムの書式設定操作を実行することもできます。 <xref:System.IFormatProvider> たとえば、整数を識別番号として、または電話番号として書式設定できます。 カスタム書式設定を実行する`provider`には、引数に<xref:System.IFormatProvider>インターフェイス<xref:System.ICustomFormatter>とインターフェイスの両方を実装する必要があります。 `provider` <xref:System.ICustomFormatter> <xref:System.ICustomFormatter> <xref:System.String.Format%2A>メソッドに引数として実装が渡されると、メソッドはその<xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType>実装を呼び出し、型のオブジェクトを要求します。 <xref:System.String.Format%2A> 次に、返され<xref:System.ICustomFormatter>たオブジェクト<xref:System.ICustomFormatter.Format%2A>のメソッドを呼び出して、渡された複合文字列の各書式項目を書式設定します。  
  
 カスタム書式指定ソリューションの提供の詳細につい[ては、「方法:カスタム数値書式プロバイダー](~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md)およびを<xref:System.ICustomFormatter>定義して使用します。 整数を書式設定されたカスタム数値に変換する[例については、「例:カスタムの書式設定](#Format6_Example)操作。 符号なしバイトをローマ数字に変換する例につい[ては、「例:インターセプトプロバイダーとローマ数字フォーマッタ](#Format7_Example)。  
  
<a name="Format6_Example"></a>   
### <a name="example-a-custom-formatting-operation"></a>例:カスタムの書式設定操作  
 この例では、整数値を、"x-xxxxx-xx" の形式で顧客アカウント番号として書式設定する書式プロバイダーを定義します。  
  
 [!code-cpp[System.String.Format#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample2.cpp#2)]
 [!code-csharp[System.String.Format#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/FormatExample2.cs#2)]
 [!code-vb[System.String.Format#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/FormatExample2.vb#2)]  
  
<a name="Format7_Example"></a>   
### <a name="example-an-intercept-provider-and-roman-numeral-formatter"></a>例:インターセプトプロバイダーとローマ数字フォーマッタ  
 この例では、次の2つの<xref:System.ICustomFormatter>処理<xref:System.IFormatProvider>を行うためのインターフェイスとインターフェイスを実装するカスタム書式プロバイダーを定義します。  
  
-   <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType>実装に渡されたパラメーターが表示されます。 これにより、書式設定を試行<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29>した各オブジェクトのカスタム書式設定の実装に、メソッドが渡すパラメーターを確認できます。 これは、アプリケーションをデバッグしているときに便利です。  
  
-   書式設定されるオブジェクトが、"R" 標準書式指定文字列を使用して書式設定される符号なしバイト値の場合、カスタムフォーマッタは数値をローマ数字として書式設定します。  
  
 [!code-cpp[System.String.Format#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/interceptor2.cpp#11)]
 [!code-csharp[System.String.Format#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/interceptor2.cs#11)]
 [!code-vb[System.String.Format#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/interceptor2.vb#11)]  
  
<a name="QA"></a>   
## <a name="stringformat-q--a"></a>文字列。 Q & A を書式設定します。  
  
### <a name="why-do-you-recommend-string-interpolation-over-calls-to-the-stringformat-method"></a>メソッドの呼び出しに対して文字列補間を`String.Format`推奨するのはなぜですか。

文字列補間は次のとおりです。

- より柔軟です。 複合書式指定をサポートするメソッドの呼び出しを必要とせずに、任意の文字列で使用できます。 それ以外の場合は、メソッド<xref:System.String.Format%2A> 、 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはや<xref:System.Text.StringBuilder.AppendFormat%2A?displayProperty=nameWithType>などの複合書式指定をサポートする別のメソッドを呼び出す必要があります。 

- より読みやすくなります。 文字列に挿入する式は、引数リストではなく、挿入式に含まれるので、補間文字列の方がコードや読み取りがはるかに簡単になります。 より読みやすくなっているため、補間文字列は複合書式指定メソッドの呼び出しだけでなく、より簡潔で明確なコードを生成するために文字列連結操作でも使用できます。 

次の2つのコード例は、文字列の連結と複合書式指定メソッドの呼び出しに対する補間文字列の優位性を示しています。 次の例では、複数の文字列連結演算を使用して、詳細なコードと読み取り専用のコードを作成します。

[!code-csharp[non-interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated1.cs#QAInterpolated)]
[!code-vb[non-interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated1.vb)]  

これに対し、次の例では、挿入文字列を使用して、文字列連結ステートメントと前の例のメソッドの<xref:System.String.Format%2A>呼び出しよりも、より明確で簡潔なコードを生成します。

[!code-csharp[interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated2.cs#QAInterpolated2)]
[!code-vb[interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated2.vb)]  

### <a name="where-can-i-find-a-list-of-the-predefined-format-strings-that-can-be-used-with-format-items"></a>書式項目と共に使用できる定義済みの書式指定文字列の一覧はどこで確認できますか。  
  
-   すべての整数型と浮動小数点型については、「[標準の数値書式指定文字列](~/docs/standard/base-types/standard-numeric-format-strings.md)」および「[カスタム数値書式指定文字列](~/docs/standard/base-types/custom-numeric-format-strings.md)」を参照してください。  
  
-   日付と時刻の値については、「[標準の日付と時刻の書式指定文字列](~/docs/standard/base-types/standard-date-and-time-format-strings.md)」および「[カスタム日時書式指定文字列](~/docs/standard/base-types/custom-date-and-time-format-strings.md)」を参照してください。  
  
-   列挙値については、「[列挙型書式指定文字列](~/docs/standard/base-types/enumeration-format-strings.md)」を参照してください。  
  
-   値<xref:System.TimeSpan>については、「[標準の timespan 書式指定文字列](~/docs/standard/base-types/standard-timespan-format-strings.md)」および「[カスタム TimeSpan 書式指定文字列](~/docs/standard/base-types/custom-timespan-format-strings.md)」を参照してください。  
  
-   値<xref:System.Guid>については、 <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType>リファレンスページの「解説」を参照してください。  
  
### <a name="how-do-i-control-the-alignment-of-the-result-strings-that-replace-format-items"></a>書式項目を置き換える結果文字列の配置を制御操作方法には  
 書式項目の一般的な構文は次のとおりです。  
  
```  
{index[,alignment][: formatString]}  
```  
  
 *alignment*は、フィールドの幅を定義する符号付き整数です。 この値が負の場合、フィールド内のテキストは左揃えになります。 正の場合、テキストは右に固定されます。  
  
### <a name="how-do-i-control-the-number-of-digits-after-the-decimal-separator"></a>小数点区切り文字の後に桁数を制御操作方法には、  
 "D" を除くすべての[標準の数値書式指定文字列](~/docs/standard/base-types/standard-numeric-format-strings.md)(整数のみで使用)、"G"、"R"、および "X" を使用すると、結果文字列の小数点以下の桁数を定義する精度指定子を使用できます。 次の例では、標準の数値書式指定文字列を使用して、結果文字列の小数点以下桁数を制御します。  
  
 [!code-csharp[System.String.Format#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa26.cs#26)]
 [!code-vb[System.String.Format#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa26.vb#26)]  
  
 [カスタム数値書式指定文字列](~/docs/standard/base-types/custom-numeric-format-strings.md)を使用している場合は、次の例に示すように、"0" 書式指定子を使用して、結果文字列の小数点以下の桁数を制御します。  
  
 [!code-csharp-interactive[System.String.Format#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa27.cs#27)]
 [!code-vb[System.String.Format#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa27.vb#27)]  
  
### <a name="how-do-i-control-the-number-of-integral-digits"></a>整数の桁数を制御操作方法には  
 既定では、書式設定操作には0以外の整数の数字のみが表示されます。 整数を書式設定する場合は、"D" および "X" の標準書式指定文字列で精度指定子を使用して、桁数を制御できます。  
  
 [!code-csharp-interactive[System.String.Format#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa29.cs#29)]
 [!code-vb[System.String.Format#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa29.vb#29)]  
  
 次の例に示すように、"0"[カスタム数値書式指定子](~/docs/standard/base-types/custom-numeric-format-strings.md)を使用して、整数または浮動小数点数を先行ゼロで埋め込んで、指定された数の整数を含む結果文字列を生成することができます。  
  
 [!code-csharp-interactive[System.String.Format#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa28.cs#28)]
 [!code-vb[System.String.Format#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa28.vb#28)]  
  
### <a name="how-many-items-can-i-include-in-the-format-list"></a>[書式] の一覧に含めることができる項目の数はいくつですか。  
 実際の制限はありません。 <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29>メソッドの2番目のパラメーターには<xref:System.ParamArrayAttribute>属性がタグ付けされます。これにより、区切り記号付きリストまたはオブジェクト配列を書式リストとして含めることができます。  
  
<a name="braces"></a>
### <a name="how-do-i-include-literal-braces--and--in-the-result-string"></a>結果の文字列にリテラルの中かっこ ("{" および "}") を含める操作方法  
 たとえば、次のメソッド呼び出しによって例外が<xref:System.FormatException>スローされないようにするには、どうすればよいでしょうか。  
  
 [!code-csharp[System.String.Format#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#23)]
 [!code-vb[System.String.Format#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#23)]  
  
 1つの左中かっこまたは右中かっこは、書式指定項目の先頭または末尾として常に解釈されます。 文字どおりに解釈されるようにするには、エスケープする必要があります。 かっこをエスケープするには、次のメソッド呼び出しのように、別の中かっこ ("{" および "}" ではなく "{{" および "}}") を追加します。  
  
 [!code-csharp-interactive[System.String.Format#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#24)]
 [!code-vb[System.String.Format#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#24)]  
  
 ただし、エスケープされた中かっこも簡単に解釈できます。 次の例に示すように、書式設定の一覧に中かっこを含め、書式項目を使用して結果の文字列に挿入することをお勧めします。  
  
 [!code-csharp-interactive[System.String.Format#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#25)]
 [!code-vb[System.String.Format#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#25)]  
  
### <a name="why-does-my-call-to-the-stringformat-method-throw-a-formatexception"></a>FormatException メソッドを呼び出すと、そのような例外がスローされるのはなぜですか。  
 例外の最も一般的な原因として、書式項目のインデックスが [書式] リストのオブジェクトに対応していないことが挙げられます。 通常、これは、書式項目のインデックスに番号が付けられていないか、[書式] ボックスの一覧にオブジェクトが含まれていないことを示します。 エスケープされていない左または右の中かっこ<xref:System.FormatException>文字を含めようとすると、もスローされます。 場合によっては、例外が発生することがあります。たとえば、一般的な誤りは、"{" (左中かっこ) ではなく "[" (左角かっこ) を誤って間違えてしまうことです。  
  
### <a name="if-the-formatsystemiformatprovidersystemstringsystemobject-method-supports-parameter-arrays-why-does-my-code-throw-an-exception-when-i-use-an-array"></a>Format (IFormatProvider, System.string, System.object []) メソッドがパラメーター配列をサポートしている場合、配列を使用すると、コードで例外がスローされるのはなぜですか。  
 たとえば、次のコードでは例外<xref:System.FormatException>がスローされます。  
  
 [!code-csharp[System.String.Format#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa1.cs#21)]
 [!code-vb[System.String.Format#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa1.vb#21)]  
  
 これは、コンパイラのオーバーロードの解決に問題があります。 コンパイラは整数の配列をオブジェクト配列に変換できないので、整数配列を1つの引数として扱います。 <xref:System.String.Format%28System.String%2CSystem.Object%29>そのため、メソッドを呼び出します。 この例外がスローされるのは、書式指定項目が4つありますが、書式一覧に項目が1つしかないためです。  
  
 Visual Basic もC#整数配列もオブジェクト配列に変換できないため、 <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29>メソッドを呼び出す前に、変換を自分で実行する必要があります。 次の例では、1つの実装を示します。  
  
 [!code-csharp-interactive[System.String.Format#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa2.cs#22)]
 [!code-vb[System.String.Format#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa2.vb#22)]  

## Examples

この記事の「 <xref:System.String.Format%2A> [解説](#remarks-top)」では、メソッドを呼び出す多くの例を示しています。  

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

また、 [dotnet/samples GitHub リポジトリ](https://github.com/dotnet/samples)から`String.Format` 、[のC# .net core 2.0 プロジェクト](https://github.com/dotnet/samples/raw/master/snippets/csharp/downloads/api/System/String.Format.zip)と[Visual Basic 用の .net core 2.0 プロジェクト](https://github.com/dotnet/samples/raw/master/snippets/visualbasic/downloads/api/System/String.Format.zip)が含まれている例の完全なセットをダウンロードすることもできます。

記事に含まれている例の一部を次に示します。

### <a name="create-a-format-string"></a>書式指定文字列の作成

[文字列の挿入](#inserting-a-string)  
[書式項目](#the-format-item)  
[同じインデックスを持つ項目を書式設定する](#format-items-that-have-the-same-index)

### <a name="control-formatted-output"></a>書式設定された出力の制御

[書式設定の制御](#controlling-formatting)  
[制御 (間隔を)](#controlling-spacing)  
[制御 (配置を)](#controlling-alignment)  
[整数部の桁数を制御する](#how-do-i-control-the-number-of-integral-digits)  
[小数点区切り文字の後の桁数を制御する](#how-do-i-control-the-number-of-digits-after-the-decimal-separator)  
[結果の文字列にリテラルの中かっこを含める](#braces)  

### <a name="make-format-strings-culture-sensitive"></a>書式指定文字列のカルチャを区別する

[カルチャに依存した書式設定](#culture-sensitive-formatting)  

### <a name="customize-the-formatting-operation"></a>書式設定操作をカスタマイズする

[カスタムの書式設定操作](#example-a-custom-formatting-operation)  
[インターセプトプロバイダーとローマ数字フォーマッタ](#example-an-intercept-provider-and-roman-numeral-formatter)  

 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET での型の書式設定</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">複合書式指定</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">標準の日時書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">カスタム日時書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">標準の数値書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">カスタム数値書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">標準 TimeSpan 書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">カスタム時間間隔書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">列挙型書式指定文字列</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj -&gt; string" Usage="System.string.Format (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">[複合書式設定文字列](~/docs/standard/base-types/composite-formatting.md)。</param>
        <param name="arg0">書式指定するオブジェクト。</param>
        <summary>文字列の 1 つ以上の書式項目を、指定されたオブジェクトの文字列表記に置換します。</summary>
        <returns>書式項目が <paramref name="format" /> の文字列形式に置換された <paramref name="arg0" /> のコピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
このメソッドは、[複合書式指定機能](~/docs/standard/base-types/composite-formatting.md)を使用して、式の値を文字列形式に変換し、その表現を文字列に埋め込みます。 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-a-single-argument"></a>例:1つの引数の書式設定  
 
 次の例では<xref:System.String.Format%28System.String%2CSystem.Object%29> 、メソッドを使用して、文字列の途中に個別の年齢を埋め込みます。  
  
 [!code-cpp[System.String.Format#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format7.cpp#7)]
 [!code-csharp-interactive[System.String.Format#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format7.cs#7)]
 [!code-vb[System.String.Format#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format7.vb#7)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> の書式指定項目が正しくありません。  
  
または 
書式項目のインデックスが 0 ではありません。</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET での型の書式設定</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">複合書式指定</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">標準の日時書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">カスタム日時書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">標準の数値書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">カスタム数値書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">標準 TimeSpan 書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">カスタム時間間隔書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">列挙型書式指定文字列</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj[] -&gt; string" Usage="System.string.Format (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">[複合書式設定文字列](~/docs/standard/base-types/composite-formatting.md)。</param>
        <param name="args">0 個以上の書式設定対象オブジェクトを含んだオブジェクト配列。</param>
        <summary>指定した文字列の書式項目を、指定した配列内の対応するオブジェクトの文字列形式に置換します。</summary>
        <returns>書式項目が <paramref name="args" /> の対応するオブジェクトの文字列表記に置換された <paramref name="format" /> のコピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
このメソッドは、[複合書式指定機能](~/docs/standard/base-types/composite-formatting.md)を使用して、4つ以上の式の値を文字列形式に変換し、それらの表現を文字列に埋め込みます。 パラメーターは<xref:System.ParamArrayAttribute?displayProperty=nameWithType>属性でマークされているため、オブジェクトを<xref:System.Object>個々の引数として、または配列としてメソッドに渡すことができます。 `args` 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-more-than-three-arguments"></a>例:3つ以上の引数の書式設定  
 
 この例では、特定の日付の高および低気温に関するデータを格納する文字列を作成します。 複合書式指定文字列には、 C#例では5つの書式項目があり、Visual Basic の例では6個の書式項目があります。 2つの書式項目は、対応する値の文字列表現の幅を定義し、最初の書式指定項目には標準の日時書式指定文字列も含まれます。  
  
 [!code-cpp[System.String.Format#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format5.cpp#5)]
 [!code-csharp[System.String.Format#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format5.cs#5)]
 [!code-vb[System.String.Format#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format5.vb#5)]  
  
 また、オブジェクトを引数リストとしてではなく配列として渡すこともできます。  
  
 [!code-cpp[System.String.Format#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format_paramarray1.cpp#10)]
 [!code-csharp[System.String.Format#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format_paramarray1.cs#10)]
 [!code-vb[System.String.Format#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format_paramarray1.vb#10)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> または <paramref name="args" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> が無効です。  
  
または 
書式項目のインデックスが 0 (ゼロ) 未満か、または <paramref name="args" /> 配列の長さ以上です。</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET での型の書式設定</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">複合書式指定</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">標準の日時書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">カスタム日時書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">標準の数値書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">カスタム数値書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">標準 TimeSpan 書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">カスタム時間間隔書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">列挙型書式指定文字列</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj -&gt; string" Usage="System.string.Format (provider, format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <param name="format">[複合書式設定文字列](~/docs/standard/base-types/composite-formatting.md)。</param>
        <param name="arg0">書式指定するオブジェクト。</param>
        <summary>指定した文字列の 1 つまたは複数の書式項目を、対応するオブジェクトの文字列形式に置換します。 パラメーターにより、カルチャに固有の書式情報が指定されます。</summary>
        <returns>書式項目が <paramref name="format" /> の文字列形式に置換された <paramref name="arg0" /> のコピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
このメソッドは、[複合書式指定機能](~/docs/standard/base-types/composite-formatting.md)を使用して、式の値を文字列形式に変換し、その表現を文字列に埋め込みます。 変換を実行する場合、メソッドはカルチャに依存した書式設定またはカスタムフォーマッタを使用します。 メソッドは、 `arg0` **tostring (IFormatProvider)** メソッドを呼び出すことによって文字列形式に変換します。または、オブジェクトの対応する書式指定項目に、その**tostring (string, IFormatProvider)** を呼び出すことによって書式文字列が含まれている場合は、を呼び出します。b. これらのメソッドが存在しない場合は、オブジェクトのパラメーターなしの**ToString**メソッドを呼び出します。  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> が無効です。  
  
- または - 
書式項目のインデックスが 0 ではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj[] -&gt; string" Usage="System.string.Format (provider, format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <param name="format">[複合書式設定文字列](~/docs/standard/base-types/composite-formatting.md)。</param>
        <param name="args">0 個以上の書式設定対象オブジェクトを含んだオブジェクト配列。</param>
        <summary>文字列の書式項目を、指定した配列内の対応するオブジェクトの文字列表記に置換します。 パラメーターにより、カルチャに固有の書式情報が指定されます。</summary>
        <returns>書式項目が <paramref name="args" /> の対応するオブジェクトの文字列表記に置換された <paramref name="format" /> のコピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
このメソッドは、[複合書式指定機能](~/docs/standard/base-types/composite-formatting.md)を使用して、4つ以上の式を文字列形式に変換し、それらの表現を文字列に埋め込みます。 変換を実行する場合、メソッドはカルチャに依存した書式設定またはカスタムフォーマッタを使用します。 メソッドは、 <xref:System.Object> **tostring (IFormatProvider)** メソッドを呼び出すことによって各引数を文字列形式に変換します。または、オブジェクトの対応する書式指定項目に**tostring (string,IFormatProvider)** メソッド。 これらのメソッドが存在しない場合は、オブジェクトのパラメーターなしの**ToString**メソッドを呼び出します。  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]

<a name="culture-sensitive-formatting" /> 

### <a name="example-culture-sensitive-formatting"></a>例:カルチャに依存した書式設定

 この例では<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> 、メソッドを使用して、いくつかの異なるカルチャを使用して、一部の日付と時刻の値と数値の文字列形式を表示します。  
  
 [!code-csharp-interactive[System.String.Format2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example2.cs#2)]
 [!code-vb[System.String.Format2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example2.vb#2)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> または <paramref name="args" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> が無効です。  
  
- または - 
書式項目のインデックスが 0 (ゼロ) 未満か、または <paramref name="args" /> 配列の長さ以上です。</exception>
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="T:System.ICustomFormatter" />
        <altmember cref="T:System.IFormatProvider" />
        <altmember cref="T:System.Globalization.NumberFormatInfo" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET での型の書式設定</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">複合書式指定</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">標準の日時書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">カスタム日時書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">標準の数値書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">カスタム数値書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">標準 TimeSpan 書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">カスタム時間間隔書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">列挙型書式指定文字列</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">[複合書式設定文字列](~/docs/standard/base-types/composite-formatting.md)。</param>
        <param name="arg0">1 番目に書式設定するオブジェクト。</param>
        <param name="arg1">2 番目に書式設定するオブジェクト。</param>
        <summary>文字列の書式項目を、指定した 2 つのオブジェクトの文字列形式に置換します。</summary>
        <returns>書式項目が <paramref name="arg0" /> と <paramref name="arg1" /> の文字列形式に置換された <paramref name="format" /> のコピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
このメソッドは、[複合書式指定機能](~/docs/standard/base-types/composite-formatting.md)を使用して、2つの式の値を文字列形式に変換し、それらの表現を文字列に埋め込みます。 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-two-arguments"></a>例:2つの引数の書式設定  
 
 この例では<xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29> 、メソッドを使用して、ジェネリック<xref:System.Collections.Generic.Dictionary%602>オブジェクトに格納されている時間と気温のデータを表示します。 書式指定文字列には3つの書式項目があることに注意してください。ただし、書式設定するオブジェクトは2つだけです。 これは、リスト内の最初のオブジェクト (日付と時刻の値) が2つの書式指定項目によって使用されるためです。最初の書式項目には時刻が表示され、2番目の書式項目には日付が表示されます。  
  
 [!code-cpp[System.String.Format#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample4.cpp#6)]
 [!code-csharp[System.String.Format#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatexample4.cs#6)]
 [!code-vb[System.String.Format#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatexample4.vb#6)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> が無効です。  
  
- または - 
書式項目のインデックスが 0 でも 1 でもありません。</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET での型の書式設定</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">複合書式指定</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">標準の日時書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">カスタム日時書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">標準の数値書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">カスタム数値書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">標準 TimeSpan 書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">カスタム時間間隔書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">列挙型書式指定文字列</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <param name="format">[複合書式設定文字列](~/docs/standard/base-types/composite-formatting.md)。</param>
        <param name="arg0">1 番目に書式設定するオブジェクト。</param>
        <param name="arg1">2 番目に書式設定するオブジェクト。</param>
        <summary>文字列の書式項目を、指定した 2 つのオブジェクトの文字列形式に置換します。 パラメーターにより、カルチャに固有の書式情報が指定されます。</summary>
        <returns>書式項目が <paramref name="arg0" /> と <paramref name="arg1" /> の文字列形式に置換された <paramref name="format" /> のコピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
このメソッドは、[複合書式指定機能](~/docs/standard/base-types/composite-formatting.md)を使用して、2つの式を文字列形式に変換し、それらの表現を文字列に埋め込みます。 変換を実行する場合、メソッドはカルチャに依存した書式設定またはカスタムフォーマッタを使用します。 メソッドは、 <xref:System.Object> **tostring (IFormatProvider)** メソッドを呼び出すことによって各引数を文字列形式に変換します。または、オブジェクトの対応する書式指定項目に**tostring (string,IFormatProvider)** メソッド。 これらのメソッドが存在しない場合は、オブジェクトのパラメーターなしの**ToString**メソッドを呼び出します。  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> が無効です。  
  
または 
書式項目のインデックスが 0 でも 1 でもありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">[複合書式設定文字列](~/docs/standard/base-types/composite-formatting.md)。</param>
        <param name="arg0">1 番目に書式設定するオブジェクト。</param>
        <param name="arg1">2 番目に書式設定するオブジェクト。</param>
        <param name="arg2">3 番目に書式設定するオブジェクト。3 番目に書式設定するオブジェクト。</param>
        <summary>文字列の書式項目を、指定した 3 つのオブジェクトの文字列形式に置換します。</summary>
        <returns>書式項目が <paramref name="format" />、<paramref name="arg0" />、および <paramref name="arg1" /> の文字列形式に置換された <paramref name="arg2" /> のコピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
このメソッドは、[複合書式指定機能](~/docs/standard/base-types/composite-formatting.md)を使用して、3つの式の値を文字列形式に変換し、それらの表現を文字列に埋め込みます。 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-three-arguments"></a>例:3つの引数の書式設定  
 
 この例では<xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> 、メソッドを使用して、2つの整数値`And`を持つブール演算の結果を示す文字列を作成します。 書式指定文字列には6つの書式項目が含まれていますが、各項目は2つの異なる方法で書式設定されるため、メソッドのパラメーターリストには3つの項目しかありません。  
  
 [!code-cpp[System.String.Format#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format4.cpp#4)]
 [!code-csharp-interactive[System.String.Format#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format4.cs#4)]
 [!code-vb[System.String.Format#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format4.vb#4)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> が無効です。  
  
または 
書式項目のインデックスが 0 より小さいか、または 2 より大きい値です。</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET での型の書式設定</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">複合書式指定</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <param name="format">[複合書式設定文字列](~/docs/standard/base-types/composite-formatting.md)。</param>
        <param name="arg0">1 番目に書式設定するオブジェクト。</param>
        <param name="arg1">2 番目に書式設定するオブジェクト。</param>
        <param name="arg2">3 番目に書式設定するオブジェクト。3 番目に書式設定するオブジェクト。</param>
        <summary>文字列の書式項目を、指定した 3 つのオブジェクトの文字列形式に置換します。 パラメーターにより、カルチャに固有の書式設定情報を指定します。</summary>
        <returns>書式項目が <paramref name="format" />、<paramref name="arg0" />、および <paramref name="arg1" /> の文字列形式に置換された <paramref name="arg2" /> のコピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
このメソッドは、[複合書式指定機能](~/docs/standard/base-types/composite-formatting.md)を使用して、3つの式を文字列形式に変換し、それらの表現を文字列に埋め込みます。 変換を実行する場合、メソッドはカルチャに依存した書式設定またはカスタムフォーマッタを使用します。 メソッドは、 <xref:System.Object> **tostring (IFormatProvider)** メソッドを呼び出すことによって各引数を文字列形式に変換します。または、オブジェクトの対応する書式指定項目に**tostring (string,IFormatProvider)** メソッド。 これらのメソッドが存在しない場合は、オブジェクトのパラメーターなしの**ToString**メソッドを呼び出します。  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> が無効です。  
  
または 
書式項目のインデックスが 0 より小さいか、または 2 より大きい値です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public CharEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.CharEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As CharEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CharEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; CharEnumerator" Usage="string.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CharEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この文字列に含まれる個々の文字を反復処理するオブジェクトを取得します。</summary>
        <returns>列挙子オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
> 文字列を列挙する<xref:System.String.GetEnumerator%2A>ために使用する<xref:System.CharEnumerator>オブジェクトを取得するためにメソッドを呼び出すのではなく、代わりに、言語の反復構造をC#使用するC++必要があります (では、/clr の場合は、Visual Basic)。 [foreach](~/docs/csharp/language-reference/keywords/foreach-in.md) in C#、for [each](/cpp/dotnet/for-each-in) C++、および Visual Basic) [](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md) 。
  
 このメソッドを使用すると、文字列内の個々の文字を反復処理できます。 たとえば、Visual Basic `For Each`およびC# `foreach`ステートメントは、このメソッドを呼び出して、 <xref:System.CharEnumerator>この文字列インスタンス内の文字への読み取り専用アクセスを提供できるオブジェクトを返します。  
  
   
  
## Examples  
 次の例では、複数の文字列の文字を反復処理し、個々の文字についての情報を表示します。 このメソッドは、メソッドの<xref:System.String.GetEnumerator%2A>呼び出しではなく、言語イテレーション構成を使用します。  
  
 [!code-cpp[system.string.getenumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetEnumerator/CPP/getenumerator.cpp#1)]
 [!code-csharp[system.string.getenumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetEnumerator/CS/getenumerator.cs#1)]
 [!code-vb[system.string.getenumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetEnumerator/VB/getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
        <altmember cref="T:System.Collections.IEnumerable" />
        <altmember cref="P:System.String.Chars(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="string.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この文字列のハッシュ コードを返します。</summary>
        <returns>32 ビット符号付き整数ハッシュ コード。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 の<xref:System.String.GetHashCode%2A>動作は、実装によって異なります。これは、共通言語ランタイムのあるバージョンから別のバージョンに変更される可能性があります。 これが発生する理由は、の<xref:System.String.GetHashCode%2A>パフォーマンスを向上させるためです。  
  
> [!IMPORTANT]
>  2つの文字列オブジェクトが等しい場合<xref:System.String.GetHashCode%2A> 、メソッドは同一の値を返します。 ただし、一意の文字列値ごとに一意のハッシュコード値はありません。 異なる文字列は、同じハッシュコードを返すことができます。  
>   
>  ハッシュコード自体は、安定しているとは限りません。 同じ文字列のハッシュコードは、.net の実装間、.net の複数のバージョン間、.net の1つのバージョンの .net プラットフォーム (32 ビットや64ビットなど) で異なる場合があります。 場合によっては、アプリケーションドメインによって異なる場合もあります。 これは、同じプログラムの2回目の実行で異なるハッシュコードが返される可能性があることを意味します。  
>   
>  このため、ハッシュコードは、作成されたアプリケーションドメインの外部では使用できません。また、コレクションのキーフィールドとして使用することは避け、永続化しないでください。  
>   
>  最後に、暗号ハッシュ関数によって返される値の代わりに、暗号強度の高いハッシュが必要な場合は、ハッシュコードを使用しないでください。 暗号化ハッシュの場合<xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType>は、クラスまたは<xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType>クラスから派生したクラスを使用します。  
>   
>  ハッシュコードの詳細については<xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>、「」を参照してください。  
  
 デスクトップアプリでは、 [ \<UseRandomizedStringHashAlgorithm > 要素](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)を使用して、アプリケーションドメインごとに一意のハッシュコードを生成できます。 これにより、競合の数を減らし、ハッシュテーブルを使用する挿入と参照の全体的なパフォーマンスを向上させることができます。 次の例は、 [ \<UseRandomizedStringHashAlgorithm > 要素](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)の使用方法を示しています。 このクラスは`DisplayString` 、プライベート文字列`s`定数を含むクラスを定義します。値は "This is a string" です。 また、メソッドを実行しているアプリケーション ドメインの名前と共に文字列値とハッシュ コードを表示する `ShowStringHashCode` メソッドも含まれています。
  
 [!code-csharp[System.String.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/perdomain.cs#2)]
 [!code-vb[System.String.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/perdomain.vb#2)]  
  
 構成ファイルを指定せずにこの例を実行すると、次のような出力が表示されます。 文字列のハッシュ コードが 2 つアプリケーション ドメインで同じであることに注意してください。  
  
```
String 'This is a string.' in domain 'PerDomain.exe': 941BCEAC  
String 'This is a string.' in domain 'NewDomain': 941BCEAC
```  
  
 ただし、例のディレクトリに次の構成ファイルを追加して例を実行すると、同じ文字列のハッシュ コードがアプリケーション ドメインによって異なります。  
  
```xml
<?xml version ="1.0"?>  
<configuration>  
   <runtime>  
      <UseRandomizedStringHashAlgorithm enabled="1" />  
   </runtime>  
</configuration>
```  
  
 構成ファイルが存在する場合、次の出力が表示されます。  
  
```  
String 'This is a string.' in domain 'PerDomain.exe': 5435776D
String 'This is a string.' in domain 'NewDomain': 75CC8236
```  
  
> [!IMPORTANT]
>  ハッシュ コードは、ハッシュ テーブルからキーを持つオブジェクトを効率的に挿入および取得するために使用されます。 ただし、ハッシュ コードは、文字列を一意に識別しません。 同一の文字列は同じハッシュコードを持ちますが、共通言語ランタイムは同じハッシュコードを異なる文字列に割り当てることもできます。 さらに、ハッシュコードは、.NETのバージョン、単一バージョンでプラットフォームとアプリケーション ドメインを変更できます。 このため、ハッシュコードの値をシリアル化したり永続化したり、ハッシュテーブルまたはディクショナリのキーとして使用したりしないでください。  
  
 ハッシュコードと`GetHashCode`メソッドの使用方法の詳細については、 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>「」を参照してください。  
  
   
  
## Examples  
 次の例は、 <xref:System.String.GetHashCode%2A>さまざまな入力文字列を使用してメソッドを示しています。  
  
 [!code-cpp[system.string.gethashcode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetHashCode/CPP/gethashcode.cpp#1)]
 [!code-csharp[system.string.gethashcode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/gethashcode.cs#1)]
 [!code-vb[system.string.gethashcode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/gethashcode.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>によって<see cref="M:System.String.GetHashCode" />返される値は、プラットフォームに依存します。 これは、.NET Framework の32ビットバージョンと64ビットバージョンで異なります。 また、.NET Framework と .NET Core のバージョンによって異なる場合もあります。</para></block>
        <altmember cref="M:System.Object.GetHashCode" />
        <related type="Article" href="https://msdn.microsoft.com/library/c08125d6-56cc-4b23-b482-813ff85dc630">&lt;UseRandomizedStringHashAlgorithm&gt;要素</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public static int GetHashCode (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHashCode(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHashCode (value As ReadOnlySpan(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetHashCode(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="static member GetHashCode : ReadOnlySpan&lt;char&gt; -&gt; int" Usage="System.string.GetHashCode value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">読み取り専用の文字スパン。</param>
        <summary>指定された読み取り専用文字スパンのハッシュ コードを返します。</summary>
        <returns>32 ビット符号付き整数ハッシュ コード。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public int GetHashCode (StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetHashCode(valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetHashCode (comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetHashCode(StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : StringComparison -&gt; int" Usage="string.GetHashCode comparisonType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="comparisonType">比較で使用する規則を指定する列挙値の 1 つ。</param>
        <summary>指定された規則を使用して、この文字列のハッシュ コードを返します。</summary>
        <returns>32 ビット符号付き整数ハッシュ コード。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public static int GetHashCode (ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHashCode(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.ReadOnlySpan{System.Char},System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHashCode (value As ReadOnlySpan(Of Char), comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetHashCode(ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member GetHashCode : ReadOnlySpan&lt;char&gt; * StringComparison -&gt; int" Usage="System.string.GetHashCode (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">読み取り専用の文字スパン。</param>
        <param name="comparisonType">比較で使用する規則を指定する列挙値の 1 つ。</param>
        <summary>指定された規則を使用して、指定された読み取り専用の文字スパンのハッシュ コードを返します。</summary>
        <returns>32 ビット符号付き整数ハッシュ コード。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPinnableReference">
      <MemberSignature Language="C#" Value="public ref readonly char GetPinnableReference ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.char GetPinnableReference() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetPinnableReference" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPinnableReference () As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; char ^ GetPinnableReference();" />
      <MemberSignature Language="F#" Value="member this.GetPinnableReference : unit -&gt; char" Usage="string.GetPinnableReference " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Char</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="netcore-3.0">
            <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>インデックス 0 にある文字列の要素への参照を返します。</summary>
        <returns>インデックス 0 にある文字列の要素への参照を表す文字。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

メソッド`GetPinnableReference`は、を<xref:System.String>メモリにピン留めするために使用できる文字を返します。 これは、fixed ステートメント<xref:System.String>内でのの使用をサポートするために必要です。

          ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">文字列が null です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="string.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.TypeCode" /> クラスには <see cref="T:System.String" /> を返します。</summary>
        <returns>列挙型定数 <see cref="F:System.TypeCode.String" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では<xref:System.TypeCode> 、 <xref:System.String>型の列挙定数を表示します。  
  
 [!code-cpp[string.gettypecode#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.gettypecode/CPP/gtc.cpp#1)]
 [!code-csharp[string.gettypecode#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.gettypecode/CS/gtc.cs#1)]
 [!code-vb[string.gettypecode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.gettypecode/VB/gtc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このインスタンス内で最初に出現する指定 Unicode 文字または文字列の 0 から始まるインデックスをレポートします。 このインスタンス内で文字または文字列が見つからない場合、このメソッドは -1 を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">シークする Unicode 文字。</param>
        <summary>指定した Unicode 文字がこの文字列内で最初に見つかった位置の 0 から始まるインデックスをレポートします。</summary>
        <returns>その文字が見つかった場合は、<paramref name="value" /> の 0 から始まるインデックスでの位置。見つからなかった場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は0から始まります。  
  
 このメソッドは、Unicode スカラー値が同じである場合にのみ、文字が別の文字と等価であると見なされる序数 (カルチャに依存しない) 検索を実行します。 カルチャに依存した検索を実行するに<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>は、メソッドを使用します。この場合、合字の "Æ" (U + 00c6) などの構成されていない文字を表す Unicode スカラー値は、カルチャに応じて、"AE" (U + 0041 という, U + 0045) などの正しいシーケンス。  
  
   
  
## Examples  
 次の例では<xref:System.String> 、 <xref:System.String.IndexOf%2A>メソッドを使用して文字を検索する方法を示します。  
  
 [!code-cpp[System.String.IndexOf#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexof_c.cpp#5)]
 [!code-csharp[System.String.IndexOf#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexof_c.cs#5)]
 [!code-vb[System.String.IndexOf#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexof_c.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <summary>指定された文字列がこのインスタンス内で最初に見つかった位置の 0 から始まるインデックスをレポートします。</summary>
        <returns>その文字列が見つかった場合は、<paramref name="value" /> の 0 から始まるインデックスでの位置。見つからなかった場合は -1。 <paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値は 0 です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は0から始まります。  
  
 このメソッドは、現在のカルチャを使用して、単語 (大文字と小文字を区別し、カルチャに依存する) 検索を実行します。 検索は、このインスタンスの最初の文字位置から開始し、最後の文字位置まで続行されます。  
  
 文字セットには無視できる文字が含まれています。これらの文字は、言語またはカルチャに依存した比較を実行する際には考慮されません。 カルチャに依存した検索では、`value` に無視できる文字が含まれている場合、その文字を削除して検索した場合と同じ結果になります。 が`value` 1 つ以上の無視できる文字のみで構成<xref:System.String.IndexOf%28System.String%29>されている場合、メソッドは常に 0 (ゼロ) を返して、現在のインスタンスの先頭で一致が見つかったことを示します。 次の例では、 <xref:System.String.IndexOf%28System.String%29>メソッドを使用して、2つの文字列の3つの部分文字列 (ソフトハイフン (U + 00ad)、ソフトハイフンの後に "n"、ソフトハイフンの後に "m") を検索します。 文字列の 1 つのみにソフト ハイフンが含まれます。 この例が以降で[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]実行されている場合、ソフトハイフンが無視できない文字であるため、結果はに`value`ソフトハイフンが含まれていなかった場合と同じになります。 ソフトハイフンのみを検索する場合、メソッドは、文字列の先頭に一致するものが見つかったことを示す 0 (ゼロ) を返します。  
  
 [!code-csharp[System.String.IndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable21.cs#21)]
 [!code-vb[System.String.IndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable21.vb#21)]  
  
   
  
## Examples  
 次の例では、"animal" の "n" を検索します。 文字列インデックスは1ではなく0から始まるの<xref:System.String.IndexOf%28System.String%29>で、メソッドは "n" が位置1にあることを示します。  
  
 [!code-cpp[System.String.IndexOf#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/simple1.cpp#12)]
 [!code-csharp[System.String.IndexOf#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/simple1.cs#12)]
 [!code-vb[System.String.IndexOf#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/simple1.vb#12)]  
  
 次の例では<xref:System.String.IndexOf%2A> 、メソッドを使用して、文に含まれる動物名の開始位置を決定します。 次に、この位置を使用して、動物を記述する形容詞を文に挿入します。  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> が <see langword="null" /> です。</exception>
        <block subset="none" type="usage"><para>「[文字列を使用するためのベストプラクティス](~/docs/standard/base-types/best-practices-strings.md)」で説明したように、既定値を置き換える文字列比較メソッドを呼び出さずに、パラメーターを明示的に指定する必要があるメソッドを呼び出すことを避けることをお勧めします。 現在のカルチャの比較規則を使用して、文字列インスタンス内の部分文字列の最初のインデックスを検索する<see cref="M:System.String.IndexOf(System.String,System.StringComparison)" />には、 `comparisonType`パラメーター <see cref="F:System.StringComparison.CurrentCulture" />の値がであるメソッドオーバーロードを呼び出します。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">シークする Unicode 文字。</param>
        <param name="startIndex">検索が開始される位置。</param>
        <summary>指定した Unicode 文字がこの文字列内で最初に見つかった位置の 0 から始まるインデックスをレポートします。 検索は、指定した文字位置から開始されます。</summary>
        <returns>その文字が見つかった場合は、文字列の先頭からの、<paramref name="value" /> の 0 から始まるインデックス位置。見つからなかった場合は、-1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックスの番号付けは0から始まります。 `startIndex` パラメーターには、0 から文字列インスタンスの長さまでの範囲の値を指定できます。 が`startIndex`文字列インスタンスの長さと等しい場合、メソッドは-1 を返します。  
  
 検索範囲は、 `startIndex`から文字列の末尾までです。  
  
 このメソッドは、Unicode スカラー値が同じである場合にのみ、文字が別の文字と等価であると見なされる序数 (カルチャに依存しない) 検索を実行します。 カルチャに依存した検索を実行するに<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>は、メソッドを使用します。この場合、合字の "Æ" (U + 00c6) などの構成されていない文字を表す Unicode スカラー値は、カルチャに応じて、"AE" (U + 0041 という, U + 0045) などの正しいシーケンス。  
  
   
  
## Examples  
 メソッドの<xref:System.String.IndexOf%2A>例を次に示します。  
  
 [!code-cpp[string.indexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof1/CPP/ixof1.cpp#1)]
 [!code-csharp[string.indexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof1/CS/ixof1.cs#1)]
 [!code-vb[string.indexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof1/VB/ixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> が、0 (ゼロ) 未満か、または文字列の長さを超えています。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">検索対象の文字。</param>
        <param name="comparisonType">検索の規則を指定する列挙値。</param>
        <summary>指定した Unicode 文字がこの文字列内で最初に見つかった位置の 0 から始まるインデックスをレポートします。 指定した文字に使用する検索の種類をパラメーターで指定します。</summary>
        <returns>その文字が見つかった場合は、<paramref name="value" /> の 0 から始まるインデックスでの位置。見つからなかった場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

インデックス番号は0から始まります。  
  
パラメーターは、 `value`引数の検索で現在のカルチャまたはインバリアントカルチャを使用するか、大文字と小文字を区別するか、または大文字と小文字を区別しないかを指定する列挙体メンバーです。または、単語または序数の比較規則を使用します。<xref:System.StringComparison> `comparisonType`
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> は有効な <see cref="T:System.StringComparison" /> 値ではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <param name="startIndex">検索が開始される位置。</param>
        <summary>指定された文字列がこのインスタンス内で最初に見つかった位置の 0 から始まるインデックスをレポートします。 検索は、指定した文字位置から開始されます。</summary>
        <returns>その文字列が見つかった場合は、現在のインスタンスの先頭からの、<paramref name="value" /> の 0 から始まるインデックス位置。見つからなかった場合は、-1。 <paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値は <paramref name="startIndex" /> です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックスの番号付けは0から始まります。 `startIndex` パラメーターには、0 から文字列インスタンスの長さまでの範囲の値を指定できます。 が`startIndex`文字列インスタンスの長さと等しい場合、メソッドは-1 を返します。  
  
 このメソッドは、現在のカルチャを使用して、単語 (大文字と小文字を区別し、カルチャに依存する) 検索を実行します。 検索は、このインスタンス`startIndex`の文字位置から開始し、最後の文字位置まで続行されます。  
  
 文字セットには無視できる文字が含まれています。これらの文字は、言語またはカルチャに依存した比較を実行する際には考慮されません。 カルチャに依存した検索では、`value` に無視できる文字が含まれている場合、その文字を削除して検索した場合と同じ結果になります。 が`value` 1 つ以上の無視できる文字で構成さ<xref:System.String.IndexOf%28System.String%2CSystem.Int32%29>れている`startIndex`場合、メソッドは常にを返します。これは、検索を開始する文字位置です。 次の例では、 <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29>メソッドを使用して、ソフトハイフン (U + 00ad) の後に2つの文字列の "m" が続く位置を検索します。 文字列の 1 つのみに必要な部分文字列が含まれます。 この例が以降で[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]実行されている場合、どちらの場合も、ソフトハイフンが無視できない文字であるため、メソッドは文字列内の "m" のインデックスを返します。 "m" の後にソフト ハイフンが含まれる最初の文字列の場合、メソッドはソフト ハイフンのインデックスを返すことができず、代わりに "m" のインデックスを返すことに注意してください。  
  
 [!code-csharp[System.String.IndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable22.cs#22)]
 [!code-vb[System.String.IndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable22.vb#22)]  
  
   
  
## Examples  
 次の例では、対象の文字列内で指定された文字列のすべての出現箇所を検索します。  
  
 [!code-cpp[stringindexof4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringindexof4/CPP/stringindexof4.cpp#1)]
 [!code-csharp[stringindexof4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringindexof4/CS/stringindexof4.cs#1)]
 [!code-vb[stringindexof4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringindexof4/VB/stringindexof4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> が、0 未満か、またはこの文字列の長さを超えています。</exception>
        <block subset="none" type="usage"><para>「[文字列を使用するためのベストプラクティス](~/docs/standard/base-types/best-practices-strings.md)」で説明したように、既定値を置き換える文字列比較メソッドを呼び出さずに、パラメーターを明示的に指定する必要があるメソッドを呼び出すことを避けることをお勧めします。 現在のカルチャの比較規則を使用して、特定の文字位置の後に出現する部分文字列の最初のインデックスを<see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />検索するには、 `comparisonType`パラメーター <see cref="F:System.StringComparison.CurrentCulture" />の値を指定してメソッドオーバーロードを呼び出します。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <param name="comparisonType">検索の規則を指定する列挙値の 1 つ。</param>
        <summary>指定した文字列が現在の <see cref="T:System.String" /> オブジェクト内で最初に見つかった位置の 0 から始まるインデックスをレポートします。 指定した文字列に使用する検索の種類をパラメーターで指定します。</summary>
        <returns>その文字列が見つかった場合は、<paramref name="value" /> パラメーターのインデックス位置。見つからなかった場合は -1。 <paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値は 0 です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は0から始まります。  
  
 パラメーター `comparisonType`は、大文字と小`value`文字を区別するか、大文字と小文字を区別しない検索を使用して、現在のカルチャまたはインバリアントカルチャを使用してパラメーターを検索し、word または序数の比較規則を使用するように指定します。  
  
   
  
## Examples  
 次の例では、 <xref:System.String.IndexOf%2A> <xref:System.StringComparison>列挙体の異なる値を使用して、別の文字列内で最初に出現する文字列を検索するメソッドの3つのオーバーロードを示します。  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> は有効な <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <block subset="none" type="usage"><para>文字セットには無視できる文字が含まれています。これらの文字は、言語またはカルチャに依存した比較を実行する際には考慮されません。 カルチャに依存する検索の場合 (つまり、<paramref name="comparisonType" /> が <see cref="F:System.StringComparison.Ordinal" /> または <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> でない場合)、<paramref name="value" /> に無視できる文字が含まれていると、その文字を削除して検索した場合と同じ結果になります。 が<paramref name="value" /> 1 つ以上の無視できる文字のみで構成<see cref="M:System.String.IndexOf(System.String,System.StringComparison)" />されている場合、メソッドは常に 0 (ゼロ) を返して、現在のインスタンスの先頭で一致が見つかったことを示します。  
  
次の例では、 <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" />メソッドを使用して、2つの文字列の3つの部分文字列 (ソフトハイフン (U + 00ad)、ソフトハイフンの後に "n"、ソフトハイフンの後に "m") を検索します。 文字列の 1 つのみにソフト ハイフンが含まれます。 この例が以降で[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]実行されている場合は、ソフトハイフンが無視できる文字であるため、カルチャに依存した検索では、ソフトハイフンが検索文字列に含まれていない場合に返されるのと同じ値が返されます。 ただし、序数検索では、1つの文字列でソフトハイフンが正常に検出され、2番目の文字列に存在しないことが報告されます。  
  
[!code-csharp[System.String.IndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable26.cs#26)] [!code-vb[System.String.IndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable26.vb#26)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">シークする Unicode 文字。</param>
        <param name="startIndex">検索が開始される位置。</param>
        <param name="count">検査する文字位置の数。</param>
        <summary>指定文字がこのインスタンス内で最初に見つかった位置の 0 から始まるインデックスをレポートします。 検索は指定した文字位置から開始され、指定した数の文字位置が検査されます。</summary>
        <returns>その文字が見つかった場合は、文字列の先頭からの、<paramref name="value" /> の 0 から始まるインデックス位置。見つからなかった場合は、-1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 検索はから始まり`startIndex` 、-1 `startIndex`に +  `count`進みます。 の文字`startIndex`  + は検索に含まれていません。`count`  
  
 インデックスの番号付けは 0 (ゼロ) から始まります。 `startIndex` パラメーターには、0 から文字列インスタンスの長さまでの範囲の値を指定できます。  
  
 このメソッドは、Unicode スカラー値が同じである場合にのみ、文字が別の文字と等価であると見なされる序数 (カルチャに依存しない) 検索を実行します。 カルチャに依存した検索を実行するに<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>は、メソッドを使用します。この場合、合字の "Æ" (U + 00c6) などの構成されていない文字を表す Unicode スカラー値は、カルチャに応じて、"AE" (U + 0041 という, U + 0045) などの正しいシーケンス。  
  
   
  
## Examples  
 メソッドの<xref:System.String.IndexOf%2A>例を次に示します。  
  
 [!code-cpp[system.string.indexof#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexofcii.cpp#1)]
 [!code-csharp[system.string.indexof#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexofcii.cs#1)]
 [!code-vb[system.string.indexof#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexofcii.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> または <paramref name="startIndex" /> が負の値です。  
  
または 
 <paramref name="startIndex" /> がこの文字列の長さより大きいです。  
  
- または - 
 <paramref name="count" /> がこの文字列の長さ - <paramref name="startIndex" /> より大きいです。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <param name="startIndex">検索が開始される位置。</param>
        <param name="count">検査する文字位置の数。</param>
        <summary>指定された文字列がこのインスタンス内で最初に見つかった位置の 0 から始まるインデックスをレポートします。 検索は指定した文字位置から開始され、指定した数の文字位置が検査されます。</summary>
        <returns>その文字列が見つかった場合は、現在のインスタンスの先頭からの、<paramref name="value" /> の 0 から始まるインデックス位置。見つからなかった場合は、-1。 <paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値は <paramref name="startIndex" /> です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックスの番号付けは 0 (ゼロ) から始まります。 `startIndex` パラメーターには、0 から文字列インスタンスの長さまでの範囲の値を指定できます。  
  
 このメソッドは、現在のカルチャを使用して、単語 (大文字と小文字を区別し、カルチャに依存する) 検索を実行します。 検索はから始まり`startIndex` 、-1 `startIndex`に +  `count`進みます。 の文字`startIndex`  + は検索に含まれていません。`count`  
  
 文字セットには無視できる文字が含まれています。これらの文字は、言語またはカルチャに依存した比較を実行する際には考慮されません。 カルチャに依存した検索では、`value` に無視できる文字が含まれている場合、その文字を削除して検索した場合と同じ結果になります。 が`value` 1 つ以上の無視できる文字で構成さ<xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29>れている`startIndex`場合、メソッドは常にを返します。これは、検索を開始する文字位置です。 次の例では、 <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29>メソッドを使用して、ソフトハイフン (U + 00ad) の後に2つ目の文字列の 3 ~ 6 文字の位置から始まる "m" を検索します。 文字列の 1 つのみに必要な部分文字列が含まれます。 この例が以降で[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]実行されている場合、どちらの場合も、ソフトハイフンが無視文字であるため、メソッドはカルチャに依存した比較を実行するときに、文字列内の "m" のインデックスを返します。 "m" の後にソフト ハイフンが含まれる最初の文字列の場合、メソッドはソフト ハイフンのインデックスを返すことができず、代わりに "m" のインデックスを返すことに注意してください。  
  
 [!code-csharp[System.String.IndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable23.cs#23)]
 [!code-vb[System.String.IndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable23.vb#23)]  
  
   
  
## Examples  
 次の例では、別の文字列の部分文字列内に出現する文字列 "he" のインデックスを検索します。 検索反復処理のたびに、検索する文字数を再計算する必要があることに注意してください。  
  
 [!code-cpp[string.indexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof8/CPP/ixof8.cpp#1)]
 [!code-csharp[string.indexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof8/CS/ixof8.cs#1)]
 [!code-vb[string.indexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof8/VB/ixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> または <paramref name="startIndex" /> が負の値です。  
  
- または - 
 <paramref name="startIndex" /> がこの文字列の長さより大きいです。  
  
- または - 
 <paramref name="count" /> がこの文字列の長さ - <paramref name="startIndex" /> より大きいです。</exception>
        <block subset="none" type="usage"><para>「[文字列を使用するためのベストプラクティス](~/docs/standard/base-types/best-practices-strings.md)」で説明したように、既定値を置き換える文字列比較メソッドを呼び出さずに、パラメーターを明示的に指定する必要があるメソッドを呼び出すことを避けることをお勧めします。 現在のカルチャの比較規則を使用してこの操作を実行するに<see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />は、 `comparisonType`パラメーター <see cref="F:System.StringComparison.CurrentCulture" />に値を指定してメソッドオーバーロードを呼び出します。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <param name="startIndex">検索が開始される位置。</param>
        <param name="comparisonType">検索の規則を指定する列挙値の 1 つ。</param>
        <summary>指定した文字列が現在の <see cref="T:System.String" /> オブジェクト内で最初に見つかった位置の 0 から始まるインデックスをレポートします。 現在の文字列内での検索の開始位置、および指定した文字列に使用する検索の種類をパラメーターで指定します。</summary>
        <returns>その文字列が見つかった場合は、現在のインスタンスの先頭からの、<paramref name="value" /> パラメーターの 0 から始まるインデックス位置。見つからなかった場合は、-1。 <paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値は <paramref name="startIndex" /> です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックスの番号付けは0から始まります。 `startIndex` パラメーターには、0 から文字列インスタンスの長さまでの範囲の値を指定できます。 が`startIndex`文字列インスタンスの長さと等しい場合、メソッドは-1 を返します。  
  
 パラメーター `comparisonType`は、大文字と小`value`文字を区別するか、大文字と小文字を区別しない検索を使用して、現在のカルチャまたはインバリアントカルチャを使用してパラメーターを検索し、word または序数の比較規則を使用するように指定します。  
  
   
  
## Examples  
 次の例では、 <xref:System.String.IndexOf%2A> <xref:System.StringComparison>列挙体の異なる値を使用して、別の文字列内で最初に出現する文字列を検索するメソッドの3つのオーバーロードを示します。  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> が、0 未満か、またはこの文字列の長さを超えています。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> は有効な <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <block subset="none" type="usage"><para>文字セットには無視できる文字が含まれています。これらの文字は、言語またはカルチャに依存した比較を実行する際には考慮されません。 カルチャに依存する検索の場合 (つまり、<paramref name="comparisonType" /> が <see cref="F:System.StringComparison.Ordinal" /> または <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> でない場合)、<paramref name="value" /> に無視できる文字が含まれていると、その文字を削除して検索した場合と同じ結果になります。 が<paramref name="value" /> 1 つ以上の無視できる文字で構成さ<see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />れている<paramref name="startIndex" />場合、メソッドは常にを返します。これは、検索を開始する文字位置です。  
  
次の例では、 <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />メソッドを使用して、ソフトハイフン (U + 00ad) の後に2つの文字列の3番目の文字位置から始まる "m" を検索します。 文字列の1つだけが、必須の部分文字列を含んでいます。この例が以降で[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]実行されている場合、どちらの場合も、ソフトハイフンが無視文字であるため、メソッドはカルチャに依存した比較を実行するときに、文字列内の "m" のインデックスを返します。 "m" の後にソフト ハイフンが含まれる最初の文字列の場合、メソッドはソフト ハイフンのインデックスを返すことができず、代わりに "m" のインデックスを返すことに注意してください。 このメソッドは、序数に基づく比較を実行したときのみ、最初の文字列に含まれるソフト ハイフンのインデックスを返します。  
  
[!code-csharp[System.String.IndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable25.cs#25)] [!code-vb[System.String.IndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable25.vb#25)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <param name="startIndex">検索が開始される位置。</param>
        <param name="count">検査する文字位置の数。</param>
        <param name="comparisonType">検索の規則を指定する列挙値の 1 つ。</param>
        <summary>指定した文字列が現在の <see cref="T:System.String" /> オブジェクト内で最初に見つかった位置の 0 から始まるインデックスをレポートします。 現在の文字列での検索開始位置、現在の文字列で検索する文字の数、および指定した文字列に使用する検索の種類をパラメーターで指定します。</summary>
        <returns>その文字列が見つかった場合は、現在のインスタンスの先頭からの、<paramref name="value" /> パラメーターの 0 から始まるインデックス位置。見つからなかった場合は、-1。 <paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値は <paramref name="startIndex" /> です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックスの番号付けは 0 (ゼロ) から始まります。 `startIndex` パラメーターには、0 から文字列インスタンスの長さまでの範囲の値を指定できます。  
  
 検索はから始まり`startIndex` 、-1 `startIndex`に +  `count`進みます。 の文字`startIndex`  + は検索に含まれていません。`count`  
  
 パラメーター `comparisonType`は、大文字と小`value`文字を区別するか、大文字と小文字を区別しない検索を使用して、現在のカルチャまたはインバリアントカルチャを使用してパラメーターを検索し、word または序数の比較規則を使用するように指定します。  
  
   
  
## Examples  
 次の例では、 <xref:System.String.IndexOf%2A> <xref:System.StringComparison>列挙体の異なる値を使用して、別の文字列内で最初に出現する文字列を検索するメソッドの3つのオーバーロードを示します。  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> または <paramref name="startIndex" /> が負の値です。  
  
または 
 <paramref name="startIndex" /> はこのインスタンスの長さを超えています。  
  
- または - 
 <paramref name="count" /> がこの文字列の長さ - <paramref name="startIndex" /> より大きいです。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> は有効な <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <block subset="none" type="usage"><para>文字セットには無視できる文字が含まれています。これらの文字は、言語またはカルチャに依存した比較を実行する際には考慮されません。 カルチャに依存する検索の場合 (つまり、<paramref name="comparisonType" /> が <see cref="F:System.StringComparison.Ordinal" /> または <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> でない場合)、<paramref name="value" /> に無視できる文字が含まれていると、その文字を削除して検索した場合と同じ結果になります。 が<paramref name="value" /> 1 つ以上の無視できる文字で構成さ<see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />れている<paramref name="startIndex" />場合、メソッドは常にを返します。これは、検索を開始する文字位置です。  
  
次の例では、 <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />メソッドを使用して、ソフトハイフン (U + 00ad) の後に2つ目の文字列の 3 ~ 6 文字の位置から始まる "m" を検索します。 文字列の 1 つのみに必要な部分文字列が含まれます。 この例が以降で[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]実行されている場合、どちらの場合も、ソフトハイフンが無視文字であるため、メソッドはカルチャに依存した比較を実行するときに、文字列内の "m" のインデックスを返します。 ただし、序数による比較を実行する場合は、最初の文字列でのみ部分文字列が検索されます。 ソフトハイフンの後に "m" が続く最初の文字列の場合、メソッドはソフトハイフンのインデックスを返すのではなく、カルチャに依存した比較を実行するときに "m" のインデックスを返すことに注意してください。 このメソッドは、序数に基づく比較を実行したときのみ、最初の文字列に含まれるソフト ハイフンのインデックスを返します。  
  
[!code-csharp[System.String.IndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable24.cs#24)] [!code-vb[System.String.IndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable24.vb#24)]</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Unicode 文字の指定した配列内にある文字がこのインスタンスで最初に見つかった位置のインデックスをレポートします。 このインスタンス内で配列内の文字が見つからない場合、このメソッドは -1 を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] -&gt; int" Usage="string.IndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">シークする 1 つ以上の文字を格納している、Unicode 文字の配列。</param>
        <summary>Unicode 文字の指定した配列内にある文字がこのインスタンスで最初に見つかった位置の 0 から始まるインデックスをレポートします。</summary>
        <returns><paramref name="anyOf" /> 内の文字がこのインスタンスで最初に見つかった場所の 0 から始まるインデックスでの位置。<paramref name="anyOf" /> 内に文字が見つからなかった場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は0から始まります。  
  
 の`anyOf`検索では、大文字と小文字が区別されます。 が`anyOf`空の配列の場合、メソッドは文字列の先頭 (インデックスゼロ) で一致を検索します。  
  
 このメソッドは、Unicode スカラー値が同じである場合にのみ、文字が別の文字と等価であると見なされる序数 (カルチャに依存しない) 検索を実行します。 カルチャに依存した検索を実行するに<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>は、メソッドを使用します。この場合、合字の "Æ" (U + 00c6) などの構成されていない文字を表す Unicode スカラー値は、カルチャに応じて、"AE" (U + 0041 という, U + 0045) などの正しいシーケンス。  
  
   
  
## Examples  
 次の例では、文字列内の最初の母音を検索します。  
  
 [!code-csharp[System.String.IndexOfAny#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.IndexOfAny/cs/IndexOfAny1.cs#1)]
 [!code-vb[System.String.IndexOfAny#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.IndexOfAny/vb/IndexOfAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> が <see langword="null" /> です。</exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">シークする 1 つ以上の文字を格納している、Unicode 文字の配列。</param>
        <param name="startIndex">検索が開始される位置。</param>
        <summary>Unicode 文字の指定した配列内にある文字がこのインスタンスで最初に見つかった位置の 0 から始まるインデックスをレポートします。 検索は、指定した文字位置から開始されます。</summary>
        <returns><paramref name="anyOf" /> 内の文字がこのインスタンスで最初に見つかった場所の 0 から始まるインデックスでの位置。<paramref name="anyOf" /> 内に文字が見つからなかった場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は0から始まります。 パラメーター `startIndex`は、0から文字列インスタンスの長さまでの範囲で指定できます。  
  
 検索範囲は、 `startIndex`から文字列の末尾までです。  
  
 の`anyOf`検索では、大文字と小文字が区別されます。  
  
 このメソッドは、Unicode スカラー値が同じである場合にのみ、文字が別の文字と等価であると見なされる序数 (カルチャに依存しない) 検索を実行します。 カルチャに依存した検索を実行するに<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>は、メソッドを使用します。この場合、合字の "Æ" (U + 00c6) などの構成されていない文字を表す Unicode スカラー値は、カルチャに応じて、"AE" (U + 0041 という, U + 0045) などの正しいシーケンス。  
  
   
  
## Examples  
 次の例では、別の文字列の部分文字列内の文字列 "is" 内の任意の文字が出現する位置のインデックスを検索します。  
  
 [!code-cpp[string.indexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany2/CPP/ixany2.cpp#1)]
 [!code-csharp[string.indexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany2/CS/ixany2.cs#1)]
 [!code-vb[string.indexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany2/VB/ixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> が負の値です。  
  
- または - 
 <paramref name="startIndex" /> が、このインスタンス中の文字数を超えています。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">シークする 1 つ以上の文字を格納している、Unicode 文字の配列。</param>
        <param name="startIndex">検索が開始される位置。</param>
        <param name="count">検査する文字位置の数。</param>
        <summary>Unicode 文字の指定した配列内にある文字がこのインスタンスで最初に見つかった位置の 0 から始まるインデックスをレポートします。 検索は指定した文字位置から開始され、指定した数の文字位置が検査されます。</summary>
        <returns><paramref name="anyOf" /> 内の文字がこのインスタンスで最初に見つかった場所の 0 から始まるインデックスでの位置。<paramref name="anyOf" /> 内に文字が見つからなかった場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 検索はから始まり`startIndex` 、-1 `startIndex`に +  `count`進みます。 の文字`startIndex`  + は検索に含まれていません。`count`  
  
 インデックス番号は0から始まります。 パラメーター `startIndex`は、0から文字列インスタンスの長さまでの範囲で指定できます。  
  
 の`anyOf`検索では、大文字と小文字が区別されます。  
  
 このメソッドは、Unicode スカラー値が同じである場合にのみ、文字が別の文字と等価であると見なされる序数 (カルチャに依存しない) 検索を実行します。 カルチャに依存した検索を実行するに<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>は、メソッドを使用します。この場合、合字の "Æ" (U + 00c6) などの構成されていない文字を表す Unicode スカラー値は、カルチャに応じて、"AE" (U + 0041 という, U + 0045) などの正しいシーケンス。  
  
   
  
## Examples  
 次の例では、別の文字列の部分文字列内で文字列 "aid" の任意の文字が出現する位置のインデックスを検索します。  
  
 [!code-cpp[string.indexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany3/CPP/ixany3.cpp#1)]
 [!code-csharp[string.indexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany3/CS/ixany3.cs#1)]
 [!code-vb[string.indexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany3/VB/ixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> または <paramref name="startIndex" /> が負の値です。  
  
または 
 <paramref name="count" /> + <paramref name="startIndex" /> が、このインスタンス中の文字数を超えています。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public string Insert (int startIndex, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Insert(int32 startIndex, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (startIndex As Integer, value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Insert(int startIndex, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string -&gt; string" Usage="string.Insert (startIndex, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="startIndex">挿入の 0 から始まるインデックス位置。</param>
        <param name="value">挿入する文字列。</param>
        <summary>このインスタンス内の指定したインデックス位置に指定した文字列を挿入する場合の、新しい文字列を返します。</summary>
        <returns>このインスタンスと等価で、<paramref name="value" /> の位置に <paramref name="startIndex" /> が挿入された新しい文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 が`startIndex`このインスタンスの長さと等しい場合は、 `value`がこのインスタンスの末尾に追加されます。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更しません。 代わりに、現在のインスタンスにが挿入さ`value`れる新しい文字列を返します。  
  
 たとえば、の`"abc".Insert(2, "XYZ")`戻り値は "abXYZc" です。  
  
   
  
## Examples  
 次の例では、文字列の4番目の文字位置 (インデックス3の文字) に空白文字を挿入します。  
  
 [!code-csharp[System.String.Insert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Insert/cs/Insert1.cs#1)]
 [!code-vb[System.String.Insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Insert/vb/Insert1.vb#1)]  
  
 次のコンソールアプリケーションは、2つの動物を説明するために1つ以上の形容詞を入力するようユーザーに求めます。 次に、 <xref:System.String.Insert%2A>メソッドを呼び出して、ユーザーが入力したテキストを文字列に挿入します。  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> が負の数値か、またはこのインスタンスの長さを超えています。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Intern">
      <MemberSignature Language="C#" Value="public static string Intern (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Intern(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Intern(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Intern (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Intern(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Intern : string -&gt; string" Usage="System.string.Intern str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="str">インターン プールから検索する文字列。</param>
        <summary>指定した <see cref="T:System.String" /> へのシステム参照を取得します。</summary>
        <returns><paramref name="str" /> がインターン プールに存在する場合は、それに対するシステム参照。それ以外の場合は、値が <paramref name="str" /> の文字列への新しい参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 共通言語ランタイムは、インターンプールと呼ばれるテーブルを保持することによって文字列ストレージを節約します。このテーブルには、プログラムで宣言またはプログラムによって作成された一意のリテラル文字列への単一の参照が含まれています。 その結果、特定の値を持つリテラル文字列のインスタンスは、システム内に1回だけ存在します。  
  
 たとえば、同じリテラル文字列を複数の変数に割り当てた場合、ランタイムは、インターンプールからリテラル文字列への同じ参照を取得し、各変数に代入します。  
  
 メソッド<xref:System.String.Intern%2A>は、インターンプールを使用して、の`str`値と等しい文字列を検索します。 このような文字列が存在する場合は、インターンプール内のその参照が返されます。 文字列が存在しない場合は、へ`str`の参照がインターンプールに追加され、その参照が返されます。  
  
 次の例では、値が "MyTest" の文字列 s1 は、プログラム内のリテラルであるため、既にインターンされています。 クラス<xref:System.Text.StringBuilder?displayProperty=nameWithType>は、s1 と同じ値を持つ新しい文字列オブジェクトを生成します。 その文字列への参照が s2 に割り当てられます。 メソッド<xref:System.String.Intern%2A>は、s2 と同じ値を持つ文字列を検索します。 このような文字列が存在するので、このメソッドは s1 に割り当てられているのと同じ参照を返します。 その後、その参照が s3 に割り当てられます。 参照 s1 と s2 は異なるオブジェクトを参照しているため、等しくないと比較します。参照 s1 と s3 は同じ文字列を参照しているため、等しいと比較されます。  
  
 [!code-csharp[System.String.Intern#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern1.cs#1)]
 [!code-vb[System.String.Intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern1.vb#1)]  
  
 このメソッドと<xref:System.String.IsInterned%2A>メソッドを比較します。  
  
## <a name="version-considerations"></a>バージョンに関する考慮事項  
 では、メソッド<xref:System.String.Intern%2A>は、空の文字列をインターン処理することに関して、.NET Framework 1.0 および1.1 での動作に戻ります。 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 次の例では、変数`str1`にへ<xref:System.String.Empty>の参照が割り当てられ、 `str2`変数には、 <xref:System.String.Empty> <xref:System.String.Intern%2A> <xref:System.Text.StringBuilder>を変換した後にメソッドを呼び出すことによって返されるへの参照が割り当てられています。値が<xref:System.String.Empty>文字列であるオブジェクト。 次に、に`str1` `str2`含まれる参照が等しいかどうかを比較します。  
  
 [!code-csharp[System.String.Intern#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern2.cs#2)]
 [!code-vb[System.String.Intern#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern2.vb#2)]  
  
 [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)] 、、[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]およびでは、 `str1` と`str2`は等価です。 [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)] とでは、`str1` と`str2`は等しくありません。 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] [!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)]  
  
## <a name="performance-considerations"></a>パフォーマンスに関する考慮事項  
 アプリケーションによって割り当てられるメモリの総量を減らす場合は、インターン文字列に2つの望ましくない副作用があることに注意してください。 1つ目の方法とし<xref:System.String>て、インターン解除されたオブジェクトに割り当てられるメモリは、共通言語ランタイム (CLR) が終了するまで解放されない可能性があります。 その理由は、インターン<xref:System.String>化されたオブジェクトへの CLR の参照は、アプリケーションまたはアプリケーションドメインが終了した後も保持される可能性があるためです。 次に、文字列をインターンさせるには、最初に文字列を作成する必要があります。 メモリが最終的にガベージ<xref:System.String>コレクトされる場合でも、オブジェクトによって使用されるメモリを割り当てる必要があります。  
  
 .NET Framework バージョン2.0 では、 <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning?displayProperty=nameWithType>列挙型のメンバーが導入されています。 メンバー <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning>は、アセンブリをリテラル文字列インターンを必要としないものとしてマークします。 属性<xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute>を使用<xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning>してアセンブリにを適用できます。 また、 [ngen.exe (ネイティブイメージジェネレーター)](~/docs/framework/tools/ngen-exe-native-image-generator.md)を使用して、実行時より前にアセンブリをコンパイルする場合、文字列はモジュール間でインターンプールされません。  
  
   
  
## Examples  
 次の例では、値が等しい3つの文字列を使用して、新しく作成された文字列とインターンされた文字列が等しいかどうかを判断します。  
  
 [!code-cpp[string.intern#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.intern/CPP/string_intern.cpp#1)]
 [!code-csharp[string.intern#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.intern/CS/string_intern.cs#1)]
 [!code-vb[string.intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.intern/VB/string_intern.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> が <see langword="null" /> です。</exception>
        <altmember cref="M:System.String.IsInterned(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsInterned">
      <MemberSignature Language="C#" Value="public static string IsInterned (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string IsInterned(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsInterned(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInterned (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ IsInterned(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member IsInterned : string -&gt; string" Usage="System.string.IsInterned str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="str">インターン プールから検索する文字列。</param>
        <summary>指定した <see cref="T:System.String" /> への参照を取得します。</summary>
        <returns><paramref name="str" /> が共通言語ランタイムのインターン プール内にある場合は、それへの参照。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 共通言語ランタイムは、インターンプールと呼ばれるテーブルを自動的に保持します。このテーブルには、プログラムで宣言された一意のリテラル文字列定数の1つ<xref:System.String>のインスタンスと、を呼び出すことによってプログラムによって追加するの一意のインスタンスが含まれます。<xref:System.String.Intern%2A>メソッド。  
  
 インターンプールは、文字列ストレージを節約します。 リテラル文字列定数を複数の変数に割り当てた場合、同じ値を持つの複数の<xref:System.String>インスタンスを参照するのではなく、各変数がインターンプールで同じ定数を参照するように設定されます。  
  
 このメソッドは、 `str`インターンプール内を検索します。 が`str`既にインターンされている場合は、そのインスタンスへの参照`null`が返されます。それ以外の場合はが返されます。  
  
 このメソッドと<xref:System.String.Intern%2A>メソッドを比較します。  
  
 このメソッドは、ブール値を返しません。 特定の文字列がインターンされているかどうかを示すブール値が必要なためにメソッドを呼び出す場合は、次のようなコードを使用できます。  
  
 [!code-csharp[System.String.IsInterned#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isinterned/cs/isinternedex1.cs#1)]
 [!code-vb[System.String.IsInterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isinterned/vb/isinternedex1.vb#1)]  
  
> [!NOTE]
>  .NET Framework バージョン2.0 以降では、 [ngen.exe (ネイティブイメージジェネレーター)](~/docs/framework/tools/ngen-exe-native-image-generator.md)を使用してローカルコンピューターのネイティブイメージキャッシュにアセンブリをインストールするときに、インターンプールの使用を無効にすることができます。 詳細については、 <xref:System.String.Intern%2A>プロパティの「解説」の「パフォーマンスに関する考慮事項」を参照してください。  
  
   
  
## Examples  
 次の例は、リテラル文字列がコンパイラによって自動的にインターンされることを示しています。  
  
 [!code-cpp[string.isinterned#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isinterned/CPP/isin.cpp#1)]
 [!code-csharp[string.isinterned#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isinterned/CS/isin.cs#1)]
 [!code-vb[string.isinterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isinterned/VB/isin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> は <see langword="null" />です。</exception>
        <altmember cref="M:System.String.Intern(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>この文字列が、特定の Unicode 正規形であるかどうかを示します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : unit -&gt; bool" Usage="string.IsNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この文字列が、Unicode 正規形 C であるかどうかを示します。</summary>
        <returns>この文字列が正規形 C である場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一部の Unicode 文字には、組み合わせと複合 Unicode 文字のセットで構成される等価のバイナリ表現が複数あります。 1つの文字に対して複数の表現が存在すると、検索、並べ替え、照合、およびその他の操作が複雑になります。  
  
 Unicode 規格では、1つの文字に相当するバイナリ表現を指定した場合に1つのバイナリ表現を返す正規化と呼ばれるプロセスが定義されています。 正規化は、正規化形式と呼ばれるいくつかのアルゴリズムを使用して実行できます。これは、さまざまな規則に従います。 現在、.NET では、C、D、KC、および KD の正規化形式がサポートされています。  
  
 サポートされている Unicode 正規形の説明<xref:System.Text.NormalizationForm?displayProperty=nameWithType>については、「」を参照してください。  
  
   
  
## Examples  
 次の例では、文字列がさまざまな正規化形式に正常に正規化されたかどうかを判断します。  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在のインスタンスに、正しくない Unicode 文字が含まれています。</exception>
        <block subset="none" type="usage"><para>メソッド<see cref="Overload:System.String.IsNormalized" />は、 <see langword="false" />文字列内の最初の正規化されていない文字が検出されるとすぐに戻ります。 したがって、文字列に非正規化文字の後に無効な Unicode 文字が含ま<see cref="Overload:System.String.Normalize" />れている場合、 <see cref="Overload:System.String.IsNormalized" />メソッド<see langword="false" />はを返しますが、は<see cref="T:System.ArgumentException" />をスローします。</para></block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : System.Text.NormalizationForm -&gt; bool" Usage="string.IsNormalized normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">Unicode 正規形。</param>
        <summary>この文字列が、指定された Unicode 正規形であるかどうかを示します。</summary>
        <returns>この文字列が <see langword="true" /> パラメーターに指定された正規形である場合は <paramref name="normalizationForm" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一部の Unicode 文字には、組み合わせと複合 Unicode 文字のセットで構成される等価のバイナリ表現が複数あります。 1つの文字に対して複数の表現が存在すると、検索、並べ替え、照合、およびその他の操作が複雑になります。  
  
 Unicode 規格では、1つの文字に相当するバイナリ表現を指定した場合に1つのバイナリ表現を返す正規化と呼ばれるプロセスが定義されています。 正規化は、正規化形式と呼ばれるいくつかのアルゴリズムを使用して実行できます。これは、さまざまな規則に従います。 現在、.NET では、C、D、KC、および KD の正規化形式がサポートされています。  
  
 サポートされている Unicode 正規形の説明<xref:System.Text.NormalizationForm?displayProperty=nameWithType>については、「」を参照してください。  
  
   
  
## Examples  
 次の例は、 <xref:System.String.IsNormalized%2A>メソッド<xref:System.String.Normalize%2A>とメソッドを示しています。  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在のインスタンスに、正しくない Unicode 文字が含まれています。</exception>
        <block subset="none" type="usage"><para>メソッド<see cref="Overload:System.String.IsNormalized" />は、 <see langword="false" />文字列内の最初の正規化されていない文字が検出されるとすぐに戻ります。 したがって、文字列に非正規化文字の後に無効な Unicode 文字が含ま<see cref="Overload:System.String.Normalize" />れている場合、 <see cref="Overload:System.String.IsNormalized" />メソッド<see langword="false" />はを返しますが、は<see cref="T:System.ArgumentException" />をスローします。</para></block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrEmpty">
      <MemberSignature Language="C#" Value="public static bool IsNullOrEmpty (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrEmpty(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrEmpty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrEmpty (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrEmpty(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrEmpty : string -&gt; bool" Usage="System.string.IsNullOrEmpty value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">テストする文字列。</param>
        <summary>指定された文字列が <see langword="null" /> または空の文字列 ("") であるかどうかを示します。</summary>
        <returns><see langword="true" /> パラメーターが <paramref name="value" /> または空の文字列 ("") の場合は <see langword="null" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.IsNullOrEmpty%2A>は、 <xref:System.String>がで`null`あるか、その値がで<xref:System.String.Empty?displayProperty=nameWithType>あるかを同時にテストできる便利なメソッドです。 これは、次のコードと同じです。  
  
 [!code-cpp[System.String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/isnullorempty1.cpp#1)]
 [!code-csharp[System.String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/isnullorempty1.cs#1)]
 [!code-vb[System.String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/isnullorempty1.vb#1)]  
  
 <xref:System.String.IsNullOrWhiteSpace%2A>メソッドを使用して、文字列がであるか`null`、その値が<xref:System.String.Empty?displayProperty=nameWithType>であるか、または空白文字のみで構成されているかをテストできます。  
  
## <a name="what-is-a-null-string"></a>Null 文字列とは何ですか。

値 ( C++および Visual Basic) が割り当てられていない場合、または値が明示的に`null`割り当てられている場合、文字列はです。 `null` 次の例に示すように、[複合書式指定](~/docs/standard/base-types/composite-formatting.md)機能は null 文字列を適切に処理できますが、メンバーがを<xref:System.NullReferenceException>スローした場合に1を呼び出そうとすると、その文字列が呼び出されます。  
  
[!code-cpp[System.String.IsNullOrEmpty#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#2)]
[!code-csharp[System.String.IsNullOrEmpty#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#2)]
[!code-vb[System.String.IsNullOrEmpty#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#2)]  
  
## <a name="what-is-an-empty-string"></a>空の文字列とは何ですか。  

空の文字列 ("") または<xref:System.String.Empty?displayProperty=nameWithType>が明示的に割り当てられている場合、文字列は空になります。 空<xref:System.String.Length%2A>の文字列のの値は0です。  次の例では、空の文字列を作成し、その値とその長さを表示します。  
  
[!code-cpp[System.String.IsNullOrEmpty#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#3)]
[!code-csharp[System.String.IsNullOrEmpty#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#3)]
[!code-vb[System.String.IsNullOrEmpty#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#3)]  
  
## Examples  
 次の例では、3つの文字列を調べて、各文字列に値、空の文字列`null`、またはがあるかどうかを確認します。  
  
 [!code-cpp[String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isNullOrEmpty/CPP/inoe.cpp#1)]
 [!code-csharp[String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isNullOrEmpty/CS/inoe.cs#1)]
 [!code-vb[String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isNullOrEmpty/VB/inoe.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsNullOrWhiteSpace (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrWhiteSpace(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrWhiteSpace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrWhiteSpace (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrWhiteSpace(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrWhiteSpace : string -&gt; bool" Usage="System.string.IsNullOrWhiteSpace value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">テストする文字列。</param>
        <summary>指定された文字列が <see langword="null" /> または空であるか、空白文字だけで構成されているかどうかを示します。</summary>
        <returns><see langword="true" /> パラメーターが <paramref name="value" /> または <see langword="null" /> であるか、<see cref="F:System.String.Empty" /> が空白文字だけで構成されている場合は <paramref name="value" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.IsNullOrWhiteSpace%2A>は、より優れたパフォーマンスを提供する点を除いて、次のコードのような便利なメソッドです。  
  
 [!code-csharp[System.String.IsNullOrWhitespace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace.cs#2)]
 [!code-vb[System.String.IsNullOrWhitespace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace.vb#2)]  
  
 空白文字は、Unicode 規格で定義されています。 メソッドは、空白文字として<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>メソッドに`true`渡されたときに、値を返す任意の文字を解釈します。 <xref:System.String.IsNullOrWhiteSpace%2A>  
  
   
  
## Examples  
 次の例では、文字列配列を作成し、配列の各要素を<xref:System.String.IsNullOrWhiteSpace%2A>メソッドに渡します。  
  
 [!code-csharp[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace1.cs#1)]
 [!code-vb[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した配列の要素またはコレクションのメンバーを連結します。各要素の間には、指定した区切り記号が挿入されます。</summary>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;string&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">区切り記号として使用する文字列。<paramref name="separator" /> が返される文字列に含まれるのは、<paramref name="values" /> が 2 つ以上の要素を含む場合に限られます。</param>
        <param name="values">連結する文字列を格納しているコレクション。</param>
        <summary><see cref="T:System.Collections.Generic.IEnumerable`1" /> 型の構築された <see cref="T:System.String" /> コレクションのメンバーを連結します。各メンバーの間には、指定した区切り記号が挿入されます。</summary>
        <returns><paramref name="values" /> のメンバーからなる、<paramref name="separator" /> 文字列で区切られた文字列。 <paramref name="values" /> にメンバーがない場合、メソッドは <see cref="F:System.String.Empty" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Empty?displayProperty=nameWithType>が`separator` の場合は、代わりに空の文字列()が使用されます。`null` のいずれかの`values`メンバー `null`がの場合は、空の文字列が代わりに使用されます。  
  
 <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29>は、要素を最初に文字列配列に変換せず`IEnumerable(Of String)`に、コレクション内の各要素を連結できる便利なメソッドです。 これは、統合言語クエリ (LINQ) クエリ式で特に便利です。 次の例では`List(Of String)` 、アルファベットの大文字または小文字を含むオブジェクトを、特定の文字以上の文字 (例では "M") を選択するラムダ式に渡します。 メソッドによって返される`IEnumerable(Of String)`コレクションは、結果を1つの文字列として表示するためにメソッドに渡されます。<xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType>  
  
 [!code-csharp[System.String.Join#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join4.cs#4)]
 [!code-vb[System.String.Join#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join4.vb#4)]  
  
   
  
## Examples  
 次の例では、ありアルゴリズムのエラトステネスを使用して、100以下の素数を計算します。 結果を型<xref:System.Collections.Generic.List%601> <xref:System.String>のオブジェクトに代入し、次に<xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29>メソッドに渡します。  
  
 [!code-csharp[System.String.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join3.cs#3)]
 [!code-vb[System.String.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> は <see langword="null" />です。</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">区切り記号として使用する文字列。 <paramref name="values" /> が 2 つ以上の要素を含む場合のみ、<paramref name="separator" /> が返される文字列に含まれます。</param>
        <param name="values">連結する要素を格納している配列。</param>
        <summary>オブジェクト配列の要素を連結します。各要素の間には、指定した区切り記号が挿入されます。</summary>
        <returns><paramref name="values" /> の要素からなる、<paramref name="separator" /> 文字列で区切られた文字列。 <paramref name="values" /> が空の配列の場合、メソッドは <see cref="F:System.String.Empty" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 が`separator` `values` `null`<xref:System.String.Empty?displayProperty=nameWithType>の場合、または最初の要素以外のの要素がの場合は、代わりに空の文字列 () が使用されます。 `null` の最初の要素が`values` `null`の場合は、「呼び出し元のメモ」セクションを参照してください。  
  
 <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29>は、要素を文字列に明示的に変換せずに、オブジェクト配列内の各要素を連結できる便利なメソッドです。 配列内の各オブジェクトの文字列形式は、そのオブジェクトの`ToString`メソッドを呼び出すことによって派生されます。  
  
   
  
## Examples  
 次の例では、ありアルゴリズムのエラトステネスを使用して、100以下の素数を計算します。 結果を整数の配列に代入し、次に<xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29>メソッドに渡します。  
  
 [!code-csharp[System.String.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join1.cs#1)]
 [!code-vb[System.String.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> は <see langword="null" />です。</exception>
        <block subset="none" type="usage"><para>の最初の要素が<paramref name="values" /> <see langword="null" />の場合、 <see cref="M:System.String.Join(System.String,System.Object[])" />メソッドはの要素を連結せ<paramref name="values" />ずに、 <see cref="F:System.String.Empty" />を返します。 この問題の回避策は多数あります。 最も簡単な方法は、次の<see cref="F:System.String.Empty" />例に示すように、配列の最初の要素に値を代入することです。  
  
[!code-csharp[System.String.Join#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/joinfix1.cs#6)] [!code-vb[System.String.Join#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/joinfix1.vb#6)]</para></block>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">区切り記号として使用する文字列。 <paramref name="value" /> が 2 つ以上の要素を含む場合のみ、<paramref name="separator" /> が返される文字列に含まれます。</param>
        <param name="value">連結する要素を格納している配列。</param>
        <summary>文字列配列のすべての要素を連結します。各要素の間には、指定した区切り記号が挿入されます。</summary>
        <returns><paramref name="value" /> 内の要素からなる、<paramref name="separator" /> 文字列で区切られた文字列。 <paramref name="value" /> が空の配列の場合、メソッドは <see cref="F:System.String.Empty" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 たとえば、が " `separator` ," で、の`value`要素が "apple"、"オレンジ"、"grape"、 `Join(separator, value)`および "pear" の場合、は "apple, オレンジ, grape, pear" を返します。  
  
 <xref:System.String.Empty?displayProperty=nameWithType>が`separator` の場合は、代わりに空の文字列()が使用されます。`null` 内の`value`いずれかの`null`要素がの場合は、代わりに空の文字列が使用されます。  
  
   
  
## Examples  
 メソッドの<xref:System.String.Join%2A>例を次に示します。  
  
 [!code-cpp[stringjoin#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringjoin/CPP/stringjoin.cpp#1)]
 [!code-csharp[stringjoin#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringjoin/CS/stringjoin.cs#1)]
 [!code-vb[stringjoin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringjoin/VB/stringjoin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> は <see langword="null" />です。</exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">区切り記号として使用する文字列。 <paramref name="value" /> が 2 つ以上の要素を含む場合のみ、<paramref name="separator" /> が返される文字列に含まれます。</param>
        <param name="value">連結する要素を格納している配列。</param>
        <param name="startIndex">使用する <paramref name="value" /> の最初の要素。</param>
        <param name="count">使用する <paramref name="value" /> の要素の数。</param>
        <summary>文字列配列の指定した要素を連結します。各要素の間には、指定した区切り記号が挿入されます。</summary>
        <returns><paramref name="value" /> 内の文字列からなる、<paramref name="separator" /> 文字列で区切られた文字列。  
  
- または - 
 <see cref="F:System.String.Empty" /> が 0 である場合、または <paramref name="count" /> に要素がない場合、または <paramref name="value" /> と <paramref name="separator" /> のすべての要素が <paramref name="value" /> である場合、<see cref="F:System.String.Empty" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 たとえば、が " `separator` ," で、の`value`要素が "apple"、"オレンジ"、"grape"、 `Join(separator, value, 1, 2)`および "pear" の場合、は "オレンジ, grape" を返します。  
  
 <xref:System.String.Empty?displayProperty=nameWithType>が`separator` の場合は、代わりに空の文字列()が使用されます。`null` 内の`value`いずれかの`null`要素がの場合は、代わりに空の文字列が使用されます。  
  
   
  
## Examples  
 次の例では、果物という名前の配列の2つの要素を連結しています。  
  
 [!code-cpp[string.join2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.join2/CPP/join2.cpp#1)]
 [!code-csharp[string.join2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.join2/CS/join2.cs#1)]
 [!code-vb[string.join2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.join2/VB/join2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> または <paramref name="count" /> が 0 未満です。  
  
- または - 
 <paramref name="startIndex" /> と <paramref name="count" /> を加算すると、 <paramref name="value" />にある要素の数を超えます。</exception>
        <exception cref="T:System.OutOfMemoryException">メモリが不足しています。</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As Char, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As String, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><paramref name="values" /> のメンバーの型。</typeparam>
        <param name="separator">区切り記号として使用する文字列。<paramref name="separator" /> が返される文字列に含まれるのは、<paramref name="values" /> が 2 つ以上の要素を含む場合に限られます。</param>
        <param name="values">連結するオブジェクトを格納しているコレクション。</param>
        <summary>コレクションのメンバーを連結します。各メンバーの間には、指定した区切り記号が挿入されます。</summary>
        <returns><paramref name="values" /> のメンバーからなる、<paramref name="separator" /> 文字列で区切られた文字列。 <paramref name="values" /> にメンバーがない場合、メソッドは <see cref="F:System.String.Empty" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Empty?displayProperty=nameWithType>が`separator` の場合は、代わりに空の文字列()が使用されます。`null` のいずれかの`values`メンバー `null`がの場合は、空の文字列が代わりに使用されます。  
  
 <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>は、最初に<xref:System.Collections.Generic.IEnumerable%601>コレクションの各メンバーを文字列に変換せずに連結できる便利なメソッドです。 <xref:System.Collections.Generic.IEnumerable%601>コレクション内の各オブジェクトの文字列形式は、そのオブジェクトの`ToString`メソッドを呼び出すことによって派生されます。  
  
 このメソッドは、統合言語クエリ (LINQ) クエリ式で特に便利です。 たとえば、次のコードでは、動物の`Animal`名前とそれが属する順序を含む非常に単純なクラスを定義しています。 次に、多数<xref:System.Collections.Generic.List%601>の`Animal`オブジェクトを含むオブジェクトを定義します。 拡張<xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType>メソッドは、 `Order`プロパティが "げっ歯類`Animal` " と等しいオブジェクトを抽出するために呼び出されます。 結果は<xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>メソッドに渡されます。  
  
 [!code-csharp[System.String.Join#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join5.cs#5)]
 [!code-vb[System.String.Join#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join5.vb#5)]  
  
   
  
## Examples  
 次の例では、ありアルゴリズムのエラトステネスを使用して、100以下の素数を計算します。 結果を integer 型の<xref:System.Collections.Generic.List%601>オブジェクトに代入し、次<xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>にメソッドに渡します。  
  
 [!code-csharp[System.String.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join2.cs#2)]
 [!code-vb[System.String.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> は <see langword="null" />です。</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このインスタンス内で最後に出現する指定 Unicode 文字または文字列の 0 から始まるインデックス位置をレポートします。 このインスタンス内で文字または文字列が見つからない場合、このメソッドは -1 を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">シークする Unicode 文字。</param>
        <summary>このインスタンス内で最後に出現する指定 Unicode 文字の 0 から始まるインデックス位置をレポートします。</summary>
        <returns>その文字が見つかった場合は、<paramref name="value" /> の 0 から始まるインデックスでの位置。見つからなかった場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は0から始まります。 つまり、文字列の最初の文字はインデックス0になり、最後の文字は- <xref:System.String.Length%2A> 1 になります。  
  
 このメソッドは、このインスタンスの最後の文字位置から検索を開始し、 `value`が見つかるか、または最初の文字位置が検査されるまで、先頭に向かって逆方向に進みます。 検索では大文字と小文字が区別されます。  
  
 このメソッドは、Unicode スカラー値が同じである場合にのみ、文字が別の文字と等価であると見なされる序数 (カルチャに依存しない) 検索を実行します。 カルチャに依存した検索を実行するに<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>は、メソッドを使用します。この場合、合字の "Æ" (U + 00c6) などの構成されていない文字を表す Unicode スカラー値は、カルチャに応じて、"AE" (U + 0041 という, U + 0045) などの正しいシーケンス。  
  
   
  
## Examples  
 次の例では`ExtractFilename` 、 <xref:System.String.LastIndexOf%28System.Char%29>メソッドを使用して、文字列内の最後のディレクトリ区切り文字を検索し、文字列のファイル名を抽出するメソッドを定義しています。 ファイルが存在する場合、メソッドはパスを指定せずにファイル名を返します。  
  
 [!code-csharp[System.String.LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/LastIndexOf_Example.cs#1)]
 [!code-vb[System.String.LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/LastIndexOf_Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <summary>指定された文字列がこのインスタンス内で最後に見つかった 0 から始まるインデックス位置をレポートします。</summary>
        <returns>その文字列が見つかった場合は、<paramref name="value" /> の 0 から始まる開始インデックス位置。見つからなかった場合は -1。 <paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値はこのインスタンスの最後のインデックス位置です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は0から始まります。 つまり、文字列の最初の文字はインデックス0になり、最後の文字は- <xref:System.String.Length%2A> 1 になります。  
  
 検索は、このインスタンスの最後の文字位置から開始し、 `value`が見つかるか、または最初の文字位置が検査されるまで、先頭に向かって逆方向に進みます。  
  
 このメソッドは、現在のカルチャを使用して、単語 (大文字と小文字を区別し、カルチャに依存する) 検索を実行します。  
  
 文字セットには無視できる文字が含まれています。これらの文字は、言語またはカルチャに依存した比較を実行する際には考慮されません。 カルチャに依存した検索では、`value` に無視できる文字が含まれている場合、その文字を削除して検索した場合と同じ結果になります。 が`value` 1 つ以上の無視できる文字で構成さ<xref:System.String.LastIndexOf%28System.String%29>れている<xref:System.String.Length%2A?displayProperty=nameWithType>場合、メソッドは常に-1 を返します。これは、現在のインスタンスの最後のインデックス位置を表します。 次の例では、 <xref:System.String.LastIndexOf%28System.String%29>メソッドを使用して、2つの文字列の3つの部分文字列 (ソフトハイフン (U + 00ad)、ソフトハイフンの後に "n"、ソフトハイフンの後に "m") を検索します。 文字列の 1 つのみにソフト ハイフンが含まれます。 この例が以降で[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]実行されている場合、ソフトハイフンが無視できない文字であるため、結果はに`value`ソフトハイフンが含まれていなかった場合と同じになります。 ソフトハイフンのみを検索する場合、メソッドは6と5を返します。 これらの値は、2つの文字列の最後の文字のインデックスに対応します。  
  
 [!code-csharp[System.String.LastIndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof21.cs#21)]
 [!code-vb[System.String.LastIndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof21.vb#21)]  
  
   
  
## Examples  
 次の例では、タグが文字列の先頭と末尾にある場合に、HTML タグの開始と終了を文字列から削除します。 文字列が右角かっこの文字 (">") で終わっている場合、この例<xref:System.String.LastIndexOf%2A>ではメソッドを使用して終了タグの先頭を検索します。  
  
 [!code-csharp[System.String.LastIndexOf#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof_example2.cs#2)]
 [!code-vb[System.String.LastIndexOf#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof_example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> が <see langword="null" /> です。</exception>
        <block subset="none" type="usage"><para>「[文字列を使用するためのベストプラクティス](~/docs/standard/base-types/best-practices-strings.md)」で説明したように、既定値を置き換える文字列比較メソッドを呼び出さずに、パラメーターを明示的に指定する必要があるメソッドを呼び出すことを避けることをお勧めします。 現在のカルチャの比較規則を使用して、文字列インスタンス内の部分文字列の最後のインデックスを検索する<see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" />には、 <paramref name="comparisonType" />パラメーター <see cref="F:System.StringComparison.CurrentCulture" />に対して値を指定してメソッドオーバーロードを呼び出します。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">シークする Unicode 文字。</param>
        <param name="startIndex">検索の開始位置。 検索は、このインスタンスの先頭に向かって <paramref name="startIndex" /> から開始されます。</param>
        <summary>このインスタンス内で最後に出現する指定 Unicode 文字の 0 から始まるインデックス位置をレポートします。 検索は、指定された文字位置から開始され、文字列の先頭に向かって逆方向に進みます。</summary>
        <returns>その文字が見つかった場合は、<paramref name="value" /> の 0 から始まるインデックス位置。見つからなかった場合、または現在のインスタンスが <see cref="F:System.String.Empty" /> と等しい場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は0から始まります。 つまり、文字列の最初の文字はインデックス0になり、最後の文字は- <xref:System.String.Length%2A> 1 になります。このメソッドは、 `startIndex`このインスタンスの文字位置から検索を開始し、次のいずれかになるまで、現在のインスタンスの先頭に向かって逆方向に進みます。`value`が見つかったか、最初の文字位置が検査されました。 たとえば、が<xref:System.String.Length%2A> - `startIndex` 1 の場合、メソッドは文字列の最後の文字から先頭までのすべての文字を検索します。 検索では大文字と小文字が区別されます。  
  
 このメソッドは、Unicode スカラー値が同じである場合にのみ、文字が別の文字と等価であると見なされる序数 (カルチャに依存しない) 検索を実行します。 カルチャに依存した検索を実行するに<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>は、メソッドを使用します。この場合、合字の "Æ" (U + 00c6) などの構成されていない文字を表す Unicode スカラー値は、カルチャに応じて、"AE" (U + 0041 という, U + 0045) などの正しいシーケンス。  
  
   
  
## Examples  
 次の例では、文字列の末尾から文字列の先頭まで、文字列内のすべての文字が出現する位置のインデックスを検索します。  
  
 [!code-cpp[string.lastindexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof1/CPP/lastixof1.cpp#1)]
 [!code-csharp[string.lastindexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof1/CS/lastixof1.cs#1)]
 [!code-vb[string.lastindexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof1/VB/lastixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> が 0 未満であるか、このインスタンスの長さ以上です。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <param name="startIndex">検索が開始される位置。 検索は、このインスタンスの先頭に向かって <paramref name="startIndex" /> から開始されます。</param>
        <summary>指定された文字列がこのインスタンス内で最後に見つかった 0 から始まるインデックス位置をレポートします。 検索は、指定された文字位置から開始され、文字列の先頭に向かって逆方向に進みます。</summary>
        <returns>その文字列が見つかった場合は、<paramref name="value" /> の 0 から始まる開始インデックス位置。見つからなかった場合、または現在のインスタンスが <see cref="F:System.String.Empty" /> と等しい場合は -1。 <paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値は <paramref name="startIndex" /> かこのインスタンスの最後のインデックス位置のいずれか小さい方です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は0から始まります。 つまり、文字列の最初の文字はインデックス0になり、最後の文字は- <xref:System.String.Length%2A> 1 になります。  
  
 検索は、このインスタンス`startIndex`の文字位置から開始し、 `value`が見つかるか、または最初の文字位置が検査されるまで、先頭に向かって逆方向に進みます。 たとえば、が<xref:System.String.Length%2A> - `startIndex` 1 の場合、メソッドは文字列の最後の文字から先頭までのすべての文字を検索します。  
  
 このメソッドは、現在のカルチャを使用して、単語 (大文字と小文字を区別し、カルチャに依存する) 検索を実行します。  
  
 文字セットには無視できる文字が含まれています。これらの文字は、言語またはカルチャに依存した比較を実行する際には考慮されません。 カルチャに依存した検索では、`value` に無視できる文字が含まれている場合、その文字を削除して検索した場合と同じ結果になります。 が`value` 1 つ以上の無視できる文字で構成さ<xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29>れている`startIndex`場合、メソッドは常にを返します。これは、検索を開始する文字位置です。 次の例<xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29>では、メソッドを使用して、ソフトハイフン (U + 00ad) を含む部分文字列を検索し、最後の "m" を文字列の前または後に含めます。 この例が以降で[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]実行されている場合は、検索文字列のソフトハイフンが無視されるので、メソッドを呼び出してソフトハイフンで構成される部分文字列を検索し、"m" は文字列内の "m" の位置を返します。それを呼び出して substrin を検索します。ソフトハイフンと "n" で構成される g は、"n" の位置を返します。 検索文字列にソフトハイフンのみが含まれている場合、メソッドはの`startIndex`値を表す "m" のインデックスを返します。  
  
 [!code-csharp[System.String.LastIndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof22.cs#22)]
 [!code-vb[System.String.LastIndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof22.vb#22)]  
  
   
  
## Examples  
 次の例では、ターゲット文字列内のすべての文字列のインデックスを検索し、ターゲット文字列の末尾からターゲット文字列の先頭に向かっています。  
  
 [!code-cpp[string.lastindexof7#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf7/CPP/lastixof7.cpp#1)]
 [!code-csharp[string.lastindexof7#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf7/CS/lastixof7.cs#1)]
 [!code-vb[string.lastindexof7#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf7/VB/lastixof7.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> が 0 未満であるか、または現在のインスタンスの長さを超えています。  
  
- または - 
現在のインスタンスが <see cref="F:System.String.Empty" /> と等しく、<paramref name="startIndex" /> が -1 未満であるか、または 0 を超えています。</exception>
        <block subset="none" type="usage"><para>「[文字列を使用するためのベストプラクティス](~/docs/standard/base-types/best-practices-strings.md)」で説明したように、既定値を置き換える文字列比較メソッドを呼び出さずに、パラメーターを明示的に指定する必要があるメソッドを呼び出すことを避けることをお勧めします。 現在のカルチャの比較規則を使用して特定の文字位置の前にある部分文字列のインデックスを検索する<see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />には、 <paramref name="comparisonType" />パラメーター <see cref="F:System.StringComparison.CurrentCulture" />の値がであるメソッドオーバーロードを呼び出します。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * StringComparison -&gt; int" Usage="string.LastIndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <param name="comparisonType">検索の規則を指定する列挙値の 1 つ。</param>
        <summary>指定した文字列が現在の <see cref="T:System.String" /> オブジェクト内で最後に見つかった 0 から始まる位置のインデックスをレポートします。 指定した文字列に使用する検索の種類をパラメーターで指定します。</summary>
        <returns>その文字列が見つかった場合は、<paramref name="value" /> パラメーターの 0 から始まる開始インデックス位置。見つからなかった場合は -1。 <paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値はこのインスタンスの最後のインデックス位置です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は0から始まります。 つまり、文字列の最初の文字はインデックス0になり、最後の文字は- <xref:System.String.Length%2A> 1 になります。  
  
 パラメーター `comparisonType`は、大文字と小`value`文字を区別するか、大文字と小文字を区別しない検索を使用して、現在のカルチャまたはインバリアントカルチャを使用してパラメーターを検索し、word または序数の比較規則を使用するように指定します。  
  
 検索は、このインスタンスの最後の文字位置から開始し、 `value`が見つかるか、または最初の文字位置が検査されるまで、先頭に向かって逆方向に進みます。  
  
   
  
## Examples  
 次の例では、 <xref:System.String.LastIndexOf%2A> <xref:System.StringComparison>列挙体の異なる値を使用して、別の文字列内で最後に出現する文字列を検索するメソッドの3つのオーバーロードを示します。  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> は有効な <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <block subset="none" type="usage"><para>文字セットには無視できる文字が含まれています。これらの文字は、言語またはカルチャに依存した比較を実行する際には考慮されません。 カルチャに依存する検索の場合 (つまり、<paramref name="options" /> が <see cref="F:System.StringComparison.Ordinal" /> または <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> でない場合)、<paramref name="value" /> に無視できる文字が含まれていると、その文字を削除して検索した場合と同じ結果になります。 が<paramref name="value" /> 1 つ以上の無視できる文字で構成さ<see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" />れている<see cref="P:System.String.Length" />場合、メソッドは常に-1 を返します。これは、現在のインスタンスの最後のインデックス位置を表します。  
  
次の例では、 <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" />メソッドを使用して、2つの文字列の3つの部分文字列 (ソフトハイフン (U + 00ad)、ソフトハイフンの後に "n"、ソフトハイフンの後に "m") を検索します。 文字列の 1 つのみにソフト ハイフンが含まれます。 この例が以降で[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]実行されている場合は、ソフトハイフンが無視できる文字であるため、カルチャに依存した検索では、ソフトハイフンが検索文字列に含まれていない場合に返されるのと同じ値が返されます。 ただし、序数検索では、1つの文字列でソフトハイフンが正常に検出され、2番目の文字列に存在しないことが報告されます。  
  
[!code-csharp[System.String.LastIndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof26.cs#26)] [!code-vb[System.String.LastIndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof26.vb#26)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">シークする Unicode 文字。</param>
        <param name="startIndex">検索の開始位置。 検索は、このインスタンスの先頭に向かって <paramref name="startIndex" /> から開始されます。</param>
        <param name="count">検査する文字位置の数。</param>
        <summary>このインスタンス内の部分文字列で最後に出現する指定 Unicode 文字の 0 から始まるインデックス位置をレポートします。 検索は指定された文字位置から開始し、文字列の開始に向かって後方に移動し、文字位置の指定された数だけ行われます。</summary>
        <returns>その文字が見つかった場合は、<paramref name="value" /> の 0 から始まるインデックス位置。見つからなかった場合、または現在のインスタンスが <see cref="F:System.String.Empty" /> と等しい場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は0から始まります。 つまり、文字列の最初の文字はインデックス0になり、最後の文字は- <xref:System.String.Length%2A> 1 になります。  
  
 このメソッドは、 `startIndex`文字位置から検索を開始し、 `value`が見つかったか、また`count`は文字位置が検査されるまで、このインスタンスの先頭に向かって逆方向に進みます。 たとえば、が<xref:System.String.Length%2A> - `startIndex` 1 の場合、メソッドは文字列の`count`最後の文字から後方の文字を検索します。 検索では大文字と小文字が区別されます。  
  
 このメソッドは、Unicode スカラー値が同じである場合にのみ、文字が別の文字と等価であると見なされる序数 (カルチャに依存しない) 検索を実行します。 カルチャに依存した検索を実行するに<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>は、メソッドを使用します。この場合、合字の "Æ" (U + 00c6) などの構成されていない文字を表す Unicode スカラー値は、カルチャに応じて、"AE" (U + 0041 という, U + 0045) などの正しいシーケンス。  
  
   
  
## Examples  
 次の例では、部分文字列の末尾から部分文字列の先頭までの、部分文字列に出現するすべての文字のインデックスを検索します。  
  
 [!code-cpp[string.lastindexof2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof2/CPP/lastixof2.cpp#1)]
 [!code-csharp[string.lastindexof2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof2/CS/lastixof2.cs#1)]
 [!code-vb[string.lastindexof2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof2/VB/lastixof2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> が 0 未満であるか、このインスタンスの長さ以上です。  
  
- または - 
現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> - <paramref name="count" /> + 1 が 0 未満です。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <param name="startIndex">検索が開始される位置。 検索は、このインスタンスの先頭に向かって <paramref name="startIndex" /> から開始されます。</param>
        <param name="count">検査する文字位置の数。</param>
        <summary>指定された文字列がこのインスタンス内で最後に見つかった 0 から始まるインデックス位置をレポートします。 検索は指定された文字位置から開始し、文字列の開始に向かって後方に移動し、文字位置の指定された数だけ行われます。</summary>
        <returns>その文字列が見つかった場合は、<paramref name="value" /> の 0 から始まる開始インデックス位置。見つからなかった場合、または現在のインスタンスが <see cref="F:System.String.Empty" /> と等しい場合は -1。 <paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値は <paramref name="startIndex" /> かこのインスタンスの最後のインデックス位置のいずれか小さい方です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は0から始まります。 つまり、文字列の最初の文字はインデックス0になり、最後の文字は- <xref:System.String.Length%2A> 1 になります。  
  
 検索は、このインスタンス`startIndex`の文字位置から開始し、 `value`が見つかるか、また`count`は文字位置が検査されるまで、先頭に向かって逆方向に進みます。 たとえば、が<xref:System.String.Length%2A> - `startIndex` 1 の場合、メソッドは文字列の`count`最後の文字から後方の文字を検索します。  
  
 このメソッドは、現在のカルチャを使用して、単語 (大文字と小文字を区別し、カルチャに依存する) 検索を実行します。  
  
 文字セットには無視できる文字が含まれています。これらの文字は、言語またはカルチャに依存した比較を実行する際には考慮されません。 カルチャに依存した検索では、`value` に無視できる文字が含まれている場合、その文字を削除して検索した場合と同じ結果になります。 が`value` 1 つ以上の無視できる文字で構成さ<xref:System.String.LastIndexOf%2A>れている`startIndex`場合、メソッドは常にを返します。これは、検索を開始する文字位置です。 次の例<xref:System.String.LastIndexOf%2A>では、2つの文字列の最後の "m" の前にある2つの文字で、ソフトハイフン (U + 00ad) の位置を検索するためにメソッドが使用されています。 文字列の 1 つのみに必要な部分文字列が含まれます。 この例が以降で[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]実行されている場合、どちらの場合も、ソフトハイフンが無視文字であるため、メソッドはカルチャに依存した比較を実行するときに、文字列内の "m" のインデックスを返します。 "m" の後にソフト ハイフンが含まれる最初の文字列の場合、メソッドはソフト ハイフンのインデックスを返すことができず、代わりに "m" のインデックスを返すことに注意してください。  
  
 [!code-csharp[System.String.LastIndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof23.cs#23)]
 [!code-vb[System.String.LastIndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof23.vb#23)]  
  
   
  
## Examples  
 次の例では、部分文字列の末尾から部分文字列の先頭までの文字列の、部分文字列のすべての出現箇所のインデックスを検索します。  
  
 [!code-cpp[string.lastindexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf8/CPP/lastixof8.cpp#1)]
 [!code-csharp[string.lastindexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf8/CS/lastixof8.cs#1)]
 [!code-vb[string.lastindexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf8/VB/lastixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> が負の値です。  
  
- または - 
現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> が負の値です。  
  
- または - 
現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> がこのインスタンスの長さより大きいです。  
  
- または - 
現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> - <paramref name="count" /> + 1 した値がこのインスタンス内にはない位置を指定しています。  
  
- または - 
現在のインスタンスが <see cref="F:System.String.Empty" /> と等しく、<paramref name="start" /> が -1 より小さいか 0 より大きいです。  
  
- または - 
現在のインスタンスが <see cref="F:System.String.Empty" /> と等しく、<paramref name="count" /> が 1 より大きいです。</exception>
        <block subset="none" type="usage"><para>「[文字列を使用するためのベストプラクティス](~/docs/standard/base-types/best-practices-strings.md)」で説明したように、既定値を置き換える文字列比較メソッドを呼び出さずに、パラメーターを明示的に指定する必要があるメソッドを呼び出すことを避けることをお勧めします。 現在のカルチャの比較規則を使用してこの操作を実行するに<see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />は、 <paramref name="comparisonType" />パラメーター <see cref="F:System.StringComparison.CurrentCulture" />に値を指定してメソッドオーバーロードを呼び出します。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <param name="startIndex">検索が開始される位置。 検索は、このインスタンスの先頭に向かって <paramref name="startIndex" /> から開始されます。</param>
        <param name="comparisonType">検索の規則を指定する列挙値の 1 つ。</param>
        <summary>指定した文字列が現在の <see cref="T:System.String" /> オブジェクト内で最後に見つかった 0 から始まる位置のインデックスをレポートします。 検索は、指定された文字位置から開始され、文字列の先頭に向かって逆方向に進みます。 指定した文字列を検索するときに実行する比較の種類をパラメーターで指定します。</summary>
        <returns>その文字列が見つかった場合は、<paramref name="value" /> パラメーターの 0 から始まる開始インデックス位置。見つからなかった場合、または現在のインスタンスが <see cref="F:System.String.Empty" /> と等しい場合は -1。 <paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値は <paramref name="startIndex" /> かこのインスタンスの最後のインデックス位置のいずれか小さい方です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は0から始まります。 つまり、文字列の最初の文字はインデックス0になり、最後の文字は- <xref:System.String.Length%2A> 1 になります。  
  
 検索は`startIndex`文字位置から開始され、 `value`が見つかるか、または最初の文字位置が検査されるまで、後方に進みます。 たとえば、が<xref:System.String.Length%2A> - `startIndex` 1 の場合、メソッドは文字列の最後の文字から先頭までのすべての文字を検索します。  
  
 パラメーター `comparisonType`は、大文字と小`value`文字を区別するか、大文字と小文字を区別しない検索を使用して、現在のカルチャまたはインバリアントカルチャを使用してパラメーターを検索し、word または序数の比較規則を使用するように指定します。  
  
   
  
## Examples  
 次の例では、 <xref:System.String.LastIndexOf%2A> <xref:System.StringComparison>列挙体の異なる値を使用して、別の文字列内で最後に出現する文字列を検索するメソッドの3つのオーバーロードを示します。  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> が 0 未満であるか、または現在のインスタンスの長さを超えています。  
  
- または - 
現在のインスタンスが <see cref="F:System.String.Empty" /> と等しく、<paramref name="startIndex" /> が -1 未満であるか、または 0 を超えています。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> は有効な <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <block subset="none" type="usage"><para>文字セットには無視できる文字が含まれています。これらの文字は、言語またはカルチャに依存した比較を実行する際には考慮されません。 カルチャに依存する検索の場合 (つまり、<paramref name="comparisonType" /> が <see cref="F:System.StringComparison.Ordinal" /> または <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> でない場合)、<paramref name="value" /> に無視できる文字が含まれていると、その文字を削除して検索した場合と同じ結果になります。 が<paramref name="value" /> 1 つ以上の無視できる文字で構成さ<see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />れている<paramref name="startIndex" />場合、メソッドは常にを返します。これは、検索を開始する文字位置です。  
  
次の例では、 <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />メソッドを使用して、ソフトハイフン (U + 00ad) の後に "m" を続け、2つの文字列の最後の "m" から開始します。 文字列の 1 つのみに必要な部分文字列が含まれます。 この例が以降で[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]実行されている場合、どちらの場合も、ソフトハイフンが無視文字であるため、メソッドはカルチャに依存した比較を実行するときに、文字列内の "m" のインデックスを返します。 "m" の後にソフト ハイフンが含まれる最初の文字列の場合、メソッドはソフト ハイフンのインデックスを返すことができず、代わりに "m" のインデックスを返すことに注意してください。 このメソッドは、序数に基づく比較を実行したときのみ、最初の文字列に含まれるソフト ハイフンのインデックスを返します。  
  
[!code-csharp[System.String.LastIndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof25.cs#25)] [!code-vb[System.String.LastIndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof25.vb#25)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <param name="startIndex">検索が開始される位置。 検索は、このインスタンスの先頭に向かって <paramref name="startIndex" /> から開始されます。</param>
        <param name="count">検査する文字位置の数。</param>
        <param name="comparisonType">検索の規則を指定する列挙値の 1 つ。</param>
        <summary>指定された文字列がこのインスタンス内で最後に見つかった 0 から始まるインデックス位置をレポートします。 検索は指定された文字位置から開始し、文字列の開始に向かって後方に移動し、文字位置の指定された数だけ行われます。 指定した文字列を検索するときに実行する比較の種類をパラメーターで指定します。</summary>
        <returns>その文字列が見つかった場合は、<paramref name="value" /> パラメーターの 0 から始まる開始インデックス位置。見つからなかった場合、または現在のインスタンスが <see cref="F:System.String.Empty" /> と等しい場合は -1。 <paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値は <paramref name="startIndex" /> かこのインスタンスの最後のインデックス位置のいずれか小さい方です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は0から始まります。 つまり、文字列の最初の文字はインデックス0になり、最後の文字は- <xref:System.String.Length%2A> 1 になります。  
  
 検索は`startIndex`文字位置から開始され、 `value`が見つかるか、また`count`は文字位置が検査されるまで、前に進みます。 たとえば、が<xref:System.String.Length%2A> - `startIndex` 1 の場合、メソッドは文字列の`count`最後の文字から後方の文字を検索します。  
  
 パラメーター `comparisonType`は、大文字と小`value`文字を区別するか、大文字と小文字を区別しない検索を使用して、現在のカルチャまたはインバリアントカルチャを使用してパラメーターを検索し、word または序数の比較規則を使用するように指定します。  
  
   
  
## Examples  
 次の例では、 <xref:System.String.LastIndexOf%2A> <xref:System.StringComparison>列挙体の異なる値を使用して、別の文字列内で最後に出現する文字列を検索するメソッドの3つのオーバーロードを示します。  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> が負の値です。  
  
- または - 
現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> が負の値です。  
  
- または - 
現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> がこのインスタンスの長さより大きいです。  
  
- または - 
現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> + 1 - <paramref name="count" /> した値がこのインスタンス内にはない位置を指定しています。  
  
- または - 
現在のインスタンスが <see cref="F:System.String.Empty" /> と等しく、<paramref name="start" /> が -1 より小さいか 0 より大きいです。  
  
- または - 
現在のインスタンスが <see cref="F:System.String.Empty" /> と等しく、<paramref name="count" /> が 1 より大きいです。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> は有効な <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <block subset="none" type="usage"><para>文字セットには無視できる文字が含まれています。これらの文字は、言語またはカルチャに依存した比較を実行する際には考慮されません。 カルチャに依存する検索の場合 (つまり、<paramref name="comparisonType" /> が <see cref="F:System.StringComparison.Ordinal" /> または <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> でない場合)、<paramref name="value" /> に無視できる文字が含まれていると、その文字を削除して検索した場合と同じ結果になります。 が<paramref name="value" /> 1 つ以上の無視できる文字で構成さ<see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />れている<paramref name="startIndex" />場合、メソッドは常にを返します。これは、検索を開始する文字位置です。  
  
次の例では、 <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />メソッドを使用して、ソフトハイフン (U + 00ad) の後に "m" を続け、2つの文字列の最後の "m" の前にある最初の文字位置を検索します。 文字列の 1 つのみに必要な部分文字列が含まれます。 この例が以降で[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]実行されている場合、どちらの場合も、ソフトハイフンが無視文字であるため、メソッドはカルチャに依存した比較を実行するときに、文字列内の "m" のインデックスを返します。 ただし、序数による比較を実行する場合は、最初の文字列でのみ部分文字列が検索されます。 ソフトハイフンの後に "m" が続く最初の文字列の場合、メソッドはソフトハイフンのインデックスを返すのではなく、カルチャに依存した比較を実行するときに "m" のインデックスを返すことに注意してください。 このメソッドは、序数に基づく比較を実行したときのみ、最初の文字列に含まれるソフト ハイフンのインデックスを返します。  
  
[!code-csharp[System.String.LastIndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof24.cs#24)] [!code-vb[System.String.LastIndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof24.vb#24)]</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Unicode 配列内の指定した 1 つ以上の文字がこのインスタンスで最後に見つかった 0 から始まるインデックス位置をレポートします。 このインスタンス内で配列内の文字が見つからない場合、このメソッドは -1 を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] -&gt; int" Usage="string.LastIndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">シークする 1 つ以上の文字を格納している、Unicode 文字の配列。</param>
        <summary>Unicode 配列内の指定した 1 つ以上の文字がこのインスタンスで最後に見つかった 0 から始まるインデックス位置をレポートします。</summary>
        <returns><paramref name="anyOf" /> 内の文字がこのインスタンスで最後に見つかった場所のインデックス位置。<paramref name="anyOf" /> 内の文字が見つからなかった場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は0から始まります。  
  
 このメソッドは、このインスタンスの最後の文字位置から検索を開始し、内`anyOf`の文字が見つかるか、または最初の文字位置が検査されるまで、先頭に向かって逆方向に進みます。 検索では大文字と小文字が区別されます。  
  
 このメソッドは、Unicode スカラー値が同じである場合にのみ、文字が別の文字と等価であると見なされる序数 (カルチャに依存しない) 検索を実行します。 カルチャに依存した検索を実行するに<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>は、メソッドを使用します。この場合、合字の "Æ" (U + 00c6) などの構成されていない文字を表す Unicode スカラー値は、カルチャに応じて、"AE" (U + 0041 という, U + 0045) などの正しいシーケンス。  
  
   
  
## Examples  
 次の例では、別の文字列内の文字列 "is" 内の任意の文字が最後に出現する位置のインデックスを検索します。  
  
 [!code-cpp[string.lastindexofany1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny1/CPP/lastixany1.cpp#1)]
 [!code-csharp[string.lastindexofany1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny1/CS/lastixany1.cs#1)]
 [!code-vb[string.lastindexofany1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny1/VB/lastixany1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> が <see langword="null" /> です。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">シークする 1 つ以上の文字を格納している、Unicode 文字の配列。</param>
        <param name="startIndex">検索が開始される位置。 検索は、このインスタンスの先頭に向かって <paramref name="startIndex" /> から開始されます。</param>
        <summary>Unicode 配列内の指定した 1 つ以上の文字がこのインスタンスで最後に見つかった 0 から始まるインデックス位置をレポートします。 検索は、指定された文字位置から開始され、文字列の先頭に向かって逆方向に進みます。</summary>
        <returns><paramref name="anyOf" /> 内の文字がこのインスタンスで最後に見つかった場所のインデックス位置。<paramref name="anyOf" /> 内の文字が見つからなかった場合、または現在のインスタンスが <see cref="F:System.String.Empty" /> と等しい場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は0から始まります。  
  
 このメソッドは、このインスタンス`startIndex`の文字位置から検索を開始し、内`anyOf`の文字が見つかるか、または最初の文字位置が検査されるまで、先頭に向かって逆方向に進みます。 検索では大文字と小文字が区別されます。  
  
 このメソッドは、Unicode スカラー値が同じである場合にのみ、文字が別の文字と等価であると見なされる序数 (カルチャに依存しない) 検索を実行します。 カルチャに依存した検索を実行するに<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>は、メソッドを使用します。この場合、合字の "Æ" (U + 00c6) などの構成されていない文字を表す Unicode スカラー値は、カルチャに応じて、"AE" (U + 0041 という, U + 0045) などの正しいシーケンス。  
  
   
  
## Examples  
 次の例では、文字列 "is" 内の任意の文字が、別の文字列の部分文字列内で最後に出現する位置のインデックスを検索します。  
  
 [!code-cpp[string.lastindexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny2/CPP/lastixany2.cpp#1)]
 [!code-csharp[string.lastindexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny2/CS/lastixany2.cs#1)]
 [!code-vb[string.lastindexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny2/VB/lastixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> がこのインスタンス内にはない位置を指定しています。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">シークする 1 つ以上の文字を格納している、Unicode 文字の配列。</param>
        <param name="startIndex">検索が開始される位置。 検索は、このインスタンスの先頭に向かって <paramref name="startIndex" /> から開始されます。</param>
        <param name="count">検査する文字位置の数。</param>
        <summary>Unicode 配列内の指定した 1 つ以上の文字がこのインスタンスで最後に見つかった 0 から始まるインデックス位置をレポートします。 検索は指定された文字位置から開始し、文字列の開始に向かって後方に移動し、文字位置の指定された数だけ行われます。</summary>
        <returns><paramref name="anyOf" /> 内の文字がこのインスタンスで最後に見つかった場所のインデックス位置。<paramref name="anyOf" /> 内の文字が見つからなかった場合、または現在のインスタンスが <see cref="F:System.String.Empty" /> と等しい場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は0から始まります。  
  
 このメソッドは、このインスタンス`startIndex`の文字位置から検索を開始し、内`anyOf`の文字が見つかるか、または`count`文字位置が検査されるまで、先頭に向かって逆方向に進みます。 検索では大文字と小文字が区別されます。  
  
 このメソッドは、Unicode スカラー値が同じである場合にのみ、文字が別の文字と等価であると見なされる序数 (カルチャに依存しない) 検索を実行します。 カルチャに依存した検索を実行するに<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>は、メソッドを使用します。この場合、合字の "Æ" (U + 00c6) などの構成されていない文字を表す Unicode スカラー値は、カルチャに応じて、"AE" (U + 0041 という, U + 0045) などの正しいシーケンス。  
  
   
  
## Examples  
 次の例では、別の文字列の部分文字列内の文字列 "aid" 内の任意の文字が最後に出現する位置のインデックスを検索します。  
  
 [!code-cpp[string.lastindexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny3/CPP/lastixany3.cpp#1)]
 [!code-csharp[string.lastindexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny3/CS/lastixany3.cs#1)]
 [!code-vb[string.lastindexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny3/VB/lastixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="count" /> または <paramref name="startIndex" /> が負の値です。  
  
- または - 
現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> - <paramref name="count" /> + 1 が 0 未満です。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.String.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.string.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.String" /> オブジェクト内の文字数を取得します。</summary>
        <value>現在の文字列の文字数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティ<xref:System.String.Length%2A>は、Unicode 文字の<xref:System.Char>数ではなく、このインスタンス内のオブジェクトの数を返します。 これは、Unicode 文字が複数の文字で<xref:System.Char>表される可能性があるためです。 クラスを<xref:System.Globalization.StringInfo?displayProperty=nameWithType>使用して、各<xref:System.Char>Unicode 文字ではなくを操作します。  
  
 C やC++などの一部の言語では、null 文字は文字列の末尾を示します。 .NET では、null 文字を文字列に埋め込むことができます。 文字列に1つ以上の null 文字が含まれている場合は、文字列全体の長さに含まれます。 たとえば、次の文字列では、部分文字列 "abc" と "def" が null 文字で区切られています。 プロパティ<xref:System.String.Length%2A>は7を返します。これは、6つの英字と null 文字が含まれていることを示します。  
  
 [!code-cpp[System.String.Class#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/system.string.class.cpp#1)]
 [!code-csharp[System.String.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/System.String.Class.cs#1)]
 [!code-vb[System.String.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/System.String.Class.vb#1)]  
  
   
  
## Examples  
 プロパティの<xref:System.String.Length%2A>例を次に示します。  
  
 [!code-cpp[string.length#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.length/CPP/length.cpp#1)]
 [!code-csharp[string.length#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.length/CS/length.cs#1)]
 [!code-vb[string.length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.length/VB/length.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Normalize">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>バイナリ表現が特定の Unicode 正規形である新しい文字列を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize" />
      <MemberSignature Language="VB.NET" Value="Public Function Normalize () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize();" />
      <MemberSignature Language="F#" Value="member this.Normalize : unit -&gt; string" Usage="string.Normalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この文字列と同じテキスト値を持ち、なおかつ、バイナリ表現が Unicode 正規形 C である新しい文字列を返します。</summary>
        <returns>この文字列と同じテキスト値を持ち、なおかつ、バイナリ表現が正規形 C である新しい文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一部の Unicode 文字には、組み合わせと複合 Unicode 文字のセットで構成される等価のバイナリ表現が複数あります。 たとえば、次のコードポイントは、"ắ" という文字を表すことができます。  
  
-   U+1EAF  
  
-   U + 0103 U + 0301  
  
-   U + 0061 U + 0306 U + 0301  
  
 1つの文字に対して複数の表現が存在すると、検索、並べ替え、照合、およびその他の操作が複雑になります。  
  
 Unicode 規格では、1つの文字に相当するバイナリ表現を指定した場合に1つのバイナリ表現を返す正規化と呼ばれるプロセスが定義されています。 正規化は、正規化形式と呼ばれるいくつかのアルゴリズムを使用して実行できます。これは、さまざまな規則に従います。 .NET では、Unicode 規格で定義されている4つの正規化形式 (C、D、KC、および KD) がサポートされています。 2つの文字列が同じ正規化形式で表される場合は、序数に基づく比較を使用して比較できます。  
  
 2つの文字列を正規化して比較するには、次の手順を実行します。  
  
1.  ファイルやユーザー入力デバイスなどの入力ソースと比較する文字列を取得します。  
  
2.  メソッドを<xref:System.String.Normalize>呼び出して、文字列を正規形 C に正規化します。  
  
3.  2つの文字列を比較する<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>には、メソッドなどの序数の文字列比較をサポートするメソッドを呼び出し、 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> <xref:System.StringComparison>引数<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>としてまたはの値を指定します。 正規化された文字列の配列を並べ替えるに`comparer`は、 <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType>また<xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType>はの値をの<xref:System.Array.Sort%2A?displayProperty=nameWithType>適切なオーバーロードに渡します。  
  
4.  前の手順で示された順序に基づいて、並べ替えられた出力内の文字列を生成します。  
  
 サポートされている Unicode 正規形の説明<xref:System.Text.NormalizationForm?displayProperty=nameWithType>については、「」を参照してください。  
  
   
  
## Examples  
 次の例では、文字列を4つの正規化された各形式に正規化し、文字列が指定した正規化形式に正規化されたことを確認した後、正規化された文字列内のコードポイントを一覧表示します。  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在のインスタンスに、正しくない Unicode 文字が含まれています。</exception>
        <block subset="none" type="usage"><para>メソッド<see cref="Overload:System.String.IsNormalized" />は、 <see langword="false" />文字列内の最初の正規化されていない文字が検出されるとすぐに戻ります。 したがって、文字列に非正規化文字の後に無効な Unicode 文字が含ま<see cref="Overload:System.String.Normalize" />れている場合、 <see cref="Overload:System.String.IsNormalized" />メソッド<see langword="false" />はを返しますが、は<see cref="T:System.ArgumentException" />をスローします。</para></block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.Normalize : System.Text.NormalizationForm -&gt; string" Usage="string.Normalize normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">Unicode 正規形。</param>
        <summary>この文字列と同じテキスト値を持ち、なおかつ、バイナリ表現が、指定された Unicode 正規形である新しい文字列を返します。</summary>
        <returns>この文字列と同じテキスト値を持ち、なおかつ、バイナリ表現が、<paramref name="normalizationForm" /> パラメーターで指定された正規形である新しい文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一部の Unicode 文字には、組み合わせと複合 Unicode 文字のセットで構成される等価のバイナリ表現が複数あります。 1つの文字に対して複数の表現が存在すると、検索、並べ替え、照合、およびその他の操作が複雑になります。  
  
 Unicode 規格では、1つの文字に相当するバイナリ表現を指定した場合に1つのバイナリ表現を返す正規化と呼ばれるプロセスが定義されています。 正規化は、正規化形式と呼ばれるいくつかのアルゴリズムを使用して実行できます。これは、さまざまな規則に従います。 .NET では、Unicode 規格で定義されている4つの正規化形式 (C、D、KC、および KD) がサポートされています。 2つの文字列が同じ正規化形式で表される場合は、序数に基づく比較を使用して比較できます。  
  
 2つの文字列を正規化して比較するには、次の手順を実行します。  
  
1.  ファイルやユーザー入力デバイスなどの入力ソースと比較する文字列を取得します。  
  
2.  文字列を<xref:System.String.Normalize%28System.Text.NormalizationForm%29>指定された正規化形式に正規化するには、メソッドを呼び出します。  
  
3.  2つの文字列を比較する<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>には、メソッドなどの序数の文字列比較をサポートするメソッドを呼び出し、 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> <xref:System.StringComparison>引数<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>としてまたはの値を指定します。 正規化された文字列の配列を並べ替えるに`comparer`は、 <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType>また<xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType>はの値をの<xref:System.Array.Sort%2A?displayProperty=nameWithType>適切なオーバーロードに渡します。  
  
4.  前の手順で示された順序に基づいて、並べ替えられた出力内の文字列を生成します。  
  
 サポートされている Unicode 正規形の説明<xref:System.Text.NormalizationForm?displayProperty=nameWithType>については、「」を参照してください。  
  
   
  
## Examples  
 次の例では、文字列を4つの正規化された各形式に正規化し、文字列が指定した正規化形式に正規化されたことを確認した後、正規化された文字列内のコードポイントを一覧表示します。  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在のインスタンスに、正しくない Unicode 文字が含まれています。</exception>
        <block subset="none" type="usage"><para>メソッド<see cref="Overload:System.String.IsNormalized" />は、 <see langword="false" />文字列内の最初の正規化されていない文字が検出されるとすぐに戻ります。 したがって、文字列に非正規化文字の後に無効な Unicode 文字が含ま<see cref="Overload:System.String.Normalize" />れている場合、 <see cref="Overload:System.String.IsNormalized" />メソッド<see langword="false" />はを返しますが、は<see cref="T:System.ArgumentException" />をスローします。</para></block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Equality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member ( = ) : string * string -&gt; bool" Usage="a = b" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">比較する最初の文字列または <see langword="null" />。</param>
        <param name="b">比較する 2 番目の文字列または <see langword="null" />。</param>
        <summary>指定した 2 つの文字列の値が同一かどうかを判断します。</summary>
        <returns><paramref name="a" /> の値が <paramref name="b" /> の値と同じ場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.String.op_Equality%2A>は、 <xref:System.String>クラスの等値演算子の演算を定義します。 ここでは、例のセクションに示されているようなコードを有効にします。 さらに、演算子は、序数 (大<xref:System.String.Equals%28System.String%2CSystem.String%29>文字と小文字を区別し、カルチャに依存しない) の比較を実行する静的メソッドを呼び出します。  
  
> [!NOTE]
>  Visual Basic コンパイラは、等値演算子をメソッドの<xref:System.String.op_Equality%2A>呼び出しとして解決しません。 代わりに、等値演算子はメソッドの<xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType>呼び出しをラップします。  
  
   
  
## Examples  
 等値演算子の例を次に示します。  
  
 [!code-cpp[system.string.equality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Equality/CPP/equalityop.cpp#1)]
 [!code-csharp[system.string.equality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Equality/CS/equalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator ReadOnlySpan&lt;char&gt; (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.ReadOnlySpan`1&lt;char&gt; op_Implicit(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Implicit(System.String)~System.ReadOnlySpan{System.Char}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As String) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator ReadOnlySpan&lt;char&gt;(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : string -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.string.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Inequality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : string * string -&gt; bool" Usage="System.string.op_Inequality (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">比較する最初の文字列または <see langword="null" />。</param>
        <param name="b">比較する 2 番目の文字列または <see langword="null" />。</param>
        <summary>指定した 2 つの文字列の値が異なるかどうかを判断します。</summary>
        <returns><see langword="true" /> の値が <paramref name="a" /> の値と異なる場合は <paramref name="b" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.String.op_Inequality%2A>は、 <xref:System.String>クラスの非等値演算子の操作を定義します。   これにより、「例」のセクションに示されているようなコードが有効になります。  
  
 さら<xref:System.String.op_Inequality%2A>に、演算子は、序数<xref:System.String.Equals%28System.String%2CSystem.String%29> (大文字と小文字を区別し、カルチャに依存しない) の比較を実行する静的メソッドを呼び出します。  
  
> [!NOTE]
>  Visual Basic コンパイラでは、非等値演算子はメソッドの<xref:System.String.op_Inequality%2A>呼び出しとして解決されません。 代わりに、非等値演算子はメソッドの<xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType>呼び出しをラップします。  
  
   
  
## Examples  
 次の例は、非等値演算子を示しています。  
  
 [!code-cpp[system.string.inequality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Inequality/CPP/inequalityop.cpp#1)]
 [!code-csharp[system.string.inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Inequality/CS/inequalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PadLeft">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の文字列の先頭に空白または指定された Unicode 文字が埋め込まれた指定された長さの新しい文字列を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int -&gt; string" Usage="string.PadLeft totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">結果として生成される文字列の文字数。これは、元の文字数と、埋め込み文字がある場合はその数を加えた数に等しくなります。</param>
        <summary>指定された文字数になるまで左側に空白を埋め込むことで、このインスタンス内の文字を右寄せした新しい文字列を返します。</summary>
        <returns>このインスタンスと等価な新しい文字列。ただし右揃えであり、<paramref name="totalWidth" /> の長さになるまで左側に空白が埋め込まれています。 ただし、<paramref name="totalWidth" /> がこのインスタンスの長さより短い場合、メソッドは既存のインスタンスへの参照を返します。 <paramref name="totalWidth" /> がこのインスタンスの長さと等しい場合、メソッドはこのインスタンスと同一の新しい文字列を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Unicode 空間は、16進数の0x0020 として定義されています。  
  
 メソッド<xref:System.String.PadLeft%28System.Int32%29>は、返された文字列の先頭に埋め込みます。 つまり、右から左に記述された言語で使用すると、文字列の右側の部分が埋め込まれます。  
  
> [!NOTE]
>  メソッドに<xref:System.String.PadLeft%2A>よって現在のインスタンスに空白文字が埋め込まれている場合、このメソッドは現在のインスタンスの値を変更しません。 代わりに、先頭の空白が埋め込まれた新しい文字列を返して、合計の長さが`totalWidth`文字になるようにします。  
  
   
  
## Examples  
 メソッドの<xref:System.String.PadLeft%2A>例を次に示します。  
  
 [!code-cpp[Classic String.PadLeft Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalWidth" /> が 0 未満です。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int * char -&gt; string" Usage="string.PadLeft (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">結果として生成される文字列の文字数。これは、元の文字数と、埋め込み文字がある場合はその数を加えた数に等しくなります。</param>
        <param name="paddingChar">Unicode 埋め込み文字。</param>
        <summary>指定された文字数になるまで左側に指定された Unicode 文字を埋め込むことで、このインスタンス内の文字を右寄せした新しい文字列を返します。</summary>
        <returns>このインスタンスと等価な新しい文字列。ただし右揃えであり、<paramref name="totalWidth" /> の長さになるまで左側に <paramref name="paddingChar" /> の文字が埋め込まれています。 ただし、<paramref name="totalWidth" /> がこのインスタンスの長さより短い場合、メソッドは既存のインスタンスへの参照を返します。 <paramref name="totalWidth" /> がこのインスタンスの長さと等しい場合、メソッドはこのインスタンスと同一の新しい文字列を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.String.PadLeft%28System.Int32%2CSystem.Char%29>は、返された文字列の先頭に埋め込みます。 つまり、右から左に記述された言語で使用すると、文字列の右側の部分が埋め込まれます。  
  
> [!NOTE]
>  メソッドに<xref:System.String.PadLeft%2A>よって現在のインスタンスに空白文字が埋め込まれている場合、このメソッドは現在のインスタンスの値を変更しません。 代わりに、先頭`paddingChar`文字が埋め込まれた新しい文字列を返して、合計の長さが`totalWidth`文字になるようにします。  
  
   
  
## Examples  
 メソッドの<xref:System.String.PadLeft%2A>例を次に示します。  
  
 [!code-cpp[Classic String.PadLeft1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalWidth" /> が 0 未満です。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PadRight">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の文字列の末尾に空白または指定された Unicode 文字が埋め込まれた指定された長さの新しい文字列を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int -&gt; string" Usage="string.PadRight totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">結果として生成される文字列の文字数。これは、元の文字数と、埋め込み文字がある場合はその数を加えた数に等しくなります。</param>
        <summary>指定された文字数になるまで右側に空白を埋め込むことで、この文字列内の文字を左寄せした新しい文字列を返します。</summary>
        <returns>このインスタンスと等価な新しい文字列。ただし左揃えであり、<paramref name="totalWidth" /> の長さになるまで右側に空白が埋め込まれています。 ただし、<paramref name="totalWidth" /> がこのインスタンスの長さより短い場合、メソッドは既存のインスタンスへの参照を返します。 <paramref name="totalWidth" /> がこのインスタンスの長さと等しい場合、メソッドはこのインスタンスと同一の新しい文字列を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Unicode 空間は、16進数の0x0020 として定義されています。  
  
 メソッド<xref:System.String.PadRight%28System.Int32%29>は、返された文字列の末尾に埋め込みます。 つまり、右から左に記述された言語で使用すると、文字列の左側に埋め込まれます。  
  
> [!NOTE]
>  メソッドに<xref:System.String.PadRight%2A>よって現在のインスタンスに空白文字が埋め込まれている場合、このメソッドは現在のインスタンスの値を変更しません。 代わりに、末尾に空白が埋め込まれている新しい文字列を返して、合計の長さ`totalWidth`が文字になるようにします。  
  
   
  
## Examples  
 メソッドの<xref:System.String.PadRight%2A>例を次に示します。  
  
 [!code-cpp[Classic String.PadRight Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalWidth" /> が 0 未満です。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int * char -&gt; string" Usage="string.PadRight (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">結果として生成される文字列の文字数。これは、元の文字数と、埋め込み文字がある場合はその数を加えた数に等しくなります。</param>
        <param name="paddingChar">Unicode 埋め込み文字。</param>
        <summary>指定された文字数になるまで右側に指定された Unicode 文字を埋め込むことで、この文字列内の文字を左寄せした新しい文字列を返します。</summary>
        <returns>このインスタンスと等価な新しい文字列。ただし左揃えであり、<paramref name="totalWidth" /> の長さになるまで右側に <paramref name="paddingChar" /> の文字が埋め込まれています。 ただし、<paramref name="totalWidth" /> がこのインスタンスの長さより短い場合、メソッドは既存のインスタンスへの参照を返します。 <paramref name="totalWidth" /> がこのインスタンスの長さと等しい場合、メソッドはこのインスタンスと同一の新しい文字列を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.String.PadRight%28System.Int32%2CSystem.Char%29>は、返された文字列の末尾に埋め込みます。 つまり、右から左に記述された言語で使用すると、文字列の左側に埋め込まれます。  
  
> [!NOTE]
>  メソッドに<xref:System.String.PadRight%2A>よって現在のインスタンスに空白文字が埋め込まれている場合、このメソッドは現在のインスタンスの値を変更しません。 代わりに、末尾`paddingChar`の文字が埋め込まれた新しい文字列を返して、合計の長さ`totalWidth`が文字になるようにします。  
  
   
  
## Examples  
 メソッドの<xref:System.String.PadRight%2A>例を次に示します。  
  
 [!code-cpp[Classic String.PadRight1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalWidth" /> が 0 未満です。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の文字列から指定された文字数を削除した新しい文字列を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Remove : int -&gt; string" Usage="string.Remove startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="startIndex">文字を削除する際の 0 から始まる開始位置。</param>
        <summary>現在のインスタンスの指定した位置から指定した最後の位置までの全文字が削除された新しい文字列を返します。</summary>
        <returns>この文字列から対象となる文字を取り除いた新しい文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 では[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]、文字列は0から始まります。 `startIndex`パラメーターの値は、0から文字列インスタンスの長さまでの範囲で指定できます。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更しません。 代わりに、元の文字列の位置`startIndex`から末尾までのすべての文字が削除された新しい文字列を返します。  
  
   
  
## Examples  
 メソッドの<xref:System.String.Remove%2A>例を次に示します。 最後から2番目のケースでは、指定したインデックスから文字列の末尾までのすべてのテキストが削除されます。 最後の例では、指定されたインデックスを開始位置として3文字を削除します。  
  
 [!code-cpp[string.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.remove/CPP/r.cpp#1)]
 [!code-csharp[string.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.remove/CS/r.cs#1)]
 [!code-vb[string.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.remove/VB/r.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> が 0 未満です。  
  
- または - 
 <paramref name="startIndex" /> が、この文字列内にはない位置を指定しています。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * int -&gt; string" Usage="string.Remove (startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">文字を削除する際の 0 から始まる開始位置。</param>
        <param name="count">削除する文字数。</param>
        <summary>現在のインスタンス内の指定した位置から指定した文字数が削除された新しい文字列を返します。</summary>
        <returns>このインスタンスから対象となる文字を取り除いた新しい文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 では[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]、文字列は0から始まります。 `startIndex`パラメーターの値は、0から文字列インスタンスの長さまでの範囲で指定できます。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更しません。 代わりに、 `count`パラメーターで指定された文字数が削除された新しい文字列を返します。 文字はで`startIndex`指定された位置で削除されます。  
  
   
  
## Examples  
 次の例は、完全な名前からミドルネームを削除する方法を示しています。  
  
 [!code-cpp[stringremove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringremove/CPP/stringremove.cpp#1)]
 [!code-csharp[stringremove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringremove/CS/stringremove.cs#1)]
 [!code-vb[stringremove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringremove/VB/stringremove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> または <paramref name="count" /> のいずれかが 0 より小さい値です。  
  
- または - 
 <paramref name="startIndex" /> に <paramref name="count" /> を加えたものが、このインスタンスの外部の位置を指定しています。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の文字列に出現する指定した Unicode 文字または <see cref="T:System.String" /> をすべて、別の指定した Unicode 文字または <see cref="T:System.String" /> に置換した新しい文字列を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(char oldChar, char newChar);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char -&gt; string" Usage="string.Replace (oldChar, newChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">置換する Unicode 文字。</param>
        <param name="newChar">出現するすべての <paramref name="oldChar" /> を置換する Unicode 文字。</param>
        <summary>このインスタンスに出現する指定された Unicode 文字をすべて、別の指定された Unicode 文字に置換した新しい文字列を返します。</summary>
        <returns><paramref name="oldChar" /> のすべてのインスタンスが <paramref name="newChar" /> で置き換えられることを除いて、このインスタンスと等価な文字列。 <paramref name="oldChar" /> が現在のインスタンス内に見つからない場合、メソッドは現在のインスタンスを変更せずに返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、検索対象の序数 (大文字と小文字を区別し`oldChar`、カルチャに依存しない) 検索を実行します。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更しません。 代わりに、のすべての`oldChar`出現箇所がに`newChar`置き換えられた新しい文字列を返します。  
  
 このメソッドは変更された文字列を返すため、メソッドの<xref:System.String.Replace%2A>連続した呼び出しを連結して、元の文字列に対して複数の置換を実行できます。 メソッドの呼び出しは左から右に実行されます。 具体的な例を次に示します。  
  
 [!code-csharp[System.String.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace2.cs#2)]
 [!code-vb[System.String.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace2.vb#2)]  
  
   
  
## Examples  
 次の例では、コンマ区切り値リストを作成します。そのためには、一連の数値の間の空白をコンマで区切って指定します。  
  
 [!code-cpp[string.replace1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.replace1/CPP/string.replace1.cpp#1)]
 [!code-csharp[string.replace1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.replace1/CS/string.replace1.cs#1)]
 [!code-vb[string.replace1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.replace1/VB/string.replace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; string" Usage="string.Replace (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">置換される文字列。</param>
        <param name="newValue">出現するすべての <paramref name="oldValue" /> を置換する文字列。</param>
        <summary>現在のインスタンスに出現する指定した文字列をすべて、別に指定した文字列に置換した新しい文字列を返します。</summary>
        <returns><paramref name="oldValue" /> のすべてのインスタンスが <paramref name="newValue" /> で置き換えられることを除いて、現在の文字列と等価な文字列。 <paramref name="oldValue" /> が現在のインスタンス内に見つからない場合、メソッドは現在のインスタンスを変更せずに返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `oldValue`が`newValue` の場合、出現するすべてのが削除されます。`null`  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更しません。 代わりに、のすべての`oldValue`出現箇所がに`newValue`置き換えられた新しい文字列を返します。  
  
 このメソッドは、検索対象の序数 (大文字と小文字を区別し`oldValue`、カルチャに依存しない) 検索を実行します。  
  
 このメソッドは変更された文字列を返すため、メソッドの<xref:System.String.Replace%2A>連続した呼び出しを連結して、元の文字列に対して複数の置換を実行できます。 メソッドの呼び出しは左から右に実行されます。 具体的な例を次に示します。  
  
 [!code-csharp[System.String.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace1.cs#1)]
 [!code-vb[System.String.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace1.vb#1)]  
  
   
  
## Examples  
 次の例は、メソッドを使用し<xref:System.String.Replace%2A>てスペルミスを修正する方法を示しています。  
  
 [!code-cpp[stringreplace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringreplace/CPP/stringreplace.cpp#1)]
 [!code-csharp[stringreplace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringreplace/CS/stringreplace.cs#1)]
 [!code-vb[stringreplace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringreplace/VB/stringreplace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="oldValue" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="oldValue" /> が空の文字列 ("") です。</exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, comparisonType As StringComparison) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * StringComparison -&gt; string" Usage="string.Replace (oldValue, newValue, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="newValue" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, ignoreCase As Boolean, culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * bool * System.Globalization.CultureInfo -&gt; string" Usage="string.Replace (oldValue, newValue, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="newValue" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="ignoreCase">To be added.</param>
        <param name="culture">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このインスタンス内の、指定された文字列または Unicode 文字の配列の要素で区切られた部分文字列を格納する文字列配列を返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Split%2A>は、区切られた文字列を部分文字列に分割する場合に使用します。 文字配列を使用して、0個、1個、または複数の区切り文字<xref:System.String.Split%28System.Char%5B%5D%29> (メソッド) を指定できます。または、文字配列を使用して、0個、1個、または複数の区切り文字列を指定できます。 メソッドの<xref:System.String.Split%2A>オーバーロードを使用すると、メソッド<xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%29> (メソッド) によって返される部分文字列の数を制限し、返された部分文字列に空の文字列<xref:System.String.Split%28System.Char%5B%5D%2CSystem.StringSplitOptions%29>を含めるかどうかを判断できます (メソッドと<xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29>メソッド、または両方を実行する場合<xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29>は<xref:System.String.Split%28System.String%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> (およびメソッド)。  

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

### <a name="alternatives-to-stringsplit"></a>文字列分割の代替手段

 <xref:System.String.Split%2A>メソッドは、区切られた文字列を部分文字列に分割するのに常に最適な方法であるとは限りません。 区切られた文字列の一部の部分文字列を抽出したくない場合、または区切り文字のセットではなくパターンに基づいて文字列を解析する場合は、次の代替手段を検討してください。  
  
### <a name="regular-expressions"></a>正規表現  
 文字列が固定パターンに準拠している場合は、正規表現を使用してその要素を抽出して処理できます。 たとえば、文字列の形式が "*数値**オペランド**数値*" の場合、[正規表現](~/docs/standard/base-types/regular-expressions.md)を使用して文字列の要素を抽出し、処理することができます。 次に例を示します。  
  
 [!code-csharp-interactive[System.String.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt1.cs#8)]
 [!code-vb[System.String.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt1.vb#8)]  
  
 正規表現パターン`(\d+)\s+([-+*/])\s+(\d+)`は次のように定義されています。  
  
|パターン|説明|  
|-------------|-----------------|  
|`(\d+)`|1 個以上の 10 進数と一致します。 これが最初のキャプチャ グループです。|  
|`\s+`|1個以上の空白文字と一致します。|  
|`([-+*/])`|算術演算子の符号 (+、-、*、/) と一致します。 これが 2 番目のキャプチャ グループです。|  
|`\s+`|1個以上の空白文字と一致します。|  
|`(\d+)`|1 個以上の 10 進数と一致します。 これが 3 番目のキャプチャ グループです。|  
  
 また、正規表現を使用して、固定された文字のセットではなく、パターンに基づいて文字列から部分文字列を抽出することもできます。 これは、次のいずれかの条件が発生した場合の一般的なシナリオです。  
  
-   1つ以上の区切り文字が、 <xref:System.String>インスタンス内の区切り記号として機能するとは限りません。  
  
-   区切り文字のシーケンスと数は、変数または unknown です。  
  
 たとえば、メソッドを<xref:System.String.Split%2A>使用して次の文字列を分割することはできません。これC#は、 `vbCrLf` (in) または (Visual Basic) 文字の`\n`数が可変であり、常に区切り記号として機能しないためです。  
  
```text
[This is captured\ntext.]\n\n[\n[This is more captured text.]\n]  
\n[Some more captured text:\n   Option1\n   Option2][Terse text.]  
```  
  
 次の例に示すように、正規表現では、この文字列を簡単に分割できます。  
  
 [!code-csharp-interactive[System.String.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt2.cs#9)]
 [!code-vb[System.String.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt2.vb#9)]  
  
 正規表現パターン`\[([^\[\]]+)\]`は次のように定義されています。  
  
|パターン|説明|  
|-------------|-----------------|  
|`\[`|左角かっこと一致します。|  
|`([^\[\]]+)`|左または右の角かっこではない任意の文字と1回以上一致します。 これが最初のキャプチャ グループです。|  
|`\]`|右角かっこと一致します。|  
  
 メソッドはとほぼ<xref:System.String.Split%2A?displayProperty=nameWithType>同じですが、固定文字セットではなく正規表現パターンに基づいて文字列を分割する点が異なります。 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> たとえば、次の例では、 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>メソッドを使用して、ハイフンとその他の文字のさまざまな組み合わせで区切られた部分文字列を含む文字列を分割しています。  
  
 [!code-csharp-interactive[System.String.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt3.cs#10)]
 [!code-vb[System.String.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt3.vb#10)]  
  
 正規表現パターン`\s-\s?[+*]?\s?-\s`は次のように定義されています。  
  
|パターン|説明|  
|-------------|-----------------|  
|`\s-`|空白文字の後にハイフンが続くパターンに一致します。|  
|`\s?`|0 個または 1 個の空白文字と一致します。|  
|`[+*]?`|+ または * のいずれかの文字の0回または1回の繰り返しに一致します。|  
|`\s?`|0 個または 1 個の空白文字と一致します。|  
|`-\s`|ハイフンの後に空白文字が続くパターンに一致します。|  
  
### <a name="search-methods-and-the-substring-method"></a>検索メソッドと Substring メソッド  
 文字列内のすべての部分文字列に関心がない場合は、一致を開始する位置のインデックスを返す文字列比較メソッドのいずれかを使用することをお勧めします。 その後、 <xref:System.String.Substring%2A>メソッドを呼び出して、必要な部分文字列を抽出できます。 文字列比較のメソッドは次のとおりです。  
  
-   <xref:System.String.IndexOf%2A>。文字列インスタンス内で文字または文字列が最初に出現する位置の0から始まるインデックスを返します。  
  
-   <xref:System.String.IndexOfAny%2A>。文字配列内の任意の文字が最初に出現する位置の、現在の文字列インスタンス内の0から始まるインデックスを返します。  
  
-   <xref:System.String.LastIndexOf%2A>。文字列インスタンス内で文字または文字列が最後に出現する位置の0から始まるインデックスを返します。  
  
-   <xref:System.String.LastIndexOfAny%2A>。文字配列内の文字が最後に出現する位置の、現在の文字列インスタンス内の0から始まるインデックスを返します。  
  
 次の例では<xref:System.String.IndexOf%2A> 、メソッドを使用して、文字列内の期間を検索します。 次に、 <xref:System.String.Substring%2A>メソッドを使用して完全な文を返します。  
  
 [!code-csharp-interactive[System.String.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt4.cs#11)]
 [!code-vb[System.String.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt4.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (params char[] separator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (ParamArray separator As Char()) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(... cli::array &lt;char&gt; ^ separator);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] -&gt; string[]" Usage="string.Split separator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">この文字列から部分文字列を取り出すために区切り文字として使用する文字配列、区切り文字が含まれていない空の配列、または <see langword="null" />。</param>
        <summary>配列内の文字に基づいて文字列を部分文字列に分割します。</summary>
        <returns>このインスタンスを <paramref name="separator" /> の 1 つ以上の文字で区切った部分文字列を要素に格納する配列。 詳細については、「解説」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 文字列が既知の文字のセットで区切られている場合は、 <xref:System.String.Split%28System.Char%5B%5D%29>メソッドを使用して、文字列を部分文字列に区切ることができます。   
  
### <a name="return-value-details"></a>戻り値の詳細  
 区切り文字は、返される配列の要素には含まれません。 たとえば、区切り記号配列に文字 "-" が含まれていて、現在の文字列インスタンスの値が "aa-bb-cc" の場合、メソッドは、"aa"、"bb"、および "cc" の3つの要素を含む配列を返します。  
  
 このインスタンスに内`separator`のいずれの文字も含まれていない場合、返される配列は、このインスタンスを格納する1つの要素で構成されます。  
  
 の`separator`各要素は、個別の区切り文字を定義します。 2つの区切り記号が隣接している場合、またはこのインスタンスの先頭または末尾に区切り記号がある場合、 <xref:System.String.Empty>返される配列内の対応する要素にはが含まれます。 次にいくつかの例を示します。  
  
|文字列値|区切り記号|返された配列|  
|------------------|---------------|--------------------|  
|"42, 12, 19"|新しい Char [] {', ', ' '} (C#)<br /><br /> Char () = {"," c, "" c}) (Visual Basic)|{"42", "", "12", "", "19"}|  
|"42..12..19"|新しい Char [] {'} (C#)<br /><br /> Char () = {"."c} (Visual Basic)|{"42", "", "12", "", "19"}|  
|バナナ|新しい Char [] {'} (C#)<br /><br /> Char () = {"."c} (Visual Basic)|{"バナナ"}|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|新しい Char [] {} (C#)<br /><br /> Char () = {} (Visual Basic)|{"Darb", "Smarba"}|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|null (C#)<br /><br /> Nothing (Visual Basic)|{"Darb", "Smarba"}|  
  
### <a name="the-separator-array"></a>区切り記号配列  
 Separator の各要素は、1つの文字で構成される個別の区切り記号を定義します。 `separator`引数が`null`であるか、または文字を含んでいない場合、メソッドは空白文字を区切り記号として扱います。 空白文字は Unicode 規格で定義されています。メソッドに渡された場合は、を返し`true`ます。 <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>  
  
### <a name="stringsplitchar-and-compiler-overload-resolution"></a>String. Split (Char []) とコンパイラのオーバーロードの解決  
 の<xref:System.String.Split%2A?displayProperty=nameWithType>このオーバーロードの1つのパラメーターは文字配列ですが、次の例に示すように、1つの文字で呼び出すことができます。  
  
 [!code-csharp-interactive[System.String.Split#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split_CompilerResolution1.cs#12)]
 [!code-vb[System.String.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split_CompilerResolution1.vb#12)]  
  
 パラメーターは<xref:System.ParamArrayAttribute>属性で修飾されているため、コンパイラは1つの文字を単一要素の文字配列として解釈します。 `separator` これは、パラメーターを<xref:System.String.Split%2A?displayProperty=nameWithType> `separator`含む他のオーバーロードには当てはまりません。これらのオーバーロードを`separator`引数として文字配列に明示的に渡す必要があります。  
  
### <a name="comparison-details"></a>比較の詳細  
 メソッド<xref:System.String.Split%28System.Char%5B%5D%29>は、 `separator`配列内の1つ以上の文字で区切られたこの文字列の部分文字列を抽出し、それらの部分文字列を配列の要素として返します。  
  
 メソッド<xref:System.String.Split%28System.Char%5B%5D%29>は、大文字と小文字を区別する序数の並べ替え規則を使用して比較を実行することで、区切り記号を検索します。 単語、文字列、および序数の並べ替えの詳細については<xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 、列挙体を参照してください。  
  
### <a name="performance-considerations"></a>パフォーマンスに関する考慮事項  
 メソッド<xref:System.String.Split%2A>は、返された配列オブジェクト<xref:System.String>にメモリを割り当て、配列要素ごとにオブジェクトを割り当てます。 アプリケーションで最適なパフォーマンスが求められる場合や、アプリケーションでメモリ割り当てを管理する必要<xref:System.String.IndexOf%2A>が<xref:System.String.IndexOfAny%2A>ある場合は、メソッドまたはメソッドの使用を検討してください。 また、 <xref:System.String.Compare%2A>メソッドを使用して、文字列内の部分文字列を検索することもできます。  
  
 文字列を区切り文字で分割するに<xref:System.String.IndexOf%2A>は、メソッドまたは<xref:System.String.IndexOfAny%2A>メソッドを使用して、文字列内の区切り記号を検索します。 区切り文字列で文字列を分割するに<xref:System.String.IndexOf%2A>は、メソッドまたは<xref:System.String.IndexOfAny%2A>メソッドを使用して、区切り記号文字列の最初の文字を検索します。 次に、 <xref:System.String.Compare%2A>メソッドを使用して、その最初の文字の後の文字が区切り記号文字列の残りの文字と等しいかどうかを確認します。  
  
 また、複数<xref:System.String.Split%2A>のメソッド呼び出しで同じ文字セットを使用して文字列を分割する場合は、1つの配列を作成し、各メソッド呼び出しでそれを参照することを検討してください。 これにより、各メソッド呼び出しのオーバーヘッドが大幅に減少します。  
  
## Examples  
 次の例では、空白と句読点を区切り記号として扱うことによって、テキストのブロックから個々の単語を抽出する方法を示します。 メソッドのパラメーター`separator`に渡される文字配列は、スペース文字とタブ文字で構成され、いくつかの一般的な区切り記号と共に使用されます。 <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType>  
  
 [!code-csharp-interactive[System.String.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split2.cs#2)]
 [!code-vb[System.String.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>以前の[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]バージョンでは、メソッドに<see cref="M:System.String.Split(System.Char[])" />文字が<see langword="null" />含まれ<paramref name="separator" />ていない、または文字を含んでいないが渡された場合、メソッドは、 <see cref="M:System.String.Trim(System.Char[])" />少し異なる文字のセットを使用して、文字列を分割します。文字列をトリミングします。 .NET Framework 4 以降では、両方のメソッドで同じセットの Unicode 空白文字が使用されます。</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int -&gt; string[]" Usage="string.Split (separator, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">この文字列から部分文字列を取り出すために区切り文字として使用する文字配列、区切り文字が含まれていない空の配列、または <see langword="null" />。</param>
        <param name="count">返される最大の部分文字列数。</param>
        <summary>配列内の文字に基づいて文字列を最大数の部分文字列に分割します。 返される部分文字列の最大数を指定します。</summary>
        <returns>このインスタンスを、<paramref name="separator" /> 配列のいずれかまたは複数の要素 (文字) で区切ることによって取り出された部分文字列を格納する配列。 詳細については、「解説」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 区切り文字は、返される配列の要素には含まれません。  
  
 このインスタンスに内`separator`のいずれの文字も含まれていない場合、返される配列は、このインスタンスを格納する1つの要素で構成されます。 が`count` 0 の場合は、空の配列が返されます。  
  
 パラメーターがで`null`あるか、文字を含んでいない場合は、空白文字が区切り記号と見なされます。 `separator` 空白文字は、Unicode 標準によって定義され`true` 、 <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>メソッドに渡される場合はを返します。  
  
 の`separator`各要素は、個別の区切り文字を定義します。 2つの区切り記号が隣接している場合、またはこのインスタンスの先頭または末尾に区切り記号が<xref:System.String.Empty>ある場合、対応する配列要素にはが含まれます。  
  
 このインスタンスに複数の`count` `count` 部分文字列が含まれている場合は、最初の-1個の部分文字列が戻り値の最初の負の要素で返され、このインスタンスの残りの`count`文字が最後の戻り値の要素。  
  
 が`count`部分文字列の数より大きい場合は、使用可能な部分文字列が返され、例外はスローされません。  
  
 次の表に例を示します。  
  
|文字列値|区切り記号|カウント|返された配列|  
|------------------|---------------|-----------|--------------------|  
|"42, 12, 19"|新しい Char [] {', ', ' '} (C#)<br /><br /> Char () = {"," c "," c} (Visual Basic)|2|{"42", " 12, 19"}|  
|"42..12..19"|新しい Char [] {'} (C#)<br /><br /> Char () = {"."c} (Visual Basic)|4|{"42", "", "12", ".19"}|  
|バナナ|新しい Char [] {'} (C#)<br /><br /> Char () = {"."c} (Visual Basic)|2|{"バナナ"}|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|新しい Char [] {} (C#)<br /><br /> Char () = {} (Visual Basic)|1|{"Darb\nSmarba"}(C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|new Char [] null (C#)<br /><br /> Char () = Nothing|2|{"Darb", "Smarba"}|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|new Char [] null (C#)<br /><br /> Char () = Nothing|100|{"Darb", "Smarba"}|  
  
### <a name="performance-considerations"></a>パフォーマンスに関する考慮事項  
 メソッド<xref:System.String.Split%2A>は、返された配列オブジェクト<xref:System.String>にメモリを割り当て、配列要素ごとにオブジェクトを割り当てます。 アプリケーションで最適なパフォーマンスが求められる場合、 <xref:System.String.IndexOf%2A>またはアプリケーションでメモリ割り当てを管理することが重要な場合は、メソッドまたは<xref:System.String.IndexOfAny%2A> <xref:System.String.Compare%2A>メソッドを使用して文字列内の部分文字列を検索することを検討してください。  
  
 文字列を区切り文字で分割する場合<xref:System.String.IndexOf%2A>は、メソッドまたは<xref:System.String.IndexOfAny%2A>メソッドを使用して、文字列内の区切り記号を検索します。 区切り文字列で文字列を分割する場合<xref:System.String.IndexOf%2A>は、メソッドまたは<xref:System.String.IndexOfAny%2A>メソッドを使用して、区切り記号文字列の最初の文字を検索します。 次に、 <xref:System.String.Compare%2A>メソッドを使用して、その最初の文字の後の文字が区切り記号文字列の残りの文字と等しいかどうかを確認します。  
  
 また、複数<xref:System.String.Split%2A>のメソッド呼び出しで同じ文字セットを使用して文字列を分割する場合は、1つの配列を作成し、各メソッド呼び出しでそれを参照することを検討してください。 これにより、各メソッド呼び出しのオーバーヘッドが大幅に減少します。  
  
   
  
## Examples  
 次の例では`count` 、がによって返される<xref:System.String.Split%2A>文字列の数にどのように影響するかを示します。  
  
 [!code-csharp-interactive[StringSplit2#10](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/StringSplit10.cs#10)]
 [!code-vb[StringSplit2#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit10.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> が負の値です。</exception>
        <block subset="none" type="usage"><para>以前の[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]バージョンでは、メソッドに<see cref="M:System.String.Split(System.Char[])" />文字が<see langword="null" />含まれ<paramref name="separator" />ていない、または文字を含んでいないが渡された場合、メソッドは、 <see cref="M:System.String.Trim(System.Char[])" />少し異なる文字のセットを使用して、文字列を分割します。文字列をトリミングします。 .NET Framework 4 以降では、両方のメソッドで同じセットの Unicode 空白文字が使用されます。</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">この文字列から部分文字列を取り出すために区切り文字として使用する文字配列、区切り文字が含まれていない空の配列、または <see langword="null" />。</param>
        <param name="options">返される配列から空の配列要素を省略する場合は <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />。返される配列に空の配列要素も含める場合は <see cref="F:System.StringSplitOptions.None" />。</param>
        <summary>配列内の文字に基づいて文字列を部分文字列に分割します。 部分文字列が空の配列の要素を含めるかどうかを指定することができます。</summary>
        <returns>この文字列を、<paramref name="separator" /> 配列のいずれかまたは複数の要素 (文字) で区切ることによって取り出された部分文字列を格納する配列。 詳細については、「解説」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
### <a name="return-value-details"></a>戻り値の詳細  
 区切り文字 ( `separator`配列内の文字) は、返される配列の要素には含まれません。 たとえば、配列に`separator`文字 "-" が含まれていて、現在の文字列インスタンスの値が "aa-bb-cc" である場合、メソッドは、"aa"、"bb"、および "cc" の3つの要素を含む配列を返します。  
  
 このインスタンスに内`separator`のいずれの文字も含まれていない場合、返される配列は、このインスタンスを格納する1つの要素で構成されます。  
  
 `options`パラメーターが<xref:System.StringSplitOptions.RemoveEmptyEntries>で、このインスタンスの長さがゼロの場合、メソッドは空の配列を返します。  
  
 の`separator`各要素は、1つの文字で構成される個別の区切り記号を定義します。 引数が<xref:System.StringSplitOptions.None>であり、2つの区切り記号が隣接している場合、またはこのインスタンスの先頭または末尾に区切り記号<xref:System.String.Empty?displayProperty=nameWithType>がある場合、対応する配列要素にはが含まれます。 `options` たとえば、に " `separator` -" と "\_" の2つの要素が含まれている場合、文字列インスタンスの\_値は\_"-aa `options` -" で、引数の<xref:System.StringSplitOptions.None>値はです。このメソッドは、文字列の配列を返します。次の5つの要素があります。  
  
1.  <xref:System.String.Empty?displayProperty=nameWithType>。インデックス0の "-" 文字の前にある空の文字列を表します。  
  
2.  <xref:System.String.Empty?displayProperty=nameWithType>。インデックス0の "-" 文字とインデックス1の "_" 文字の間の空の文字列を表します。  
  
3.  "aa"、  
  
4.  <xref:System.String.Empty?displayProperty=nameWithType>。インデックス4の "_" 文字の後に続く空の文字列を表します。  
  
5.  <xref:System.String.Empty?displayProperty=nameWithType>。インデックス5の "-" 文字の後に続く空の文字列を表します。  
  
### <a name="the-separator-array"></a>区切り記号配列  
 パラメーターがで`null`あるか、文字を含んでいない場合は、空白文字が区切り記号と見なされます。 `separator` 空白文字は、Unicode 標準によって定義され`true` 、 <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>メソッドに渡される場合はを返します。  
  
 このメソッドオーバーロードの呼び出しの`null`パラメーターがの場合、コンパイラのオーバーロードの解決は失敗します。`separator` 呼び出されたメソッドを明確に識別するには`null`、コードでの型を指定する必要があります。 次の例は、このオーバーロードを明確に識別するいくつかの方法を示しています。  
  
 [!code-csharp[System.String.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#5)]
 [!code-vb[System.String.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#5)]  
  
### <a name="comparison-details"></a>比較の詳細  
 メソッド<xref:System.String.Split%2A>は、 `separator`パラメーターの1つ以上の文字で区切られたこの文字列の部分文字列を抽出し、それらの部分文字列を配列の要素として返します。  
  
 メソッド<xref:System.String.Split%2A>は、大文字と小文字を区別する序数の並べ替え規則を使用して比較を実行することで、区切り記号を検索します。 単語、文字列、および序数の並べ替えの詳細については<xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 、列挙体を参照してください。  
  
### <a name="performance-considerations"></a>パフォーマンスに関する考慮事項  
 メソッド<xref:System.String.Split%2A>は、返された配列オブジェクト<xref:System.String>にメモリを割り当て、配列要素ごとにオブジェクトを割り当てます。 アプリケーションで最適なパフォーマンスが求められる場合、 <xref:System.String.IndexOf%2A>またはアプリケーションでメモリ割り当てを管理することが重要な場合は、メソッドまたは<xref:System.String.IndexOfAny%2A> <xref:System.String.Compare%2A>メソッドを使用して文字列内の部分文字列を検索することを検討してください。  
  
 文字列を区切り文字で分割する場合<xref:System.String.IndexOf%2A>は、メソッドまたは<xref:System.String.IndexOfAny%2A>メソッドを使用して、文字列内の区切り記号を検索します。 区切り文字列で文字列を分割する場合<xref:System.String.IndexOf%2A>は、メソッドまたは<xref:System.String.IndexOfAny%2A>メソッドを使用して、区切り記号文字列の最初の文字を検索します。 次に、 <xref:System.String.Compare%2A>メソッドを使用して、その最初の文字の後の文字が区切り記号文字列の残りの文字と等しいかどうかを確認します。  
  
 また、複数<xref:System.String.Split%2A>のメソッド呼び出しで同じ文字セットを使用して文字列を分割する場合は、1つの配列を作成し、各メソッド呼び出しでそれを参照することを検討してください。 これにより、各メソッド呼び出しのオーバーヘッドが大幅に減少します。  
  
   
  
## Examples  
 次の例では<xref:System.StringSplitOptions> 、列挙体を使用して、 <xref:System.String.Split%2A>メソッドによって生成される部分文字列を含めたり除外したりします。  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> は <see cref="T:System.StringSplitOptions" /> 値のいずれでもありません。</exception>
        <block subset="none" type="usage"><para>以前の[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]バージョンでは、メソッドに<see cref="M:System.String.Split(System.Char[])" />文字が<see langword="null" />含まれ<paramref name="separator" />ていない、または文字を含んでいないが渡された場合、メソッドは、 <see cref="M:System.String.Trim(System.Char[])" />少し異なる文字のセットを使用して、文字列を分割します。文字列をトリミングします。 .NET Framework 4 以降では、両方のメソッドで同じセットの Unicode 空白文字が使用されます。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">この文字列から部分文字列を取り出すために区切り文字として使用する文字列配列。区切り文字が含まれていない空の配列。または <see langword="null" />。</param>
        <param name="options">返される配列から空の配列要素を省略する場合は <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />。返される配列に空の配列要素も含める場合は <see cref="F:System.StringSplitOptions.None" />。</param>
        <summary>配列内の文字列に基づいて文字列を部分文字列に分割します。 部分文字列が空の配列の要素を含めるかどうかを指定することができます。</summary>
        <returns>この文字列を、<paramref name="separator" /> 配列のいずれかまたは複数の要素 (文字列) で区切ることによって取り出された部分文字列を格納する配列。 詳細については、「解説」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 文字列が既知の文字列セットで区切られている場合は、 <xref:System.String.Split%2A>メソッドを使用して、文字列を部分文字列に分割できます。  
  
### <a name="return-value-details"></a>戻り値の詳細  
 区切り記号文字列は、返される配列の要素には含まれません。 たとえば、配列に`separator`文字列 "--" が含まれていて、現在の文字列インスタンスの値が "aa--bb-cc" である場合、メソッドは、"aa"、"bb"、および "cc" の3つの要素を含む配列を返します。  
  
 このインスタンスに内`separator`のいずれの文字列も含まれていない場合、返される配列は、このインスタンスを格納する1つの要素で構成されます。  
  
 `options`パラメーターが<xref:System.StringSplitOptions.RemoveEmptyEntries>で、このインスタンスの長さがゼロの場合、メソッドは空の配列を返します。  
  
 の`separator`各要素は、1つ以上の文字で構成される個別の区切り記号を定義します。 引数が<xref:System.StringSplitOptions.None>であり、2つの区切り記号が隣接している場合、またはこのインスタンスの先頭または末尾に区切り記号<xref:System.String.Empty?displayProperty=nameWithType>がある場合、対応する配列要素にはが含まれます。 `options` たとえば、に " `separator` -" と "\_" の2つの要素が含まれている場合、文字列インスタンスの\_値は\_"-aa `options` -" で、引数の<xref:System.StringSplitOptions.None>値はです。このメソッドは、指定された配列次の5つの要素があります。  
  
1.  <xref:System.String.Empty?displayProperty=nameWithType>。インデックス0の "-" 部分文字列の前にある空の文字列を表します。  
  
2.  <xref:System.String.Empty?displayProperty=nameWithType>。インデックス0の "-" 部分文字列とインデックス1の "_" 部分文字列の間の空の文字列を表します。  
  
3.  "aa"、  
  
4.  <xref:System.String.Empty?displayProperty=nameWithType>。インデックス4の "_" 部分文字列の後にある空の文字列を表します。  
  
5.  <xref:System.String.Empty?displayProperty=nameWithType>。インデックス5の "-" 部分文字列の後にある空の文字列を表します。  
  
### <a name="the-separator-array"></a>区切り記号配列  
 内`separator`のいずれかの要素が複数の文字で構成されている場合、部分文字列全体が区切り記号と見なされます。 たとえば、内`separator`のいずれかの要素が "10" である場合、文字列 "This10is10a10string" を分割しようとしています。 は、次の4つの要素から成る配列を返します: {"This"、"is"、"a"、"string" }.  
  
 パラメーターがで`null`あるか、文字を含んでいない場合は、空白文字が区切り記号と見なされます。 `separator` 空白文字は、Unicode 標準によって定義され`true` 、 <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>メソッドに渡される場合はを返します。  
  
 このメソッドオーバーロードの呼び出しの`null`パラメーターがの場合、コンパイラのオーバーロードの解決は失敗します。`separator` 呼び出されたメソッドを明確に識別するには`null`、コードでの型を指定する必要があります。 次の例は、このオーバーロードを明確に識別するいくつかの方法を示しています。  
  
 [!code-csharp[System.String.Split#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#6)]
 [!code-vb[System.String.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#6)]  
  
### <a name="comparison-details"></a>比較の詳細  
 メソッド<xref:System.String.Split%2A>は、 `separator`パラメーター内の1つ以上の文字列で区切られたこの文字列の部分文字列を抽出し、それらの部分文字列を配列の要素として返します。  
  
 メソッド<xref:System.String.Split%2A>は、大文字と小文字を区別する序数の並べ替え規則を使用して比較を実行することで、区切り記号を検索します。 単語、文字列、および序数の並べ替えの詳細については<xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 、列挙体を参照してください。  
  
 メソッドは、値が`null`また`separator`は空の文字列 ("") であるの要素を無視します。 <xref:System.String.Split%2A>  
  
 の`separator`文字列に共通の文字が含まれている場合に<xref:System.String.Split%2A>あいまいな結果を避けるために、操作は最初からインスタンスの値の末尾まで進み、の`separator`最初の要素と一致します。これは、instance. インスタンスでの部分文字列の出現順序は、の`separator`要素の順序よりも優先されます。  
  
 たとえば、値が "abcdef" であるインスタンスについて考えてみます。 の`separator`最初の要素が "ef" で、2番目の要素が "bcde" の場合、split 操作の結果は、"a" と "f" の2つの要素を含む文字列配列になります。 これは、"bcde" というインスタンス内の部分文字列が検出され、部分文字列`separator` "f" が検出される前の内の要素と一致するためです。  
  
 ただし、の最初の`separator`要素が "bcd" で、2番目の要素が "bc" の場合、split 操作の結果は、"a" と "ef" の2つの要素を含む文字列配列になります。 これは、"bcd" が、インスタンス内の`separator`区切り記号と一致するの最初の区切り記号であるためです。 最初の要素が "bc" で、2番目の要素が "bcd" であるために、区切り記号の順序が逆になった場合、結果は、"a" と "def" の2つの要素を含む文字列配列になります。  
  
### <a name="performance-considerations"></a>パフォーマンスに関する考慮事項  
 メソッド<xref:System.String.Split%2A>は、返された配列オブジェクト<xref:System.String>にメモリを割り当て、配列要素ごとにオブジェクトを割り当てます。 アプリケーションで最適なパフォーマンスが求められる場合、 <xref:System.String.IndexOf%2A>またはアプリケーションでメモリ割り当てを管理することが重要な場合は、メソッドまたは<xref:System.String.IndexOfAny%2A> <xref:System.String.Compare%2A>メソッドを使用して文字列内の部分文字列を検索することを検討してください。  
  
 文字列を区切り文字で分割する場合<xref:System.String.IndexOf%2A>は、メソッドまたは<xref:System.String.IndexOfAny%2A>メソッドを使用して、文字列内の区切り記号を検索します。 区切り文字列で文字列を分割する場合<xref:System.String.IndexOf%2A>は、メソッドまたは<xref:System.String.IndexOfAny%2A>メソッドを使用して、区切り記号文字列の最初の文字を検索します。 次に、 <xref:System.String.Compare%2A>メソッドを使用して、その最初の文字の後の文字が区切り記号文字列の残りの文字と等しいかどうかを確認します。  
  
 また、複数<xref:System.String.Split%2A>のメソッド呼び出しで同じ文字セットを使用して文字列を分割する場合は、1つの配列を作成し、各メソッド呼び出しでそれを参照することを検討してください。 これにより、各メソッド呼び出しのオーバーヘッドが大幅に減少します。  
  
   
  
## Examples  
 次の例では、文字列<xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29?displayProperty=nameWithType>のメソッド`options`を呼び出して、そのパラメーターを<xref:System.StringSplitOptions.None?displayProperty=nameWithType>およびと<xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>等しい配列の違いを示します。  
  
 [!code-csharp-interactive[System.String.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split.cs#1)]
 [!code-vb[System.String.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split.vb#1)]  
  
 次の例では、句読点と空白文字を含む区切り記号の配列を定義しています。 この配列をの<xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>値と共<xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29>にメソッドに渡すと、文字列の個々の単語で構成される配列が返されます。  
  
 [!code-csharp-interactive[System.String.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split7.cs#7)]
 [!code-vb[System.String.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split7.vb#7)]  
  
 `options`引数がに<xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>設定された状態でメソッドが呼び出されることに注意してください。 これにより、区切り記号と<xref:System.String.Empty?displayProperty=nameWithType>空白文字の間の空の部分文字列の一致を表す値を、返された配列に含めることができなくなります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> は <see cref="T:System.StringSplitOptions" /> 値のいずれでもありません。</exception>
        <block subset="none" type="usage"><para>以前の[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]バージョンでは、メソッドに<see cref="M:System.String.Split(System.Char[])" />文字が<see langword="null" />含まれ<paramref name="separator" />ていない、または文字を含んでいないが渡された場合、メソッドは、 <see cref="M:System.String.Trim(System.Char[])" />少し異なる文字のセットを使用して、文字列を分割します。文字列をトリミングします。 .NET Framework 4 以降では、両方のメソッドで同じセットの Unicode 空白文字が使用されます。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">この文字列から部分文字列を取り出すために区切り文字として使用する文字配列、区切り文字が含まれていない空の配列、または <see langword="null" />。</param>
        <param name="count">返される最大の部分文字列数。</param>
        <param name="options">返される配列から空の配列要素を省略する場合は <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />。返される配列に空の配列要素も含める場合は <see cref="F:System.StringSplitOptions.None" />。</param>
        <summary>配列内の文字に基づいて文字列を最大数の部分文字列に分割します。</summary>
        <returns>この文字列を、<paramref name="separator" /> 配列のいずれかまたは複数の要素 (文字) で区切ることによって取り出された部分文字列を格納する配列。 詳細については、「解説」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 区切り文字は、返される配列の要素には含まれません。  
  
 このインスタンスに内`separator`の文字が含まれていない場合、 `count`またはパラメーターが1の場合、返される配列は、このインスタンスを格納する1つの要素で構成されます。 パラメーターがで`null`あるか、文字を含んでいない場合は、空白文字が区切り記号と見なされます。 `separator` 空白文字は、Unicode 標準によって定義され`true` 、 <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>メソッドに渡される場合はを返します。 ただし、このメソッド`separator`オーバーロードの呼び出しのパラメーターがの場合、 `null`コンパイラのオーバーロードの解決は失敗します。 呼び出されたメソッドを明確に識別するには、コードが null の型を示す必要があります。 次の例は、このオーバーロードを明確に識別するいくつかの方法を示しています。  
  
 [!code-csharp[System.String.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#3)]
 [!code-vb[System.String.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#3)]  
  
 パラメーターがゼロの場合、 `options`またはパラメーターが<xref:System.StringSplitOptions.RemoveEmptyEntries>で、このインスタンスの長さが0の場合は、空の配列が返されます。 `count`  
  
 の`separator`各要素は、個別の区切り文字を定義します。 パラメーターが<xref:System.StringSplitOptions.None>であり、2つの区切り記号が隣接している場合、またはこのインスタンスの先頭または末尾に区切り記号<xref:System.String.Empty>がある場合、対応する配列要素にはが含まれます。 `options`  
  
 このインスタンスに複数の`count` `count` 部分文字列が含まれている場合は、最初の-1個の部分文字列が戻り値の最初の負の要素で返され、このインスタンスの残りの`count`文字が最後の戻り値の要素。  
  
 が`count`部分文字列の数より大きい場合は、使用可能な部分文字列が返され、例外はスローされません。  
  
### <a name="performance-considerations"></a>パフォーマンスに関する考慮事項  
 メソッド<xref:System.String.Split%2A>は、返された配列オブジェクト<xref:System.String>にメモリを割り当て、配列要素ごとにオブジェクトを割り当てます。 アプリケーションで最適なパフォーマンスが求められる場合、 <xref:System.String.IndexOf%2A>またはアプリケーションでメモリ割り当てを管理することが重要な場合は、メソッドまたは<xref:System.String.IndexOfAny%2A> <xref:System.String.Compare%2A>メソッドを使用して文字列内の部分文字列を検索することを検討してください。  
  
 文字列を区切り文字で分割する場合<xref:System.String.IndexOf%2A>は、メソッドまたは<xref:System.String.IndexOfAny%2A>メソッドを使用して、文字列内の区切り記号を検索します。 区切り文字列で文字列を分割する場合<xref:System.String.IndexOf%2A>は、メソッドまたは<xref:System.String.IndexOfAny%2A>メソッドを使用して、区切り記号文字列の最初の文字を検索します。 次に、 <xref:System.String.Compare%2A>メソッドを使用して、その最初の文字の後の文字が区切り記号文字列の残りの文字と等しいかどうかを確認します。  
  
 また、複数<xref:System.String.Split%2A>のメソッド呼び出しで同じ文字セットを使用して文字列を分割する場合は、1つの配列を作成し、各メソッド呼び出しでそれを参照することを検討してください。 これにより、各メソッド呼び出しのオーバーヘッドが大幅に減少します。  
  
   
  
## Examples  
 次の例では<xref:System.StringSplitOptions> 、列挙体を使用して、 <xref:System.String.Split%2A>メソッドによって生成される部分文字列を含めたり除外したりします。  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> が負の値です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> は <see cref="T:System.StringSplitOptions" /> 値のいずれでもありません。</exception>
        <block subset="none" type="usage"><para>以前の[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]バージョンでは、メソッドに<see cref="M:System.String.Split(System.Char[])" />文字が<see langword="null" />含まれ<paramref name="separator" />ていない、または文字を含んでいないが渡された場合、メソッドは、 <see cref="M:System.String.Trim(System.Char[])" />少し異なる文字のセットを使用して、文字列を分割します。文字列をトリミングします。 .NET Framework 4 以降では、両方のメソッドで同じセットの Unicode 空白文字が使用されます。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">この文字列から部分文字列を取り出すために区切り文字として使用する文字列配列。区切り文字が含まれていない空の配列。または <see langword="null" />。</param>
        <param name="count">返される最大の部分文字列数。</param>
        <param name="options">返される配列から空の配列要素を省略する場合は <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />。返される配列に空の配列要素も含める場合は <see cref="F:System.StringSplitOptions.None" />。</param>
        <summary>配列内の文字列に基づいて文字列を最大数の部分文字列に分割します。 部分文字列が空の配列の要素を含めるかどうかを指定することができます。</summary>
        <returns>この文字列を、<paramref name="separator" /> 配列のいずれかまたは複数の要素 (文字列) で区切ることによって取り出された部分文字列を格納する配列。 詳細については、「解説」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
### <a name="return-value-details"></a>戻り値の詳細  
 区切り記号文字列は、返される配列の要素には含まれません。  
  
 このインスタンスに内`separator`のいずれかの文字列が含まれていない場合、 `count`またはパラメーターが1の場合、返される配列は、このインスタンスを格納する1つの要素で構成されます。 パラメーターがで`null`あるか、文字を含んでいない場合は、空白文字が区切り記号と見なされます。 `separator` 空白文字は、Unicode 標準によって定義され`true` 、 <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>メソッドに渡される場合はを返します。 ただし、このメソッド`separator`オーバーロードの呼び出しのパラメーターがの場合、 `null`コンパイラのオーバーロードの解決は失敗します。 呼び出されたメソッドを明確に識別するには`null`、コードでの型を指定する必要があります。 次の例は、このオーバーロードを明確に識別するいくつかの方法を示しています。  
  
 [!code-csharp[System.String.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#4)]
 [!code-vb[System.String.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#4)]  
  
 パラメーターがゼロの場合、 `options`またはパラメーターが<xref:System.StringSplitOptions.RemoveEmptyEntries>で、このインスタンスの長さが0の場合は、空の配列が返されます。 `count`  
  
 の`separator`各要素は、1つ以上の文字で構成される個別の区切り記号を定義します。 パラメーターが<xref:System.StringSplitOptions.None>であり、2つの区切り記号が隣接している場合、またはこのインスタンスの先頭または末尾に区切り記号<xref:System.String.Empty>がある場合、対応する配列要素にはが含まれます。 `options`  
  
 このインスタンスに複数の`count` `count` 部分文字列が含まれている場合は、最初の-1個の部分文字列が戻り値の最初の負の要素で返され、このインスタンスの残りの`count`文字が最後の戻り値の要素。  
  
 が`count`部分文字列の数より大きい場合は、使用可能な部分文字列が返され、例外はスローされません。  
  
### <a name="the-separator-array"></a>区切り記号配列  
 内`separator`のいずれかの要素が複数の文字で構成されている場合、部分文字列全体が区切り記号と見なされます。 たとえば、内`separator`のいずれかの要素が "10" である場合、文字列 "This10is10a10string" を分割しようとしています。 この4つの要素を持つ配列 {"This"、"is"、"a"、"string" を返します。 }.  
  
### <a name="comparison-details"></a>比較の詳細  
 メソッド<xref:System.String.Split%2A>は、 `separator`パラメーター内の1つ以上の文字列で区切られたこの文字列の部分文字列を抽出し、それらの部分文字列を配列の要素として返します。  
  
 メソッド<xref:System.String.Split%2A>は、大文字と小文字を区別する序数の並べ替え規則を使用して比較を実行することで、区切り記号を検索します。 単語、文字列、および序数の並べ替えの詳細については<xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 、列挙体を参照してください。  
  
 メソッドは、値が`null`また`separator`は空の文字列 ("") であるの要素を無視します。 <xref:System.String.Split%2A>  
  
 の`separator`文字列に共通の文字が含まれている場合に<xref:System.String.Split%2A>あいまいな結果を避けるために、メソッドはインスタンスの値の最初から最後まで処理を進め`separator` 、は、内の区切り記号と等しいの最初の要素と一致します。instance. インスタンスでの部分文字列の出現順序は、の`separator`要素の順序よりも優先されます。  
  
 たとえば、値が "abcdef" であるインスタンスについて考えてみます。 の`separator`最初の要素が "ef" で、2番目の要素が "bcde" の場合、分割操作の結果は "a" と "f" になります。 これは、"bcde" というインスタンス内の部分文字列が検出され、部分文字列`separator` "f" が検出される前の内の要素と一致するためです。  
  
 ただし、の最初の`separator`要素が "bcd" で、2番目の要素が "bc" の場合、split 操作の結果は "a" と "ef" になります。 これは、"bcd" が、インスタンス内の`separator`区切り記号と一致するの最初の区切り記号であるためです。 最初の要素が "bc" で、2番目の要素が "bcd" であるために、区切り記号の順序が逆になった場合、結果は "a" と "def" になります。  
  
### <a name="performance-considerations"></a>パフォーマンスに関する考慮事項  
 メソッド<xref:System.String.Split%2A>は、返された配列オブジェクト<xref:System.String>にメモリを割り当て、配列要素ごとにオブジェクトを割り当てます。 アプリケーションで最適なパフォーマンスが求められる場合、 <xref:System.String.IndexOf%2A>またはアプリケーションでメモリ割り当てを管理することが重要な場合は、メソッドまたは<xref:System.String.IndexOfAny%2A> <xref:System.String.Compare%2A>メソッドを使用して文字列内の部分文字列を検索することを検討してください。  
  
 文字列を区切り文字で分割する場合<xref:System.String.IndexOf%2A>は、メソッドまたは<xref:System.String.IndexOfAny%2A>メソッドを使用して、文字列内の区切り記号を検索します。 区切り文字列で文字列を分割する場合<xref:System.String.IndexOf%2A>は、メソッドまたは<xref:System.String.IndexOfAny%2A>メソッドを使用して、区切り記号文字列の最初の文字を検索します。 次に、 <xref:System.String.Compare%2A>メソッドを使用して、その最初の文字の後の文字が区切り記号文字列の残りの文字と等しいかどうかを確認します。  
  
 また、複数<xref:System.String.Split%2A>のメソッド呼び出しで同じ文字セットを使用して文字列を分割する場合は、1つの配列を作成し、各メソッド呼び出しでそれを参照することを検討してください。 これにより、各メソッド呼び出しのオーバーヘッドが大幅に減少します。  
  
   
  
## Examples  
 次の例では<xref:System.StringSplitOptions> 、列挙体を使用して、 <xref:System.String.Split%2A>メソッドによって生成される部分文字列を含めたり除外したりします。  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> が負の値です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> は <see cref="T:System.StringSplitOptions" /> 値のいずれでもありません。</exception>
        <block subset="none" type="usage"><para>以前の[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]バージョンでは、メソッドに<see cref="M:System.String.Split(System.Char[])" />文字が<see langword="null" />含まれ<paramref name="separator" />ていない、または文字を含んでいないが渡された場合、メソッドは、 <see cref="M:System.String.Trim(System.Char[])" />少し異なる文字のセットを使用して、文字列を分割します。文字列をトリミングします。 .NET Framework 4 以降では、両方のメソッドで同じセットの Unicode 空白文字が使用されます。</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="StartsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>この文字列インスタンスの先頭が、指定した文字列と一致するかどうかを判断します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(char value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : char -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">比較対象の文字列。</param>
        <summary>この文字列インスタンスの先頭が、指定した文字列と一致するかどうかを判断します。</summary>
        <returns>この文字列の先頭が <paramref name="value" /> と一致する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは`value` 、このインスタンスの先頭にある、と`value`同じ長さの部分文字列と比較し、等しいかどうかを示す値を返します。 を同じにする`value`には、が空の<xref:System.String.Empty?displayProperty=nameWithType>文字列 () であるか、この同じインスタンスへの参照であるか、またはこのインスタンスの先頭と一致している必要があります。  
  
 このメソッドは、現在のカルチャを使用して、単語 (大文字と小文字を区別し、カルチャに依存する) 比較を実行します。  
  
   
  
## Examples  
 次の例では`StripStartTags` 、 <xref:System.String.StartsWith%28System.String%29>メソッドを使用して、文字列の先頭から HTML 開始タグを削除するメソッドを定義しています。 このメソッドは`StripStartTags` 、行の先頭にある複数の HTML 開始タグが削除されるように、再帰的に呼び出されることに注意してください。 この例では、文字列に埋め込まれている HTML タグは削除されません。  
  
 [!code-cpp[stringstartswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringstartswith/CPP/stringstartswith.cpp#1)]
 [!code-csharp[stringstartswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringstartswith/CS/stringstartswith.cs#1)]
 [!code-vb[stringstartswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringstartswith/VB/stringstartswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> が <see langword="null" /> です。</exception>
        <block subset="none" type="usage"><para>「[文字列を使用するためのベストプラクティス](~/docs/standard/base-types/best-practices-strings.md)」で説明したように、既定値を置き換える文字列比較メソッドを呼び出さずに、パラメーターを明示的に指定する必要があるメソッドを呼び出すことを避けることをお勧めします。 現在のカルチャの文字列比較規則を使用して、文字列が特定の部分文字列で始まるかどうか<see cref="M:System.String.StartsWith(System.String,System.StringComparison)" />を確認するには、 <see cref="F:System.StringComparison.CurrentCulture" /> <paramref name="comparisonType" />パラメーターの値を指定してメソッドオーバーロードを呼び出します。</para></block>
        <altmember cref="M:System.String.EndsWith(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * StringComparison -&gt; bool" Usage="string.StartsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">比較対象の文字列。</param>
        <param name="comparisonType">この文字列と <paramref name="value" /> との比較方法を決定する列挙値の 1 つ。</param>
        <summary>指定された比較オプションを使って比較した場合に、この文字列インスタンスの先頭が、指定された文字列と一致するかどうかを判断します。</summary>
        <returns>インスタンスが <see langword="true" /> で開始する場合は <paramref name="value" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.String.StartsWith%2A>は、 `value`パラメーターをこの文字列の先頭の部分文字列と比較し、等しいかどうかを示す値を返します。 と等しい場合は`value` 、この同じ文字列への参照であるか、空の文字列 ("") であるか、またはこの文字列の先頭と一致する必要があります。 <xref:System.String.StartsWith%2A>メソッドによって実行される比較の種類は、 `comparisonType`パラメーターの値によって異なります。 比較では、現在のカルチャ (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>および<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>) またはインバリアントカルチャ (<xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType>および<xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>) の規則を使用できます。また、コードポイントの文字単位の比較 (<xref:System.StringComparison.Ordinal?displayProperty=nameWithType>または)を使用することもできます。<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>). 比較では、大文字と小文字<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>を区別する<xref:System.StringComparison.Ordinal?displayProperty=nameWithType>こともできます ( <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType>、、また<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>は) <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>。または、大文字小文字を無視することもできます ( <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>、、)。  
  
   
  
## Examples  
 次の例では、"the" という語で始まる長い文字列の先頭にある文字列 "the" を検索します。 この例の出力に示すように、カルチャを認識<xref:System.String.StartsWith%28System.String%2CSystem.StringComparison%29>しないが大文字と小文字を区別する比較を実行するメソッドへの呼び出しは、文字列に一致しません。一方、カルチャおよび大文字と小文字を区別しない比較を実行する呼び出しは文字列に一致します。  
  
 [!code-cpp[System.String.StartsWith#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/StartsWith2.cpp#2)]
 [!code-csharp[System.String.StartsWith#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/StartsWith2.cs#2)]
 [!code-vb[System.String.StartsWith#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/StartsWith2.vb#2)]  
  
 次の例では、文字列が特定の部分文字列で始まるかどうかを判断します。 2次元の文字列配列を初期化します。 2番目の次元の最初の要素には文字列が含まれ、2番目の要素には、最初の文字列の先頭で検索する文字列が含まれます。 結果は、カルチャの選択、case が無視されるかどうか、および序数に基づく比較が実行されるかどうかによって影響を受けます。 文字列インスタンスに合字が含まれている場合、その連続する文字とのカルチャに依存した比較が正常に行われることに注意してください。  
  
 [!code-cpp[System.String.StartsWith#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/startswith1.cpp#1)]
 [!code-csharp[System.String.StartsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/startswith1.cs#1)]
 [!code-vb[System.String.StartsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/startswith1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> が <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.StartsWith (value, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">比較対象の文字列。</param>
        <param name="ignoreCase">比較時に大文字と小文字の区別を無視する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="culture">この文字列と <paramref name="value" /> との比較方法を決定するカルチャ情報。 <paramref name="culture" /> が <see langword="null" /> の場合は、現在のカルチャが使用されます。</param>
        <summary>指定されたカルチャを使って比較した場合に、この文字列インスタンスの先頭が、指定された文字列と一致するかどうかを判断します。</summary>
        <returns><see langword="true" /> パラメーターがこの文字列の先頭と一致する場合は <paramref name="value" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、 `value`パラメーターを、この文字列の先頭にあるのと`value`同じ長さの部分文字列と比較し、等しいかどうかを示す値を返します。 を同じにする`value`には、が空の<xref:System.String.Empty?displayProperty=nameWithType>文字列 () であるか、この同じインスタンスへの参照であるか、またはこのインスタンスの先頭と一致している必要があります。  
  
 このメソッドは、指定された大文字と小文字の区別とカルチャを使用して比較を実行します。  
  
   
  
## Examples  
 次の例では、文字列が別の文字列の先頭にあるかどうかを判断します。 大文字と小文字の区別、大文字小文字の区別、および検索結果に影響を与えるさまざまなカルチャを使用して、メソッドが複数回呼び出されます。<xref:System.String.StartsWith%2A>  
  
 [!code-csharp[system.string.StartsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.StartsWithCI/cs/swci.cs#1)]
 [!code-vb[system.string.StartsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.StartsWithCI/vb/swci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> は <see langword="null" />です。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Substring">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>インスタンスから部分文字列を取得します。  
  
 このメンバーはオーバーロードされます。 構文、使用方法、例など、このメンバーの詳細については、オーバーロード リストで名前をクリックしてください。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (Index startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(valuetype System.Index startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Index)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Index) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(Index startIndex);" />
      <MemberSignature Language="F#" Value="member this.Substring : Index -&gt; string" Usage="string.Substring startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Index" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="startIndex">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Substring : int -&gt; string" Usage="string.Substring startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">このインスタンス内の部分文字列の 0 から始まる開始文字位置。</param>
        <summary>インスタンスから部分文字列を取得します。 部分文字列は、文字列中の指定した文字の位置で開始し、文字列の末尾まで続きます。</summary>
        <returns>このインスタンスの <paramref name="startIndex" /> で始まる部分文字列と等価な文字列。または、<paramref name="startIndex" /> がこのインスタンスの長さと等しい場合は <see cref="F:System.String.Empty" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Substring%28System.Int32%29>メソッドを呼び出して、指定した文字位置から開始し、文字列の末尾で終わる文字列から部分文字列を抽出します。 開始文字の位置は0から始まります。つまり、文字列の最初の文字は、インデックス1ではなくインデックス0になります。 指定した文字位置から開始し、文字列の末尾より前にある部分文字列を抽出するに<xref:System.String.Substring%28System.Int32%2CSystem.Int32%29>は、メソッドを呼び出します。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更しません。 代わりに、現在の文字列の`startIndex`位置から始まる新しい文字列を返します。  
  
 特定の文字または文字シーケンスで始まる部分文字列を抽出するには、の値<xref:System.String.IndexOf%2A>を<xref:System.String.IndexOf%2A>取得するために、 `startIndex`やなどのメソッドを呼び出します。 2番目の例では、これを示します。"=" 文字の後に1文字位置を開始するキー値を抽出します。  
  
 が`startIndex` 0 に等しい場合、メソッドは元の文字列を変更せずに返します。  
   
  
## Examples  
 文字列から部分文字列を取得する例を次に示します。  
  
 [!code-cpp[System.String.Substring#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.String.Substring/cpp/Substring10.cpp#10)]
 [!code-csharp[System.String.Substring#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring10.cs#10)]
 [!code-vb[System.String.Substring#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring10.vb#10)]  
  
 次の例では<xref:System.String.Substring%2A> 、メソッドを使用して、等号 ("=") 文字で区切られたキーと値のペアを区切ります。  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 文字列<xref:System.String.IndexOf%2A>内の equals 文字の位置を取得するには、メソッドを使用します。 <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29>メソッドを呼び出すと、キー名が抽出されます。キー名は、文字列の最初の文字から始まり、メソッドの<xref:System.String.IndexOf%2A>呼び出しによって返される文字数に対してが拡張されます。 次に、メソッド<xref:System.String.Substring%28System.Int32%29>の呼び出しによって、キーに割り当てられた値が抽出されます。 これは、等号文字を超えて1文字位置から開始し、文字列の末尾まで拡張します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> が、0 未満か、またはこのインスタンスの長さを超えています。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (Range range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(valuetype System.Range range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Range)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(Range range);" />
      <MemberSignature Language="F#" Value="member this.Substring : Range -&gt; string" Usage="string.Substring range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Range" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="range">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.Substring : int * int -&gt; string" Usage="string.Substring (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">このインスタンス内の部分文字列の 0 から始まる開始文字位置。</param>
        <param name="length">部分文字列の文字数。</param>
        <summary>インスタンスから部分文字列を取得します。 この部分文字列は、指定した文字位置から開始し、指定した文字数の文字列です。</summary>
        <returns>このインスタンスの <paramref name="startIndex" /> から始まる長さ <paramref name="length" /> の部分文字列と等価な文字列。または、<paramref name="startIndex" /> がこのインスタンスの長さと等しく、<paramref name="length" /> がゼロの場合は <see cref="F:System.String.Empty" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29>メソッドを呼び出して、指定した文字位置から開始し、文字列の末尾の前にある文字列から部分文字列を抽出します。 開始文字の位置は0から始まります。つまり、文字列の最初の文字は、インデックス1ではなくインデックス0になります。 指定した文字位置から開始し、文字列の末尾まで続く部分文字列を抽出するには、 <xref:System.String.Substring%28System.Int32%29>メソッドを呼び出します。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更しません。 代わりに、現在の文字列の`length` `startIndex`位置から始まる文字を含む新しい文字列を返します。  
  
 パラメーター `length`は、現在の文字列インスタンスから抽出する合計文字数を表します。 これには、インデックス`startIndex`で見つかった開始文字も含まれます。  言い換えると、メソッドは<xref:System.String.Substring%2A>インデックス`startIndex`からインデックス`startIndex`  +  `length` -1 に文字を抽出しようとします。  
  
 特定の文字または文字シーケンスで始まる部分文字列を抽出するには、の値<xref:System.String.IndexOf%2A>を<xref:System.String.LastIndexOf%2A>取得するために、 `startIndex`やなどのメソッドを呼び出します。  
  
 部分文字列をから`startIndex`指定された文字シーケンスに拡張する場合は、や<xref:System.String.LastIndexOf%2A>など<xref:System.String.IndexOf%2A>のメソッドを呼び出して、終了文字または文字シーケンスのインデックスを取得できます。  その後、次のように、その値を文字列内のインデックス位置に変換できます。  
  
-   部分文字列の末尾を示す1文字を検索`length`した場合、 `endIndex`  -  <xref:System.String.IndexOf%2A> `startIndex`パラメーターは + 1 になります。ここ`endIndex`で、は、または<xref:System.String.IndexOf%2A>の戻り値です。b. 次の例では、文字列から "b" 文字の連続ブロックを抽出します。  
  
     [!code-csharp[System.String.Substring#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring2.cs#2)]
     [!code-vb[System.String.Substring#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring2.vb#2)]  
  
-   部分文字列`length`の末尾を示す複数の文字を検索した場合、パラメーターはと同じ`endIndex`  +  `startIndex` `endMatchLength`  - になります`endIndex` 。ここで、はの戻り値です。<xref:System.String.IndexOf%2A>または<xref:System.String.IndexOf%2A>メソッド、 `endMatchLength`およびは、部分文字列の末尾を示す文字シーケンスの長さです。 次の例では、XML `<definition>`要素を含むテキストのブロックを抽出します。  
  
     [!code-csharp[System.String.Substring#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring3.cs#3)]
     [!code-vb[System.String.Substring#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring3.vb#3)]  
  
-   文字または文字のシーケンス`length`が部分文字列の末尾に含まれていない場合、パラメーターはと等しく`endIndex`  -  <xref:System.String.IndexOf%2A> `startIndex`なります。ここ`endIndex`で<xref:System.String.IndexOf%2A> 、は、またはの戻り値です。b.  
  
 が`startIndex` 0 で、現在の文字列の長さと等しい場合、メソッドは元の文字列を変更せずに返します。  
  
   
  
## Examples  
 次の例は、6番目の<xref:System.String.Substring%28System.Int32%2CSystem.Int32%29>文字位置 (つまり、インデックス 5) から始まる文字列から2つの文字を抽出するメソッドの単純な呼び出しを示しています。  
  
 [!code-csharp[System.String.Substring#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring4.cs#4)]
 [!code-vb[System.String.Substring#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring4.vb#4)]  
  
 次の例では<xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> 、次の3つのケースでメソッドを使用して、文字列内で部分文字列を分離します。 2つのケースでは、部分文字列が比較に使用されます。3番目のケースでは、無効なパラメーターが指定されているため、例外がスローされます。  
  
-   このメソッドは、文字列内の1文字と3番目の位置 (インデックス 2) を抽出し、それを "c" と比較します。 この比較は`true`を返します。  
  
-   文字列の4番目の位置 (インデックス 3) から開始してゼロ文字を抽出し、 <xref:System.String.IsNullOrEmpty%2A>メソッドに渡します。 これは、 <xref:System.String.Substring%2A>メソッドへの呼び出しがを返す<xref:System.String.Empty?displayProperty=nameWithType>ため、true を返します。  
  
-   文字列の4番目の位置から1文字を抽出しようとします。 その位置に文字がないため、メソッドの呼び出しでは<xref:System.ArgumentOutOfRangeException>例外がスローされます。  
  
 [!code-csharp[Classic String.Substring1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.Substring1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.Substring1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.Substring1 Example/VB/source.vb#1)]  
  
 次の例では<xref:System.String.Substring%2A> 、メソッドを使用して、等号 ("=") 文字で区切られたキーと値のペアを区切ります。  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 文字列<xref:System.String.IndexOf%2A>内の equals 文字の位置を取得するには、メソッドを使用します。 <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29>メソッドを呼び出すと、キー名が抽出されます。キー名は、文字列の最初の文字から始まり、メソッドの<xref:System.String.IndexOf%2A>呼び出しによって返される文字数に対してが拡張されます。 次に、メソッド<xref:System.String.Substring%28System.Int32%29>の呼び出しによって、キーに割り当てられた値が抽出されます。 これは、等号文字を超えて1文字位置から開始し、文字列の末尾まで拡張します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> に<paramref name="length" /> を加算した値はこのインスタンスの範囲外である位置を示します。  
  
または 
 <paramref name="startIndex" /> または <paramref name="length" /> が 0 未満です。</exception>
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Char&gt;.GetEnumerator" ExplicitInterfaceMemberName="System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;char&gt; IEnumerable&lt;char&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;char&gt; System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#Generic#IEnumerable&lt;char&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of Char) Implements IEnumerable(Of Char).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;char&gt; ^ System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;char&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.String" /> オブジェクトを反復処理する列挙子を返します。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトを反復処理するために使用できる、厳密に型指定された列挙子。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 このメソッドは、 <xref:System.String>インスタンスが<xref:System.Collections.Generic.IEnumerable%601>インターフェイスオブジェクトにキャストされている場合にのみ使用できます。 詳細については、<xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> メソッドを参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.String" /> オブジェクトを反復処理する列挙子を返します。</summary>
        <returns>現在の文字列を反復処理するために使用できる列挙子。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.Collections.IEnumerable> インターフェイスにキャストされる場合のみ、使用できます。 詳細については、<xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType> メソッドを参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">このパラメーターは無視されます。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>現在の文字列の値が <see langword="true" /> の場合は <see cref="F:System.Boolean.TrueString" />。現在の文字列の値が <see langword="false" /> の場合は <see cref="F:System.Boolean.FalseString" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合のみ、使用できます。 別の<xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType>方法として、メソッドを呼び出すことをお勧めします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">現在の文字列の値が <see cref="F:System.Boolean.TrueString" /> または <see cref="F:System.Boolean.FalseString" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合のみ、使用できます。 別の<xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法として、メソッドを呼び出すことをお勧めします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">現在の <see cref="T:System.String" /> オブジェクトの値を解析できません。</exception>
        <exception cref="T:System.OverflowException">現在の <see cref="T:System.String" /> オブジェクトの値は、<see cref="F:System.Byte.MaxValue" /> より大きい数か、<see cref="F:System.Byte.MinValue" />&lt;bpt i="1000001" x="1000001" type="formatting"&gt;{b&amp;gt;&lt;/bpt&gt; &lt;ept i="1000001"&gt;&amp;lt;b}&lt;/ept&gt;未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトのインデックス 0 位置にある文字。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合のみ、使用できます。 別の<xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法として、メソッドを呼び出すことをお勧めします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの説明については、<see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" /> のトピックを参照してください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合のみ、使用できます。 別の<xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法として、メソッドを呼び出すことをお勧めします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの説明については、<see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" /> のトピックを参照してください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合のみ、使用できます。 別の<xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法として、メソッドを呼び出すことをお勧めします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">現在の <see cref="T:System.String" /> オブジェクトの値を解析できません。</exception>
        <exception cref="T:System.OverflowException">現在の <see cref="T:System.String" /> オブジェクトの値は、<see cref="F:System.Decimal.MinValue" /> 未満か、<see cref="F:System.Decimal.MaxValue" /> より大きい数です。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合のみ、使用できます。 別の<xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法として、メソッドを呼び出すことをお勧めします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">現在の <see cref="T:System.String" /> オブジェクトの値を解析できません。</exception>
        <exception cref="T:System.OverflowException">現在の <see cref="T:System.String" /> オブジェクトの値は、<see cref="F:System.Double.MinValue" /> 未満か、<see cref="F:System.Double.MaxValue" /> より大きい数です。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合のみ、使用できます。 別の<xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法として、メソッドを呼び出すことをお勧めします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">現在の <see cref="T:System.String" /> オブジェクトの値を解析できません。</exception>
        <exception cref="T:System.OverflowException">現在の <see cref="T:System.String" /> オブジェクトの値は、<see cref="F:System.Int16.MaxValue" /> より大きい数か、<see cref="F:System.Int16.MinValue" />&lt;bpt i="1000001" x="1000001" type="formatting"&gt;{b&amp;gt;&lt;/bpt&gt; &lt;ept i="1000001"&gt;&amp;lt;b}&lt;/ept&gt;未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの説明については、<see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" /> のトピックを参照してください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合のみ、使用できます。 別の<xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法として、メソッドを呼び出すことをお勧めします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの説明については、<see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" /> のトピックを参照してください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合のみ、使用できます。 別の<xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法として、メソッドを呼び出すことをお勧めします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの説明については、<see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" /> のトピックを参照してください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合のみ、使用できます。 別の<xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法として、メソッドを呼び出すことをお勧めします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">現在の <see cref="T:System.String" /> オブジェクトの値を解析できません。</exception>
        <exception cref="T:System.OverflowException">現在の <see cref="T:System.String" /> オブジェクトの値は、<see cref="F:System.SByte.MaxValue" /> より大きい数か、<see cref="F:System.SByte.MinValue" />&lt;bpt i="1000001" x="1000001" type="formatting"&gt;{b&amp;gt;&lt;/bpt&gt; &lt;ept i="1000001"&gt;&amp;lt;b}&lt;/ept&gt;未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合のみ、使用できます。 別の<xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法として、メソッドを呼び出すことをお勧めします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToString">
      <MemberSignature Language="C#" Value="string IConvertible.ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IConvertible.ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (provider As IFormatProvider) As String Implements IConvertible.ToString" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IConvertible.ToString(IFormatProvider ^ provider) = IConvertible::ToString;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">取得するオブジェクトの型。</param>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合のみ、使用できます。 別の<xref:System.Convert.ChangeType%2A>方法として、メソッドを呼び出すことをお勧めします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.InvalidCastException">現在の <see cref="T:System.String" /> オブジェクトの値を、<paramref name="type" /> パラメーターで指定された型に変換できません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合のみ、使用できます。 別の<xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法として、メソッドを呼び出すことをお勧めします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">現在の <see cref="T:System.String" /> オブジェクトの値を解析できません。</exception>
        <exception cref="T:System.OverflowException">現在の <see cref="T:System.String" /> オブジェクトの値は、<see cref="F:System.UInt16.MaxValue" /> より大きい数か、<see cref="F:System.UInt16.MinValue" />&lt;bpt i="1000001" x="1000001" type="formatting"&gt;{b&amp;gt;&lt;/bpt&gt; &lt;ept i="1000001"&gt;&amp;lt;b}&lt;/ept&gt;未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの説明については、<see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" /> のトピックを参照してください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合のみ、使用できます。 別の<xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法として、メソッドを呼び出すことをお勧めします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">現在の <see cref="T:System.String" /> オブジェクトの値を解析できません。</exception>
        <exception cref="T:System.OverflowException">現在の <see cref="T:System.String" /> オブジェクトの値は、<see cref="F:System.UInt32.MaxValue" /> より大きい数か、<see cref="F:System.UInt32.MinValue" />&lt;bpt i="1000001" x="1000001" type="formatting"&gt;{b&amp;gt;&lt;/bpt&gt; &lt;ept i="1000001"&gt;&amp;lt;b}&lt;/ept&gt;未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの説明については、<see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" /> のトピックを参照してください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合のみ、使用できます。 別の<xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法として、メソッドを呼び出すことをお勧めします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToCharArray">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このインスタンスの文字を Unicode 文字配列へコピーします。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray();" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : unit -&gt; char[]" Usage="string.ToCharArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このインスタンスの文字を Unicode 文字配列へコピーします。</summary>
        <returns>このインスタンスの各文字を要素とする Unicode 文字配列。 このインスタンスが空の文字列である場合、返される配列は空で、長さは 0 になります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、文字列内の各文字 ( <xref:System.Char>つまり、各オブジェクト) を文字配列にコピーします。 コピーされた最初の文字は、返された文字配列のインデックス0になります。コピーされた最後の文字<xref:System.Array.Length%2A?displayProperty=nameWithType>は、インデックス-1 になります。  
  
 文字配列内の文字から文字列を作成するには、 <xref:System.String.%23ctor%28System.Char%5B%5D%29>コンストラクターを呼び出します。  
  
 文字列内のエンコードされた文字を含むバイト配列を作成するには<xref:System.Text.Encoding> 、適切なオブジェクト<xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=nameWithType>をインスタンス化し、そのメソッドを呼び出します。 .NET で使用できる標準エンコーディングには、次のようなものがあります。  
  
|エンコード|Object|  
|--------------|------------|  
|ASCII|<xref:System.Text.ASCIIEncoding>|  
|UTF-7|<xref:System.Text.UTF7Encoding>|  
|UTF-8|<xref:System.Text.UTF8Encoding>|  
|UTF-16|<xref:System.Text.UnicodeEncoding>|  
|UTF-32|<xref:System.Text.UTF32Encoding>|  
  
 詳細については、「 [.net での文字エンコード](~/docs/standard/base-types/character-encoding.md)」を参照してください。  
  
   
  
## Examples  
 次の例では<xref:System.String.ToCharArray%2A> 、メソッドを呼び出して、文字列内の文字を文字配列に抽出しています。 次に、元の文字列と配列内の要素が表示されます。  
  
 [!code-csharp[System.String.ToCharArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tochararray/cs/ToCharArray1.cs#1)]
 [!code-vb[System.String.ToCharArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tochararray/vb/ToCharArray1.vb#1)]  
  
 次の例では、区切り記号で区切られた文字列で区切り文字として機能する文字を含む文字列を定義します。 次に、 <xref:System.String.ToCharArray%2A>メソッドを呼び出して、区切られた文字列を個々の部分<xref:System.String.Split%28System.Char%5B%5D%29>文字列に分割するためにメソッドに渡すことができる文字配列を作成します。  
  
 [!code-cpp[StringSplit2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringSplit2/CPP/stringsplit2.cpp#1)] 
 [!code-csharp[StringSplit2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/stringsplit2.cs#1)] 
 [!code-vb[StringSplit2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit2.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
      </Docs>
    </Member>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray (startIndex As Integer, length As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : int * int -&gt; char[]" Usage="string.ToCharArray (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">このインスタンス内の部分文字列の開始位置。</param>
        <param name="length">このインスタンス内の部分文字列の長さ。</param>
        <summary>このインスタンスの指定した部分文字列の文字を Unicode 文字配列へコピーします。</summary>
        <returns>文字位置 <paramref name="startIndex" /> から始まる、このインスタンス内の文字の <paramref name="length" /> 数を要素とする Unicode 文字配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、文字列の一部の文字を文字配列にコピーします。 文字配列内の文字範囲から文字列を作成するには、 <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>コンストラクターを呼び出します。  
  
 `startIndex`パラメーターは0から始まります。 つまり、文字列インスタンス内の最初の文字のインデックスは0です。  
  
 が`length` 0 の場合、返される配列は空で、長さは0になります。 このインスタンスが`null`または空の文字列 ("") の場合、返される配列は空で、長さは0になります。  
  
 文字列の一部にエンコードされた文字を含むバイト配列を作成するには、適切<xref:System.Text.Encoding>なオブジェクトをインスタンス<xref:System.Text.Encoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29>化し、そのメソッドを呼び出します。 .NET で使用できる標準エンコーディングには、次のようなものがあります。  
  
|エンコード|Object|  
|--------------|------------|  
|ASCII|<xref:System.Text.ASCIIEncoding>|  
|UTF-7|<xref:System.Text.UTF7Encoding>|  
|UTF-8|<xref:System.Text.UTF8Encoding>|  
|UTF-16|<xref:System.Text.UnicodeEncoding>|  
|UTF-32|<xref:System.Text.UTF32Encoding>|  
  
 詳細については、「 [.net での文字エンコード](~/docs/standard/base-types/character-encoding.md)」を参照してください。  
  
   
  
## Examples  
 次の例では、文字列内の部分文字列を文字の配列に変換してから、配列の要素を列挙して表示します。  
  
 [!code-cpp[string.tochararray1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.ToCharArray1/CPP/tocharry1.cpp#1)]
 [!code-csharp[string.tochararray1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.ToCharArray1/CS/tocharry1.cs#1)]
 [!code-vb[string.tochararray1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.ToCharArray1/VB/tocharry1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> または <paramref name="length" /> が 0 未満です。  
  
- または - 
 <paramref name="startIndex" /> に <paramref name="length" /> を加算した値がこのインスタンスの長さを超えています。</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToLower">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>この文字列のコピーを小文字に変換して返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower();" />
      <MemberSignature Language="F#" Value="member this.ToLower : unit -&gt; string" Usage="string.ToLower " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この文字列のコピーを小文字に変換して返します。</summary>
        <returns>小文字の文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、現在のカルチャの大文字と小文字の規則を考慮します。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更しません。 代わりに、現在のインスタンス内のすべての文字が小文字に変換される新しい文字列が返されます。  
  
## <a name="security-considerations"></a>セキュリティの考慮事項  
 メソッドを<xref:System.String.ToLower>呼び出した結果として得られる大文字と小文字の演算では、現在のカルチャの大文字と小文字の表記規則が考慮されます。 ファイル名、名前付きパイプ、レジストリキーなど、オペレーティングシステム識別子の小文字または大文字のバージョンが必要な場合は、メソッド<xref:System.String.ToLowerInvariant%2A>また<xref:System.String.ToUpperInvariant%2A>はメソッドを使用します。 これにより、( <xref:System.String.ToLower>メソッドとは異なり) すべてのカルチャで同じ結果が生成され、より効率的に実行されます。  
  
   
  
## Examples  
 次の例では、複数の大文字と小文字が混在する文字列を小文字に変換します。  
  
 [!code-cpp[stringlowerupper#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringlowerupper/CPP/stringtolower.cpp#1)]
 [!code-csharp[stringlowerupper#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringlowerupper/CS/stringtolower.cs#1)]
 [!code-vb[stringlowerupper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringlowerupper/VB/stringtolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>「[文字列を使用するためのベストプラクティス](~/docs/standard/base-types/best-practices-strings.md)」で説明されているように、既定値を置き換える文字列の大文字と小文字の使い分けメソッドを呼び出さずに、パラメーターを明示的に指定する必要があるメソッドを呼び出すことをお勧めします。 現在のカルチャの大文字と小文字の表記規則を使用して文字を<see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" />小文字に変換するに<see cref="P:System.Globalization.CultureInfo.CurrentCulture" />は、 <paramref name="culture" />パラメーターの値を指定してメソッドオーバーロードを呼び出します。</para></block>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToLower : System.Globalization.CultureInfo -&gt; string" Usage="string.ToLower culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="culture">カルチャ固有の大文字と小文字の規則を提供するオブジェクト。</param>
        <summary>指定されたカルチャの大文字と小文字の規則を使用して、この文字列のコピーを小文字に変換して返します。</summary>
        <returns>現在の文字列を小文字にしたもの。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `culture`パラメーターで指定されたカルチャの大文字と小文字の規則によって、文字列の大文字と小文字の変更方法が決まります。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更しません。 代わりに、現在のインスタンス内のすべての文字が小文字に変換される新しい文字列が返されます。  
  
## <a name="security-considerations"></a>セキュリティの考慮事項  
 メソッドに<xref:System.String.ToLower%28System.Globalization.CultureInfo%29>以外<xref:System.Globalization.CultureInfo>のオブジェクトを渡すと、大文字と小文字の操作によってカルチャ固有の規則が考慮されます。 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> ファイル名、名前付きパイプ、レジストリキーなど、オペレーティングシステム識別子の小文字または大文字のバージョンが必要な場合は、メソッド<xref:System.String.ToLowerInvariant%2A>また<xref:System.String.ToUpperInvariant%2A>はメソッドを使用します。 これにより、すべてのカルチャで同じ結果が生成され、より効率的に実行されます。  
  
   
  
## Examples  
 次の例では、大文字の2つの文字列を、英語 (米国) とトルコ語 (トルコ) のカルチャを使用して小文字に変換し、その後、小文字の文字列を比較します。 大文字の文字列は同じですが、1つの文字列に Unicode ラテン大文字 I が出現するたびに、もう一方の文字列には上記のドット付きのラテン大文字 I が含まれている点が異なります。  
  
 [!code-cpp[string.tolower1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tolower1/CPP/tolower.cpp#1)]
 [!code-csharp[string.tolower1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tolower1/CS/tolower.cs#1)]
 [!code-vb[string.tolower1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tolower1/VB/tolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> は <see langword="null" />です。</exception>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.ToUpper" />
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public string ToLowerInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLowerInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLowerInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLowerInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLowerInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToLowerInvariant : unit -&gt; string" Usage="string.ToLowerInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>インバリアント カルチャの大文字と小文字の規則を使用して、この <see cref="T:System.String" /> オブジェクトのコピーを小文字に変換して返します。</summary>
        <returns>現在の文字列を小文字にしたもの。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インバリアントカルチャは、カルチャを認識しないカルチャを表します。 英語と関連付けられていますが、特定の国または地域には関連付けられていません。 詳細については、<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> プロパティを参照してください。  
  
 現在のカルチャの影響を受けない予測可能な方法で文字列が変更された場合にアプリケーションが依存し<xref:System.String.ToLowerInvariant%2A>ている場合は、メソッドを使用します。 メソッド<xref:System.String.ToLowerInvariant%2A>は、 `ToLower(CultureInfo.InvariantCulture)`と同じです。 文字列のコレクションをユーザーインターフェイスコントロールで予測可能な順序で表示する必要がある場合は、メソッドをお勧めします。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更しません。 代わりに、現在のインスタンス内のすべての文字が小文字に変換される新しい文字列が返されます。  
  
## <a name="security-considerations"></a>セキュリティの考慮事項  
 ファイル名、名前付きパイプ、レジストリキーなど、オペレーティングシステム識別子の小文字または大文字のバージョンが必要な場合は、メソッド<xref:System.String.ToLowerInvariant%2A>また<xref:System.String.ToUpperInvariant%2A>はメソッドを使用します。  
  
   
  
## Examples  
 次の例では、複数の言語に含まれる1つの単語を含む文字列配列を定義します。 メソッド<xref:System.String.ToLowerInvariant%2A>は、各単語の大文字と小文字を区別せずに並列配列の要素を設定するために使用されます。 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType>メソッドを使用して、小文字配列内の要素の順序に基づいて大文字と小文字を区別する配列を並べ替え、要素が言語に関係なく同じ順序で表示されるようにします。  
  
 [!code-csharp[System.String.ToLowerInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tolowerinvariant/cs/tolowerinvariant.cs#1)]
 [!code-vb[System.String.ToLowerInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tolowerinvariant/vb/tolowerinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToUpperInvariant" />
        <altmember cref="M:System.String.ToLower(System.Globalization.CultureInfo)" />
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このインスタンスの値を <see cref="T:System.String" /> に変換します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="string.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.String" /> のこのインスタンスを返します。実際の変換処理は実行されません。</summary>
        <returns>現在の文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、現在の文字列をそのまま返すだけなので、直接呼び出す必要はありません。 この例に示すように、通常、複合書式指定操作で暗黙的に呼び出されます。  
  
   
  
## Examples  
 メソッドの<xref:System.String.ToString%2A>例を次に示します。この例では、メソッドは<xref:System.String.ToString%2A>明示的に呼び出されないことに注意してください。 代わりに、メソッドは[複合書式指定](~/docs/standard/base-types/composite-formatting.md)機能によって暗黙的に呼び出されます。  
  
 [!code-cpp[string.tostring#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tostring/CPP/string.tostring.cpp#1)]
 [!code-csharp[string.tostring#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tostring/CS/string.tostring.cs#1)]
 [!code-vb[string.tostring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tostring/VB/string.tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Clone" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="string.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">(予約済み) カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary><see cref="T:System.String" /> のこのインスタンスを返します。実際の変換処理は実行されません。</summary>
        <returns>現在の文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `provider`は予約されており、現在この操作に参加していません。  
  
 このメソッドは、現在の文字列をそのまま返すだけなので、直接呼び出す必要はありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToUpper">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>この文字列のコピーを大文字に変換して返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper();" />
      <MemberSignature Language="F#" Value="member this.ToUpper : unit -&gt; string" Usage="string.ToUpper " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この文字列のコピーを大文字に変換して返します。</summary>
        <returns>現在の文字列を大文字にしたもの。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、現在のカルチャの大文字と小文字の規則を使用して、現在のインスタンスの各文字を、それと等価な大文字に変換します。 文字に大文字と小文字が含まれていない場合は、返された文字列にそのまま含まれます。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更しません。 代わりに、現在のインスタンス内のすべての文字が大文字に変換される新しい文字列が返されます。  
  
 <xref:System.String.ToUpper%2A>メソッドは、大文字と小文字を区別しない比較で使用できるように、文字列を大文字に変換するためによく使用されます。 大文字と小文字を区別しない比較を実行するには、カルチャに依存<xref:System.StringComparison>し、大文字と小<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>文字を区別しない比較のためにに設定した値を持つパラメーターを持つ文字列比較メソッドを呼び出すことをお勧めします。  
  
## <a name="security-considerations"></a>セキュリティの考慮事項  
 メソッドを<xref:System.String.ToUpper>呼び出した結果として得られる大文字と小文字の演算では、現在のカルチャの大文字と小文字の表記規則が考慮されます。 ファイル名、名前付きパイプ、レジストリキーなど、オペレーティングシステム識別子の小文字または大文字のバージョンが必要な場合は、メソッド<xref:System.String.ToLowerInvariant%2A>また<xref:System.String.ToUpperInvariant%2A>はメソッドを使用します。 これにより、( <xref:System.String.ToUpper>メソッドとは異なり) すべてのカルチャで同じ結果が生成され、より効率的に実行されます。  
  
   
  
## Examples  
 次の例では<xref:System.String.ToUpper%2A> 、メソッドを呼び出して、基本的な latin、ラテン1の追加、およびラテン拡張文字セットの各文字を含む一連の1文字の文字列を変換します。 次に、大文字が小文字と異なる文字列をそれぞれ表示します。  
  
 [!code-cpp[System.String.ToUpper#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.ToUpper/cpp/ToUpperEx.cpp#1)]
 [!code-csharp[System.String.ToUpper#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.ToUpper/cs/ToUpperEx.cs#1)]
 [!code-vb[System.String.ToUpper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.ToUpper/vb/ToUpperEx.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>「[文字列を使用するためのベストプラクティス](~/docs/standard/base-types/best-practices-strings.md)」で説明されているように、既定値を置き換える文字列の大文字と小文字の使い分けメソッドを呼び出さずに、パラメーターを明示的に指定する必要があるメソッドを呼び出すことをお勧めします。 現在のカルチャの大文字と小文字の表記規則を使用して文字列を<see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" />大文字に変換するには<see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> 、 <paramref name="culture" />パラメーターの値がであるメソッドオーバーロードを呼び出します。</para></block>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToUpper : System.Globalization.CultureInfo -&gt; string" Usage="string.ToUpper culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="culture">カルチャ固有の大文字と小文字の規則を提供するオブジェクト。</param>
        <summary>指定されたカルチャの大文字と小文字の規則を使用して、この文字列のコピーを大文字に変換して返します。</summary>
        <returns>現在の文字列を大文字にしたもの。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `culture`パラメーターで指定されたカルチャの大文字と小文字の規則によって、文字列の大文字と小文字の変更方法が決まります。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更しません。 代わりに、現在のインスタンス内のすべての文字が大文字に変換される新しい文字列が返されます。  
  
## <a name="security-considerations"></a>セキュリティの考慮事項  
 メソッドに<xref:System.String.ToUpper%28System.Globalization.CultureInfo%29>以外<xref:System.Globalization.CultureInfo>のオブジェクトを渡すと、大文字と小文字の操作によってカルチャ固有の規則が考慮されます。 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> ファイル名、名前付きパイプ、レジストリキーなど、オペレーティングシステム識別子の小文字または大文字のバージョンが必要な場合は、メソッド<xref:System.String.ToLowerInvariant%2A>また<xref:System.String.ToUpperInvariant%2A>はメソッドを使用します。 これにより、すべてのカルチャで同じ結果が生成され、より効率的に実行されます。  
  
   
  
## Examples  
 次の例では、米国英語とトルコ語のカルチャを使用して小文字の文字列を大文字の2つの文字列に変換し、その後、大文字の文字列を比較します。 大文字の文字列は同じですが、1つの文字列に Unicode ラテン大文字 I が出現するたびに、もう一方の文字列には上記のドット付きのラテン大文字 I が含まれている点が異なります。  
  
 [!code-csharp[string.toupper1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.toupper1/CS/toupper.cs#1)]
 [!code-vb[string.toupper1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.toupper1/VB/toupper.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> は <see langword="null" />です。</exception>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public string ToUpperInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpperInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpperInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpperInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpperInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToUpperInvariant : unit -&gt; string" Usage="string.ToUpperInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>インバリアント カルチャの大文字と小文字の規則を使用して、この <see cref="T:System.String" /> オブジェクトのコピーを大文字に変換して返します。</summary>
        <returns>現在の文字列を大文字にしたもの。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インバリアントカルチャは、カルチャを認識しないカルチャを表します。 英語と関連付けられていますが、特定の国または地域には関連付けられていません。 詳細については、<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> プロパティを参照してください。  
  
 現在のカルチャの影響を受けない予測可能な方法で文字列が変更された場合にアプリケーションが依存し<xref:System.String.ToUpperInvariant%2A>ている場合は、メソッドを使用します。 メソッド<xref:System.String.ToUpperInvariant%2A>は、 `ToUpper(CultureInfo.InvariantCulture)`と同じです。 文字列のコレクションをユーザーインターフェイスコントロールで予測可能な順序で表示する必要がある場合は、メソッドをお勧めします。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更しません。 代わりに、現在のインスタンス内のすべての文字が大文字に変換される新しい文字列が返されます。  
  
## <a name="security-considerations"></a>セキュリティの考慮事項  
 ファイル名、名前付きパイプ、レジストリキーなど、オペレーティングシステム識別子の小文字または大文字のバージョンが必要な場合は、メソッド<xref:System.String.ToLowerInvariant%2A>また<xref:System.String.ToUpperInvariant%2A>はメソッドを使用します。  
  
   
  
## Examples  
 次の例では、複数の言語に含まれる1つの単語を含む文字列配列を定義します。 メソッド<xref:System.String.ToUpperInvariant%2A>は、各単語の大文字と小文字を区別せずに並列配列の要素を設定するために使用されます。 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType>メソッドを使用して、大文字と小文字を区別する配列を大文字配列の要素の順序に基づいて並べ替え、要素が言語に関係なく同じ順序で表示されるようにします。  
  
 [!code-csharp[System.String.ToUpperInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.toupperinvariant/cs/toupperinvariant.cs#1)]
 [!code-vb[System.String.ToUpperInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.toupperinvariant/vb/toupperinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Trim">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.String" /> オブジェクトの先頭および末尾から、指定した文字セットをすべて削除した新しい文字列を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim();" />
      <MemberSignature Language="F#" Value="member this.Trim : unit -&gt; string" Usage="string.Trim " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.String" /> オブジェクトの先頭および末尾にある空白文字をすべて削除します。</summary>
        <returns>現在の文字列の先頭および末尾から空白文字をすべて削除した後に残った文字列。 現在のインスタンスから文字をトリミングできない場合、メソッドは現在のインスタンスを変更せずに返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.String.Trim%2A>は、現在の文字列からすべての先頭および末尾の空白文字を削除します。 それぞれの先頭および末尾のトリム操作は、空白以外の文字が検出されると停止します。 たとえば、現在の文字列が "abc" の場合、このメソッド<xref:System.String.Trim%2A>は "abc xyz" を返します。 文字列内の単語間の空白文字を削除するには、 [.net の正規表現](~/docs/standard/base-types/regular-expressions.md)を使用します。  
  
> [!NOTE]
>  メソッドが<xref:System.String.Trim%2A>現在のインスタンスから任意の文字を削除した場合、このメソッドは現在のインスタンスの値を変更しません。 代わりに、現在のインスタンスで見つかった先頭および末尾の空白文字がすべて削除された新しい文字列を返します。  
  
 現在の文字列がと<xref:System.String.Empty>等しい場合、または現在のインスタンス内のすべての文字が空白文字で構成<xref:System.String.Empty>されている場合、メソッドはを返します。  
  
 空白文字は、Unicode 規格で定義されています。 メソッド<xref:System.String.Trim>は、 <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>メソッドに渡されるときにの戻り値を生成`true`する先頭および末尾の文字を削除します。  
  
   
  
## Examples  
 次の例では<xref:System.String.Trim?displayProperty=nameWithType> 、メソッドを使用して、連結前にユーザーが入力した文字列から余分な空白を削除します。  
  
 [!code-cpp[System.String.Trim#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim2.cpp#2)]
 [!code-csharp[System.String.Trim#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim2.cs#2)]
 [!code-vb[System.String.Trim#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>以前[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]のバージョンでは、このメソッドがトリムする空白文字の内部リストを維持しています。 以降では、メソッドは、すべての Unicode の空白文字 (つまり、 <see cref="M:System.Char.IsWhiteSpace(System.Char)" />メソッドに渡されるとき<see langword="true" />に戻り値を生成する文字) をトリムします。 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] この変更<see cref="M:System.String.Trim" />により、 [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]およびそれより前のバージョンのメソッドでは、2つの文字、0の幅空間 (u + 200B)、およびゼロ幅の改行なしスペース ( <see cref="M:System.String.Trim" /> u + FEFF [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]) が削除されます。以降のバージョンのメソッドでは、削除しないでください。 また<see cref="M:System.String.Trim" /> 、以前のバージョンのメソッド[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]では、3つの Unicode の空白文字は削除されません。モンゴル語の母音区切り記号 (U + 180 e)、ナロースペースなし (U + 202F)、および中程度の数学空間 (U + 205F)。</para></block>
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.Trim : char -&gt; string" Usage="string.Trim trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.Trim : char[] -&gt; string" Usage="string.Trim trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">削除する Unicode 文字の配列、または <see langword="null" />。</param>
        <summary>現在の <see cref="T:System.String" /> オブジェクトの先頭および末尾から、配列で指定された文字セットをすべて削除します。</summary>
        <returns>現在の文字列の先頭および末尾から、<paramref name="trimChars" /> パラメーターの文字をすべて削除した後に残った文字列。 <paramref name="trimChars" /> が <see langword="null" /> または空の配列の場合は、代わりに空白文字が削除されます。 現在のインスタンスから文字をトリミングできない場合、メソッドは現在のインスタンスを変更せずに返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.String.Trim%2A>は、 `trimChars`パラメーターに含まれる先頭と末尾のすべての文字を現在の文字列から削除します。 に含まれていない文字が検出されると、それぞれ`trimChars`の先頭および末尾のトリム操作が停止します。 たとえば、現在の文字列が "123abc456xyz789" `trimChars`で、"1" ~ "9" の数字が含まれている場合、メソッドは<xref:System.String.Trim%2A> "abc456xyz" を返します。  
  
> [!NOTE]
>  メソッドが<xref:System.String.Trim%2A>現在のインスタンスから任意の文字を削除した場合、このメソッドは現在のインスタンスの値を変更しません。 代わりに、現在のインスタンスに含まれる先頭および末尾`trimChars`のすべての文字が削除された新しい文字列を返します。  
  
 現在の文字列がと<xref:System.String.Empty>等しい場合、または現在のインスタンス内のすべての文字`trimChars`が配列内の文字<xref:System.String.Empty>で構成されている場合、メソッドはを返します。  
  
 が`trimChars` `true` <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>または空の配列の場合、このメソッドは、メソッドに渡されたときにメソッドによって返される先頭または末尾の文字を削除します。 `null`  
  
   
  
## Examples  
 次の例では<xref:System.String.Trim%28System.Char%5B%5D%29?displayProperty=nameWithType> 、メソッドを使用して、文字列からスペース、アスタリスク (*)、およびアポストロフィ (') 文字を削除します。  
  
 [!code-cpp[System.String.Trim#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim1.cpp#1)]
 [!code-csharp[System.String.Trim#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim1.cs#1)]
 [!code-vb[System.String.Trim#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>以前[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]のバージョンでは、が<see langword="null" />または空の配列の場合<paramref name="trimChars" />に、このメソッドがトリムする空白文字の内部リストを保持します。 <see langword="null" /> <paramref name="trimChars" /> <see cref="M:System.Char.IsWhiteSpace(System.Char)" />以降では、がまたは空の配列の場合、メソッドはすべての Unicode 空白文字 (つまり、メソッドに渡されるとき<see langword="true" />に戻り値を生成する文字) をトリムします。 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] この変更<see cref="M:System.String.Trim" />により、 [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]およびそれより前のバージョンのメソッドでは、2つの文字、0の幅空間 (u + 200B)、およびゼロ幅の改行なしスペース ( <see cref="M:System.String.Trim" /> u + FEFF [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]) が削除されます。以降のバージョンのメソッドでは、削除しないでください。 また<see cref="M:System.String.Trim" /> 、以前のバージョンのメソッド[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]では、3つの Unicode の空白文字は削除されません。モンゴル語の母音区切り記号 (U + 180 e)、ナロースペースなし (U + 202F)、および中程度の数学空間 (U + 205F)。</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd();" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : unit -&gt; string" Usage="string.TrimEnd " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char -&gt; string" Usage="string.TrimEnd trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char[] -&gt; string" Usage="string.TrimEnd trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">削除する Unicode 文字の配列、または <see langword="null" />。</param>
        <summary>現在の <see cref="T:System.String" /> オブジェクトの末尾から、配列で指定された文字セットをすべて削除します。</summary>
        <returns>現在の文字列の末尾から、<paramref name="trimChars" /> パラメーターの文字をすべて削除した後に残った文字列。 <paramref name="trimChars" /> が <see langword="null" /> または空の配列の場合は、代わりに Unicode の空白文字が削除されます。 現在のインスタンスから文字をトリミングできない場合、メソッドは現在のインスタンスを変更せずに返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.String.TrimEnd%2A>は、現在の文字列から、 `trimChars`パラメーター内の末尾にあるすべての文字を削除します。 トリム操作は、に含ま`trimChars`れていない最初の文字が文字列の末尾で見つかったときに停止します。 たとえば、現在の文字列が "123abc456xyz789" `trimChars`で、"1" ~ "9" の数字が含まれている場合、メソッドは<xref:System.String.TrimEnd%2A> "123abc456xyz" を返します。  
  
> [!NOTE]
>  メソッドが<xref:System.String.TrimEnd%2A>現在のインスタンスから任意の文字を削除した場合、このメソッドは現在のインスタンスの値を変更しません。 代わりに、で`trimChars`見つかったすべての末尾の文字が現在の文字列から削除された新しい文字列を返します。  
  
   
  
## Examples  
 次の例は、 <xref:System.String.TrimEnd%28System.Char%5B%5D%29>メソッドを使用して、文字列の末尾から空白または句読点を除去する方法を示しています。  
  
 [!code-csharp[System.String.TrimEnd#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimEnd/cs/sample2.cs#2)]
 [!code-vb[System.String.TrimEnd#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimEnd/vb/Sample2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>以前[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]のバージョンでは、が<see langword="null" />または空の配列の場合<paramref name="trimChars" />に、このメソッドがトリムする空白文字の内部リストを保持します。 <see langword="null" /> <paramref name="trimChars" /> <see cref="M:System.Char.IsWhiteSpace(System.Char)" />以降では、がまたは空の配列の場合、メソッドはすべての Unicode 空白文字 (つまり、メソッドに渡されるとき<see langword="true" />に戻り値を生成する文字) をトリムします。 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] この変更<see cref="M:System.String.Trim" />により、 [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]およびそれより前のバージョンのメソッドでは、2つの文字、0の幅空間 (u + 200B)、およびゼロ幅の改行なしスペース ( <see cref="M:System.String.Trim" /> u + FEFF [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] ) が削除されます。以降のバージョンのメソッドでは、削除しないでください。 また<see cref="M:System.String.Trim" /> 、以前のバージョンのメソッド[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]では、3つの Unicode の空白文字は削除されません。モンゴル語の母音区切り記号 (U + 180 e)、ナロースペースなし (U + 202F)、および中程度の数学空間 (U + 205F)。</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart();" />
      <MemberSignature Language="F#" Value="member this.TrimStart : unit -&gt; string" Usage="string.TrimStart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char -&gt; string" Usage="string.TrimStart trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char[] -&gt; string" Usage="string.TrimStart trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">削除する Unicode 文字の配列、または <see langword="null" />。</param>
        <summary>現在の <see cref="T:System.String" /> オブジェクトの先頭から、配列で指定された文字セットをすべて削除します。</summary>
        <returns>現在の文字列の先頭から、<paramref name="trimChars" /> パラメーターの文字をすべて削除した後に残った文字列。 <paramref name="trimChars" /> が <see langword="null" /> または空の配列の場合は、代わりに空白文字が削除されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.String.TrimStart%2A>は、 `trimChars`パラメーターに含まれるすべての先頭文字を現在の文字列から削除します。 トリム操作は、に含ま`trimChars`れていない文字が見つかったときに停止します。 たとえば、現在の文字列が "123abc456xyz789" `trimChars`で、"1" ~ "9" の数字が含まれている場合、メソッドは<xref:System.String.TrimStart%2A> "abc456xyz789" を返します。  
  
> [!NOTE]
>  メソッドが<xref:System.String.TrimStart%2A>現在のインスタンスから任意の文字を削除した場合、このメソッドは現在のインスタンスの値を変更しません。 代わりに、現在のインスタンスで見つかったすべての先頭の空白文字が削除される新しい文字列を返します。  
  
   
  
## Examples  
 次の例は、 <xref:System.String.TrimStart%2A>メソッドの基本的な機能を示しています。

 [!code-csharp[System.String.TrimStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#1)]
 [!code-vb[System.String.TrimStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#1)]

 次の例では<xref:System.String.TrimStart%2A> 、メソッドを使用して、ソースコードの行から空白とコメント文字を除去します。 メソッド`StripComments`は、の<xref:System.String.TrimStart%2A>呼び出しをラップし、空白とコメント文字を含む文字配列を渡します。これは、Visual Basic のアポストロフィ (') と、のC#スラッシュ (/) です。 文字列<xref:System.String.TrimStart%2A>がコメントであるかどうかを評価するときに、先頭の空白を削除するメソッドも呼び出されます。  
  
 [!code-csharp[System.String.TrimStart#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#2)]
 [!code-vb[System.String.TrimStart#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#2)]  
  
 `StripComments` メソッドを呼び出す例を次に示します。  
  
 [!code-csharp[System.String.TrimStart#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#3)]
 [!code-vb[System.String.TrimStart#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>以前[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]のバージョンでは、が<see langword="null" />または空の配列の場合<paramref name="trimChars" />に、このメソッドがトリムする空白文字の内部リストを保持します。 <see langword="null" /> <paramref name="trimChars" /> <see cref="M:System.Char.IsWhiteSpace(System.Char)" />以降では、がまたは空の配列の場合、メソッドはすべての Unicode 空白文字 (つまり、メソッドに渡されるとき<see langword="true" />に戻り値を生成する文字) をトリムします。 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] この変更<see cref="M:System.String.Trim" />により、 [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]およびそれより前のバージョンのメソッドでは、2つの文字、0の幅空間 (u + 200B)、およびゼロ幅の改行なしスペース ( <see cref="M:System.String.Trim" /> u + FEFF [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] ) が削除されます。以降のバージョンのメソッドでは、削除しないでください。 また<see cref="M:System.String.Trim" /> 、以前のバージョンのメソッド[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]では、3つの Unicode の空白文字は削除されません。モンゴル語の母音区切り記号 (U + 180 e)、ナロースペースなし (U + 202F)、および中程度の数学空間 (U + 205F)。</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
  </Members>
</Type>