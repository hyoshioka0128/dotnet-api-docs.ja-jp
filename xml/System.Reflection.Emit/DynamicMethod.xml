<Type Name="DynamicMethod" FullName="System.Reflection.Emit.DynamicMethod">
  <Metadata><Meta Name="ms.openlocfilehash" Value="71e905a95bc7051f218f8ee2fb82ff422b40b7d3" /><Meta Name="ms.sourcegitcommit" Value="74239f3977d28923e5020663db2c4e91601bea79" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="07/24/2019" /><Meta Name="ms.locfileid" Value="68437197" /></Metadata><TypeSignature Language="C#" Value="public sealed class DynamicMethod : System.Reflection.MethodInfo" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit DynamicMethod extends System.Reflection.MethodInfo" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.DynamicMethod" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DynamicMethod&#xA;Inherits MethodInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class DynamicMethod sealed : System::Reflection::MethodInfo" />
  <TypeSignature Language="F#" Value="type DynamicMethod = class&#xA;    inherit MethodInfo" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MethodInfo</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>コンパイル、実行、および破棄できる動的メソッドを定義し、表します。 破棄されたメソッドは、ガベージ コレクションの対象となります。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.DynamicMethod>クラスを使用して、メソッドを格納する動的アセンブリおよび動的な型を生成せずに、実行時にメソッドを生成して実行できます。 ジャストインタイム (JIT) コンパイラによって作成された実行可能コードは、 <xref:System.Reflection.Emit.DynamicMethod>オブジェクトが再利用されるときに解放されます。 動的メソッドは、少量のコードを生成して実行するための最も効率的な方法です。  
  
 動的メソッドは匿名でホストすることも、モジュールまたは型に論理的に関連付けることもできます。  
  
-   動的メソッドが匿名でホストされている場合は、システム指定のアセンブリに配置されるため、他のコードから分離されます。 既定では、パブリックでないデータにはアクセスできません。 匿名でホストさ<xref:System.Security.Permissions.ReflectionPermission>れる動的メソッドは、 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>フラグで JIT コンパイラの参照範囲チェックを省略できるようにすることができます。 パブリックでないメンバーが動的メソッドによってアクセスされるアセンブリの信頼レベルは、動的メソッドを出力した呼び出し履歴の信頼レベルと同じであるか、そのサブセットである必要があります。 匿名でホストされる動的メソッドの詳細に[ついては、「チュートリアル:部分信頼シナリオ](~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md)でのコードの出力。  
  
-   指定したモジュールに動的メソッドが関連付けられている場合、動的メソッドはそのモジュールに対して実質的にグローバルになります。 モジュール内のすべての型、および型の`internal`すべて`Friend`の (Visual Basic) メンバーにアクセスできます。 モジュールを作成したかどうかに関係なく、動的メソッドを任意のモジュールに関連付けることが<xref:System.Security.Permissions.ReflectionPermission>できます<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> 。これは、コードを含む呼び出し履歴がフラグに対する要求を満たすことができるようにするためです。 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>フラグが grant に含まれている場合、動的メソッドは、JIT コンパイラの参照範囲チェックをスキップし、モジュールまたは任意のアセンブリ内の他のモジュールで宣言されているすべての型のプライベートデータにアクセスできます。  
  
    > [!NOTE]
    >  動的メソッドが関連付けられているモジュールを指定する場合、そのモジュールは、匿名ホストに使用されるシステム指定のアセンブリに含まれていない必要があります。  
  
-   指定した型に動的メソッドが関連付けられている場合、アクセスレベルに関係なく、型のすべてのメンバーにアクセスできます。 また、JIT 参照範囲チェックをスキップすることもできます。 これにより、動的メソッドは、同じモジュールまたは任意のアセンブリ内の他のモジュールで宣言されている他の型のプライベートデータにアクセスできます。 動的メソッドは任意の型に関連付けることができますが、と<xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess>の<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>両方のフラグを使用してコードを許可する必要があります。  
  
 次の表は、匿名でホストされる動的メソッドにアクセスできる型およびメンバーを示しています。これは、 <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>フラグが付与されているかどうかによって異なりますが、JIT 参照範囲チェックの有無は関係ありません。  
  
||<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> を使用しない場合|<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> を使用する場合|  
|-|-|-|  
|JIT 参照範囲チェックをスキップせず|任意のアセンブリのパブリック型のパブリックメンバー。|任意のアセンブリのパブリック型のパブリックメンバー。|  
|制限付きで JIT 参照範囲チェックをスキップする|任意のアセンブリのパブリック型のパブリックメンバー。|すべての型のすべてのメンバー。信頼レベルが動的メソッドを出力したアセンブリの信頼レベル以下であるアセンブリ内のすべてのメンバー。|  
  
> [!NOTE]
>  より前<xref:System.Security.Permissions.ReflectionPermission>では、 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>フラグを使用して必要なコードを出力していました。 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] このアクセス許可は、既定では、FullTrust および LocalIntranet という名前のアクセス許可セットに含まれていますが、インターネットアクセス許可セットには含まれていません。 このため、以前のバージョンの[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]では、ライブラリに<xref:System.Security.SecurityCriticalAttribute> <xref:System.Security.PermissionSet.Assert%2A>属性があり、の<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>を実行する場合にのみ、インターネットアクセス許可でライブラリを使用できます。 このようなライブラリでは、コーディング エラーがあるとセキュリティ ホールが発生するおそれがあるため、セキュリティを慎重にレビューする必要があります。 コードの生成は本質的に特権を必要とする操作ではないため、[!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)] はセキュリティ確認要求を発行せずに部分信頼シナリオでコードを出力できます。 これは、生成されたコードには、コードを出力したアセンブリと同等以下のアクセス許可しかないことを意味します。 これにより、コードを出力するライブラリは透過的セキュリティになるため、<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit> を要求する必要がなくなります。そのため、安全なライブラリを簡単に作成できるようになります。 この機能を使用するに[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]は、アプリケーションで以降を対象とする必要があります。  
  
 次の表は、モジュールに関連付けられている動的メソッドにアクセスできる型およびメンバー、またはモジュール内の型を示しています。  
  
||モジュールに関連付けられています|関連付けられている型|  
|-|-|-|  
|JIT 参照範囲チェックをスキップせず|モジュール内のパブリック型、内部型、およびプライベート型のパブリックメンバーと内部メンバー。<br /><br /> 任意のアセンブリのパブリック型のパブリックメンバー。|関連付けられた型のすべてのメンバー。 モジュール内の他のすべての型のパブリックメンバーと内部メンバー。<br /><br /> 任意のアセンブリのパブリック型のパブリックメンバー。|  
|JIT 参照範囲チェックのスキップ|任意のアセンブリのすべての型のすべてのメンバー。|任意のアセンブリのすべての型のすべてのメンバー。|  
  
 モジュールに関連付けられている動的メソッドには、そのモジュールのアクセス許可があります。 型に関連付けられている動的メソッドには、その型を含むモジュールのアクセス許可があります。  
  
 動的メソッドとそのパラメーターに名前を付ける必要はありませんが、デバッグに役立つ名前を指定できます。 カスタム属性は、動的メソッドまたはそのパラメーターではサポートされていません。  
  
 動的メソッドはメソッド`static` (`Shared` Visual Basic 内のメソッド) ですが、で導入された[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]デリゲートバインディングの緩やかな規則では、動的メソッドをオブジェクトにバインドできます。これにより、次の場合にインスタンスメソッドのように動作するようになります。そのデリゲートインスタンスを使用して呼び出されます。 これを示す例として、 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29>メソッドのオーバーロードがあります。  
  
> [!NOTE]
>  [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]では、動的メソッドは、シンボル情報、つまりローカル変数名と行番号マッピングをサポートしていません。 この制限は、将来のバージョンでは削除される可能性があります。 開発時に<xref:System.Reflection.Emit.AssemblyBuilder>を使用して、生成された Microsoft 中間言語 (MSIL) のデバッグを簡略化した後、最終的な配置<xref:System.Reflection.Emit.ILGenerator>中に動的メソッドに切り替えることができます。これは、呼び出しが両方の場合に同じであるためです。  
  
## <a name="verification"></a>検証  
 次の一覧は、動的メソッドに検証不可能なコードを含めることができる条件をまとめたものです。 (たとえば、 <xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A>プロパティがに`false`設定されている場合、動的メソッドは検証できません)。  
  
-   セキュリティクリティカルなアセンブリに関連付けられている動的メソッドは、セキュリティクリティカルでもあるため、検証をスキップできます。 たとえば、デスクトップアプリケーションとして実行されるセキュリティ属性を持たないアセンブリは、ランタイムによってセキュリティクリティカルとして扱われます。 動的メソッドをアセンブリに関連付ける場合、動的メソッドには検証不可能なコードを含めることができます。  
  
-   検証不可能なコードを含む動的メソッドが、レベル1の透過性を持つアセンブリに関連付けられている場合、ジャストインタイム (JIT) コンパイラによってセキュリティ要求が挿入されます。 動的メソッドが完全に信頼されたコードによって実行される場合にのみ、要求は成功します。 「[透過的セキュリティコード、レベル1」を](~/docs/framework/misc/security-transparent-code-level-1.md)参照してください。  
  
-   検証不可能なコードを含む動的メソッドが、レベル2の透過性 (mscorlib.dll など) を持つアセンブリに関連付けられている場合、セキュリティ要求を行うのではなく、(JIT コンパイラによって挿入された) 例外をスローします。 「[透過的セキュリティコード、レベル2」を](~/docs/framework/misc/security-transparent-code-level-2.md)参照してください。  
  
-   検証不可能なコードを含む匿名でホストされる動的メソッドは、常に例外をスローします。 完全に信頼されたコードによって作成および実行された場合でも、検証をスキップすることはできません。  
  
 検証不可能なコードに対してスローされる例外は、動的メソッドの呼び出し方法によって異なります。 メソッドから返されたデリゲートを使用して動的メソッドを呼び出すと、がスローされます。<xref:System.Security.VerificationException> <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> メソッドを使用<xref:System.Security.VerificationException>して動的メソッドを呼び出すと、が内部でスローされます。<xref:System.Reflection.TargetInvocationException> <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>  
  
   
  
## Examples  
 次のコード例では、2つのパラメーターを受け取る動的メソッドを作成します。 この例では、最初のパラメーターをコンソールに出力する単純な関数本体を出力します。この例では、メソッドの戻り値として2番目のパラメーターを使用します。 この例では、デリゲートを作成してメソッドを完了し、異なるパラメーターを使用してデリゲートを呼び出し、 <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>最後にメソッドを使用して動的メソッドを呼び出します。  
  
 [!code-cpp[Reflection.DynamicMethod.All#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.All#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.All#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">方法: 動的メソッドを定義および実行する</related>
    <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">リフレクション出力のセキュリティ関連事項</related>
    <related type="Article" href="~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md">チュートリアル: 部分信頼シナリオにおけるコード出力</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>動的メソッドを作成します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">動的メソッドの名前。 これは、長さ 0 の文字列にできますが、 <see langword="null" />にすることはできません。</param>
        <param name="returnType">動的メソッドの戻り値の型を指定する <see cref="T:System.Type" /> オブジェクト。メソッドに戻り値の型がない場合は <see langword="null" />。</param>
        <param name="parameterTypes">動的メソッドのパラメーターの型を指定する <see cref="T:System.Type" /> オブジェクトの配列。メソッドにパラメーターがない場合は <see langword="null" />。</param>
        <summary>メソッド名、戻り値の型、およびパラメーターの型を指定して、匿名でホストされる動的メソッドを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンストラクターによって作成される動的メソッドは、既存の型またはモジュールではなく、匿名アセンブリに関連付けられます。 匿名アセンブリは、動的メソッドのサンドボックス環境を提供するためだけに存在します。つまり、他のコードから分離します。 この環境では、部分信頼コードによって動的メソッドの生成と実行を安全に行うことができます。  
  
 このコンストラクターは、動的メソッドの MSIL (Microsoft 中間言語) に対して just-in-time (JIT) 参照範囲チェックが適用されることを指定します。 つまり、動的メソッドのコードは、パブリッククラスのパブリックメソッドにアクセスできます。 メソッドが`private`、 `protected`、または (`Friend` Visual Basic) である型または`internal`メンバーにアクセスしようとすると、例外がスローされます。 JIT 参照範囲チェックをスキップする機能が制限されている動的メソッドを<xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%2CSystem.Boolean%29>作成するには、コンストラクターを使用します。  
  
 匿名でホストされる動的メソッドを構築する場合は、出力アセンブリの呼び出し履歴が含まれます。 メソッドが呼び出されると、実際の呼び出し元のアクセス許可ではなく、出力アセンブリのアクセス許可が使用されます。 したがって、動的メソッドは、より高い信頼レベルを持つアセンブリに渡されて実行される場合でも、それを生成したアセンブリより高いレベルの特権では実行できません。  
  
 このコンストラクターは、メソッド属性<xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>、、および呼び出し規約<xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>を指定します。  
  
> [!NOTE]
>  このコンストラクターは、 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]以降で導入されました。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="parameterTypes" /> の要素が <see langword="null" /> または <see cref="T:System.Void" /> です。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> は、<see cref="P:System.Type.IsByRef" /> が <see langword="true" /> を返す型です。</exception>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">方法: 動的メソッドを定義および実行する</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">リフレクション出力のセキュリティ関連事項</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md">チュートリアル: 部分信頼シナリオにおけるコード出力</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, bool restrictedSkipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, bool restrictedSkipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), restrictedSkipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, bool restrictedSkipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, restrictedSkipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="restrictedSkipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">動的メソッドの名前。 これは、長さ 0 の文字列にできますが、 <see langword="null" />にすることはできません。</param>
        <param name="returnType">動的メソッドの戻り値の型を指定する <see cref="T:System.Type" /> オブジェクト。メソッドに戻り値の型がない場合は <see langword="null" />。</param>
        <param name="parameterTypes">動的メソッドのパラメーターの型を指定する <see cref="T:System.Type" /> オブジェクトの配列。メソッドにパラメーターがない場合は <see langword="null" />。</param>
        <param name="restrictedSkipVisibility">動的メソッドの MSIL によりアクセスされる型およびメンバーに対する JIT 参照範囲チェックをスキップする場合は <see langword="true" /> (ただし、それらの型およびメンバーが含まれるアセンブリの信頼レベルは、動的メソッドを出力する呼び出しスタックの信頼レベル以下でなければならないという制限あり)。それ以外の場合は <see langword="false" />。</param>
        <summary>メソッド名、戻り値の型、パラメーターの型を指定し、さらに Just-In-Time (JIT) 参照範囲チェックが動的メソッドの Microsoft Intermediate Language (MSIL) によりアクセスされる型やメンバーをスキップするかどうかを指定して、匿名ホスト対象の動的メソッドを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンストラクターによって作成される動的メソッドは、既存の型またはモジュールではなく、匿名アセンブリに関連付けられます。 匿名アセンブリは、動的メソッドのサンドボックス環境を提供するためだけに存在します。つまり、他のコードから分離します。 この環境では、部分信頼コードによって動的メソッドの生成と実行を安全に行うことができます。  
  
 匿名`private`でホストされる動的メソッドには、、 `protected`、または (`Friend` Visual Basic) である`internal`型またはメンバーへの自動アクセスはありません。 これは、既存の型またはモジュールに関連付けられている動的メソッドとは異なります。これは、関連付けられているスコープ内の隠しメンバーにアクセスできます。  
  
 動的`true`メソッド`restrictedSkipVisibility` `private`が、 、また`internal`はの型またはメンバーにアクセスする必要がある場合は、にを指定します。 `protected` これにより、動的メソッドでは、これらのメンバーへのアクセスが制限されます。 つまり、次の条件が満たされている場合にのみ、メンバーにアクセスできます。  
  
-   ターゲットメンバーは、動的メソッドを出力する呼び出し履歴と同じかそれより下位の信頼レベルを持つアセンブリに属しています。  
  
-   動的メソッドを出力するコールスタックは、 <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>フラグを使用して付与されます。 完全信頼でコードを実行する場合は、常に true になります。 部分的に信頼されているコードの場合は、ホストが明示的にアクセス許可を付与している場合にのみ true になります。  
  
    > [!IMPORTANT]
    >  アクセス許可が付与されていない場合、 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>が呼び出されたとき、または動的メソッドが呼び出されたときにセキュリティ例外がスローされます。このコンストラクターが呼び出されたときにはスローされません。 動的メソッドを出力するために特別なアクセス許可は必要ありません。  
  
 たとえば、をに`restrictedSkipVisibility` `true`設定して作成された動的メソッドは、呼び出し履歴に制限されたメンバーアクセスが許可されている場合、呼び出し履歴上の任意のアセンブリのプライベートメンバーにアクセスできます。 動的メソッドが呼び出し履歴に部分的に信頼されたコードで作成される場合、 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]アセンブリ内の型のプライベートメンバーにアクセスすることはできません。このようなアセンブリは完全に信頼されているためです。  
  
 が`restrictedSkipVisibility` の`false`場合は、JIT 参照範囲チェックが適用されます。 動的メソッドのコードはパブリッククラスのパブリックメソッドにアクセスでき、例外は`private`、 `protected`、、また`internal`はの型またはメンバーにアクセスしようとした場合にスローされます。  
  
 匿名でホストされる動的メソッドを構築する場合は、出力アセンブリの呼び出し履歴が含まれます。 メソッドが呼び出されると、実際の呼び出し元のアクセス許可ではなく、出力コールスタックのアクセス許可が使用されます。 したがって、動的メソッドは、より高い信頼レベルを持つアセンブリに渡されて実行される場合でも、それを生成したアセンブリより高いレベルの特権では実行できません。  
  
 このコンストラクターは、メソッド属性<xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>、、および呼び出し規約<xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>を指定します。  
  
> [!NOTE]
>  このコンストラクターは、 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]以降で導入されました。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="parameterTypes" /> の要素が <see langword="null" /> または <see cref="T:System.Void" /> です。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> は、<see cref="P:System.Type.IsByRef" /> が <see langword="true" /> を返す型です。</exception>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">方法: 動的メソッドを定義および実行する</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">リフレクション出力のセキュリティ関連事項</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md">チュートリアル: 部分信頼シナリオにおけるコード出力</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, System.Reflection.Module m);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), m As Module)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * System.Reflection.Module -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, m)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="name">動的メソッドの名前。 これは、長さ 0 の文字列にできますが、 <see langword="null" />にすることはできません。</param>
        <param name="returnType">動的メソッドの戻り値の型を指定する <see cref="T:System.Type" /> オブジェクト。メソッドに戻り値の型がない場合は <see langword="null" />。</param>
        <param name="parameterTypes">動的メソッドのパラメーターの型を指定する <see cref="T:System.Type" /> オブジェクトの配列。メソッドにパラメーターがない場合は <see langword="null" />。</param>
        <param name="m">動的メソッドを論理的に関連付けるモジュールを表す <see cref="T:System.Reflection.Module" />。</param>
        <summary>メソッド名、戻り値の型、パラメーターの型、およびモジュールを指定して、モジュールに対してグローバルな動的メソッドを作成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンストラクターは、メソッド<xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType>属性<xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>と呼び出し規約<xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>を指定し、just-in-time (JIT) 参照範囲チェックをスキップしません。  
  
 このコンストラクターを使用して作成された動的メソッド`internal`は`Friend` 、モジュール`m`に含まれるすべての型のパブリックおよび (Visual Basic) メンバーにアクセスできます。  
  
> [!NOTE]
>  旧バージョンとの互換性を維持<xref:System.Security.Permissions.SecurityPermission>するため<xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType>に、このコンストラクターは、次の条件が両方とも当てはまる場合はフラグを要求します<xref:System.Security.Permissions.ReflectionPermission> 。は<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>呼び出し元のモジュール以外のモジュール、はフラグを使用したの要求です。 `m`が失敗しました。 の<xref:System.Security.Permissions.SecurityPermission>要求が成功した場合、操作は許可されます。  
  
> [!NOTE]
>  以降では[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメンバーはフラグを<xref:System.Security.Permissions.ReflectionPermission>使用する<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>必要がなくなりました。 (「[リフレクション出力のセキュリティの問題」を](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)参照してください)。この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
   
  
## Examples  
 次のコード例では、2つのパラメーターを受け取る動的メソッドを作成します。 この例では、最初のパラメーターをコンソールに出力する単純な関数本体を出力します。この例では、メソッドの戻り値として2番目のパラメーターを使用します。 この例では、デリゲートを作成してメソッドを完了し、異なるパラメーターを使用してデリゲートを呼び出し、 <xref:System.Reflection.Emit.DynamicMethod.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29>最後にメソッドを使用して動的メソッドを呼び出します。  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="parameterTypes" /> の要素が <see langword="null" /> または <see cref="T:System.Void" /> です。  
  
- または - 
 <paramref name="m" /> が、動的メソッドを匿名でホストするモジュールです。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="m" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> は、<see cref="P:System.Type.IsByRef" /> が <see langword="true" /> を返す型です。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">動的メソッドを、呼び出し元モジュール以外のモジュールに関連付ける場合は。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /> (関連する列挙体)</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">方法: 動的メソッドを定義および実行する</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">リフレクション出力のセキュリティ関連事項</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, Type owner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), owner As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * Type -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, owner)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">動的メソッドの名前。 これは、長さ 0 の文字列にできますが、 <see langword="null" />にすることはできません。</param>
        <param name="returnType">動的メソッドの戻り値の型を指定する <see cref="T:System.Type" /> オブジェクト。メソッドに戻り値の型がない場合は <see langword="null" />。</param>
        <param name="parameterTypes">動的メソッドのパラメーターの型を指定する <see cref="T:System.Type" /> オブジェクトの配列。メソッドにパラメーターがない場合は <see langword="null" /> 。</param>
        <param name="owner">動的メソッドを論理的に関連付ける <see cref="T:System.Type" />。 動的メソッドはこの型のすべてのメンバーにアクセスできます。</param>
        <summary>メソッド名、戻り値の型、パラメーターの型、および動的メソッドを論理的に関連付ける型を指定して、動的メソッドを作成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンストラクターを使用して作成された動的メソッドは、型`owner`のすべてのメンバー、 `internal`および`Friend`を含む`owner`モジュール内の他のすべての型のパブリックおよび (Visual Basic) メンバーにアクセスできます。  
  
 このコンストラクターは、メソッド<xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType>属性<xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>と呼び出し規約<xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>を指定し、just-in-time (JIT) 参照範囲チェックをスキップしません。  
  
> [!NOTE]
>  旧バージョンとの互換性を維持<xref:System.Security.Permissions.SecurityPermission>するため<xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType>に、このコンストラクターは、次の条件`owner`が両方とも当てはまる場合はフラグを必要と<xref:System.Security.Permissions.ReflectionPermission>します。は<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 、呼び出し元のモジュール以外のモジュールにあり、フラグが失敗しました。 の<xref:System.Security.Permissions.SecurityPermission>要求が成功した場合、操作は許可されます。  
  
> [!NOTE]
>  以降では[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメンバーはフラグを<xref:System.Security.Permissions.ReflectionPermission>使用する<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>必要がなくなりました。 (「[リフレクション出力のセキュリティの問題」を](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)参照してください)。この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
   
  
## Examples  
 次のコード例では<xref:System.Reflection.Emit.DynamicMethod> 、型に論理的に関連付けられているを作成します。 この関連付けにより、その型のプライベートメンバーにアクセスできるようになります。  
  
 このコード例では、プライベート`Example`フィールドを持つという名前のクラス`DerivedFromExample`を定義しています。このクラスは、最初の<xref:System.Int32>クラスから派生すると`Example`いう名前のクラスで、を返し、型`UseLikeStatic` <xref:System.Int32>のパラメーターを持つという名前のデリゲート型を指定します。、およびはを返し`UseLikeInstance` <xref:System.Int32> 、型<xref:System.Int32>のパラメーターを1つ持つという名前のデリゲート型。  
  
 このコード例では、 <xref:System.Reflection.Emit.DynamicMethod>のインスタンスのプライベートフィールドを変更し、 `Example`前の値を返すを作成します。  
  
> [!NOTE]
>  一般に、クラスの内部フィールドを変更することは、オブジェクト指向のコーディング手法として適切ではありません。  
  
 このコード例では、の`Example`インスタンスを作成し、2つのデリゲートを作成します。 1つ目の型`UseLikeStatic`はで、動的メソッドと同じパラメーターを持ちます。 2番目のは`UseLikeInstance`型で、最初のパラメーター (型`Example`) が不足しています。 このデリゲートは、 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29>メソッドオーバーロードを使用して作成されます。このメソッドオーバーロードの2番目のパラメーターは、の`Example`インスタンスです。この場合、新しく作成されたデリゲートにバインドされたインスタンスが作成されます。 そのデリゲートが呼び出されるたびに、動的メソッドはの`Example`バインドされたインスタンスに対して動作します。  
  
> [!NOTE]
>  これは、 [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]で導入されたデリゲートバインディングの緩やかな規則の例であり、 <xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType>メソッドの新しいオーバーロードと共に使用されます。 詳細については、<xref:System.Delegate> クラスを参照してください。  
  
 デリゲートが呼び出され、 `UseLikeInstance`デリゲートにバインドされ`Example`ているのインスタンスが渡されます。 `UseLikeStatic` 次に、 `Example`デリゲートが呼び出され、両方のデリゲートがの同じインスタンスで動作するよう`UseLikeInstance`になります。 内部フィールドの値の変更は、各呼び出しの後に表示されます。 最後に、 `UseLikeInstance`デリゲートがの`DerivedFromExample`インスタンスにバインドされ、デリゲート呼び出しが繰り返されます。  
  
 [!code-csharp[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/cs/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="parameterTypes" /> の要素が <see langword="null" /> または <see cref="T:System.Void" /> です。  
  
- または - 
 <paramref name="owner" /> がインターフェイス、配列、オープン ジェネリック型、ジェネリック型またはジェネリック メソッドの型パラメーターです。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="owner" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> が <see langword="null" /> であるか、<see cref="P:System.Type.IsByRef" /> で <see langword="true" /> が返される型です。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">動的メソッドを、呼び出し元モジュール以外のモジュール内の型に関連付ける場合は。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /> (関連する列挙体)</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">方法: 動的メソッドを定義および実行する</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">リフレクション出力のセキュリティ関連事項</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, System.Reflection.Module m, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), m As Module, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * System.Reflection.Module * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, m, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">動的メソッドの名前。 これは、長さ 0 の文字列にできますが、 <see langword="null" />にすることはできません。</param>
        <param name="returnType">動的メソッドの戻り値の型を指定する <see cref="T:System.Type" /> オブジェクト。メソッドに戻り値の型がない場合は <see langword="null" />。</param>
        <param name="parameterTypes">動的メソッドのパラメーターの型を指定する <see cref="T:System.Type" /> オブジェクトの配列。メソッドにパラメーターがない場合は <see langword="null" />。</param>
        <param name="m">動的メソッドを論理的に関連付けるモジュールを表す <see cref="T:System.Reflection.Module" />。</param>
        <param name="skipVisibility">動的メソッドの MSIL によってアクセスされる型およびメンバーに対して JIT の参照範囲チェックをスキップする場合は <see langword="true" />。</param>
        <summary>メソッド名、戻り値の型、パラメーターの型、モジュールを指定し、さらに動的メソッドの MSIL (Microsoft Intermediate Language) によってアクセスされる型およびメンバーに対して JIT (Just-In-Time) の参照範囲チェックをスキップする必要があるかどうかを指定して、モジュールに対してグローバルな動的メソッドを作成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンストラクター <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>は、メソッド<xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType>属性、、および呼び出し<xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>規約を指定します。  
  
 このコンストラクターで作成される動的メソッドは、含まれ`internal`て`Friend`いるモジュール`m`内のすべての型のパブリックおよび (Visual Basic) メンバーにアクセスできます。 JIT コンパイラの参照範囲チェックをスキップすると、動的メソッドは、他のすべての型のプライベートメンバーとプロテクトメンバーにもアクセスできます。 これは、たとえば、オブジェクトをシリアル化するコードを記述する場合に便利です。  
  
> [!NOTE]
>  旧バージョンとの互換性を維持<xref:System.Security.Permissions.SecurityPermission>するため<xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType>に、このコンストラクターは、次の条件が両方とも当てはまる場合はフラグを要求します<xref:System.Security.Permissions.ReflectionPermission> 。は<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>呼び出し元のモジュール以外のモジュール、はフラグを使用したの要求です。 `m`が失敗しました。 の<xref:System.Security.Permissions.SecurityPermission>要求が成功した場合、操作は許可されます。  
  
> [!NOTE]
>  以降では[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメンバーはフラグを<xref:System.Security.Permissions.ReflectionPermission>使用する<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>必要がなくなりました。 (「[リフレクション出力のセキュリティの問題」を](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)参照してください)。この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="parameterTypes" /> の要素が <see langword="null" /> または <see cref="T:System.Void" /> です。  
  
- または - 
 <paramref name="m" /> が、動的メソッドを匿名でホストするモジュールです。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="m" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> は、<see cref="P:System.Type.IsByRef" /> が <see langword="true" /> を返す型です。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">動的メソッドを、呼び出し元モジュール以外のモジュールに関連付ける場合は。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /> (関連する列挙体)</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">方法: 動的メソッドを定義および実行する</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">リフレクション出力のセキュリティ関連事項</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), owner As Type, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * Type * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, owner, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">動的メソッドの名前。 これは、長さ 0 の文字列にできますが、 <see langword="null" />にすることはできません。</param>
        <param name="returnType">動的メソッドの戻り値の型を指定する <see cref="T:System.Type" /> オブジェクト。メソッドに戻り値の型がない場合は <see langword="null" />。</param>
        <param name="parameterTypes">動的メソッドのパラメーターの型を指定する <see cref="T:System.Type" /> オブジェクトの配列。メソッドにパラメーターがない場合は <see langword="null" /> 。</param>
        <param name="owner">動的メソッドを論理的に関連付ける <see cref="T:System.Type" />。 動的メソッドはこの型のすべてのメンバーにアクセスできます。</param>
        <param name="skipVisibility">動的メソッドの MSIL によってアクセスされる型およびメンバーに対して JIT の参照範囲チェックをスキップする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>メソッド名、戻り値の型、パラメーターの型、動的メソッドを論理的に関連付ける型を指定し、さらに動的メソッドの MSIL (Microsoft Intermediate Language) によってアクセスされる型およびメンバーに対して JIT (Just-In-Time) の参照範囲チェックをスキップする必要があるかどうかを指定して、動的メソッドを作成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンストラクターを使用して作成された動的メソッドは、型`owner`のすべてのメンバー、 `internal`および`Friend`を含む`owner`モジュール内の他のすべての型のパブリックおよび (Visual Basic) メンバーにアクセスできます。 JIT コンパイラの参照範囲チェックをスキップすると、動的メソッドは、他のすべての型のプライベートメンバーとプロテクトメンバーにもアクセスできます。 これは、たとえば、オブジェクトをシリアル化するコードを記述する場合に便利です。  
  
 このコンストラクター <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>は、メソッド<xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType>属性、、および呼び出し<xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>規約を指定します。  
  
> [!NOTE]
>  旧バージョンとの互換性を維持<xref:System.Security.Permissions.SecurityPermission>するため<xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType>に、このコンストラクターは、次の条件`owner`が両方とも当てはまる場合はフラグを必要と<xref:System.Security.Permissions.ReflectionPermission>します。は<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 、呼び出し元のモジュール以外のモジュールにあり、フラグが失敗しました。 の<xref:System.Security.Permissions.SecurityPermission>要求が成功した場合、操作は許可されます。  
  
> [!NOTE]
>  以降では[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメンバーはフラグを<xref:System.Security.Permissions.ReflectionPermission>使用する<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>必要がなくなりました。 (「[リフレクション出力のセキュリティの問題」を](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)参照してください)。この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="parameterTypes" /> の要素が <see langword="null" /> または <see cref="T:System.Void" /> です。  
  
または 
 <paramref name="owner" /> がインターフェイス、配列、オープン ジェネリック型、ジェネリック型またはジェネリック メソッドの型パラメーターです。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="owner" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> が <see langword="null" /> であるか、<see cref="P:System.Type.IsByRef" /> で <see langword="true" /> が返される型です。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">動的メソッドを、呼び出し元モジュール以外のモジュール内の型に関連付ける場合は。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /> (関連する列挙体)</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">方法: 動的メソッドを定義および実行する</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">リフレクション出力のセキュリティ関連事項</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Reflection.Module m, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type(), m As Module, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * System.Reflection.Module * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, attributes, callingConvention, returnType, parameterTypes, m, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">動的メソッドの名前。 これは、長さ 0 の文字列にすることはできますが、<see langword="null" /> にすることはできません。</param>
        <param name="attributes">動的メソッドの属性を指定する <see cref="T:System.Reflection.MethodAttributes" /> 値のビットごとの組み合わせ。 許可される組み合わせは、<see cref="F:System.Reflection.MethodAttributes.Public" /> と <see cref="F:System.Reflection.MethodAttributes.Static" /> の組み合わせだけです。</param>
        <param name="callingConvention">動的メソッドの呼び出し規約。 <see cref="F:System.Reflection.CallingConventions.Standard" />にする必要があります。</param>
        <param name="returnType">動的メソッドの戻り値の型を指定する <see cref="T:System.Type" /> オブジェクト。メソッドに戻り値の型がない場合は <see langword="null" /> 。</param>
        <param name="parameterTypes">動的メソッドのパラメーターの型を指定する <see cref="T:System.Type" /> オブジェクトの配列。メソッドにパラメーターがない場合は <see langword="null" />。</param>
        <param name="m">動的メソッドを論理的に関連付けるモジュールを表す <see cref="T:System.Reflection.Module" />。</param>
        <param name="skipVisibility">動的メソッドの MSIL によってアクセスされる型およびメンバーに対して JIT の参照範囲チェックをスキップする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>メソッド名、属性、呼び出し規約、戻り値の型、パラメーターの型、モジュールを指定し、さらに動的メソッドの MSIL (Microsoft Intermediate Language) によってアクセスされる型およびメンバーに対して JIT (Just-In-Time) の参照範囲チェックをスキップする必要があるかどうかを指定して、モジュールに対してグローバルな動的メソッドを作成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンストラクターを使用して作成された動的メソッド`internal`は`Friend` 、モジュール`m`に含まれるすべてのパブリック型と内部型のパブリックおよび (Visual Basic) メンバーにアクセスできます。  
  
 JIT コンパイラの参照範囲チェックを省略すると、動的メソッドは、モジュールおよび他のすべてのアセンブリの他のすべての型のプライベートメンバーとプロテクトメンバーにもアクセスできるようになります。 これは、たとえば、オブジェクトをシリアル化するコードを記述する場合に便利です。  
  
> [!NOTE]
>  旧バージョンとの互換性を維持<xref:System.Security.Permissions.SecurityPermission>するため<xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType>に、このコンストラクターは、次の条件が両方とも当てはまる場合はフラグを要求します<xref:System.Security.Permissions.ReflectionPermission> 。は<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>呼び出し元のモジュール以外のモジュール、はフラグを使用したの要求です。 `m`が失敗しました。 の<xref:System.Security.Permissions.SecurityPermission>要求が成功した場合、操作は許可されます。  
  
> [!NOTE]
>  以降では[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメンバーはフラグを<xref:System.Security.Permissions.ReflectionPermission>使用する<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>必要がなくなりました。 (「[リフレクション出力のセキュリティの問題」を](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)参照してください)。この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="parameterTypes" /> の要素が <see langword="null" /> または <see cref="T:System.Void" /> です。  
  
- または - 
 <paramref name="m" /> が、動的メソッドを匿名でホストするモジュールです。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="m" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="attributes" /> が <see cref="F:System.Reflection.MethodAttributes.Public" /> と <see cref="F:System.Reflection.MethodAttributes.Static" /> 以外のフラグの組み合わせです。  
  
- または - 
 <paramref name="callingConvention" /> が <see cref="F:System.Reflection.CallingConventions.Standard" /> ではありません。  
  
または 
 <paramref name="returnType" /> は、<see cref="P:System.Type.IsByRef" /> が <see langword="true" /> を返す型です。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">動的メソッドを、呼び出し元モジュール以外のモジュールに関連付ける場合は。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /> (関連する列挙体)</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">方法: 動的メソッドを定義および実行する</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">リフレクション出力のセキュリティ関連事項</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type(), owner As Type, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * Type * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, attributes, callingConvention, returnType, parameterTypes, owner, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">動的メソッドの名前。 これは、長さ 0 の文字列にすることはできますが、<see langword="null" /> にすることはできません。</param>
        <param name="attributes">動的メソッドの属性を指定する <see cref="T:System.Reflection.MethodAttributes" /> 値のビットごとの組み合わせ。 許可される組み合わせは、<see cref="F:System.Reflection.MethodAttributes.Public" /> と <see cref="F:System.Reflection.MethodAttributes.Static" /> の組み合わせだけです。</param>
        <param name="callingConvention">動的メソッドの呼び出し規約。 <see cref="F:System.Reflection.CallingConventions.Standard" />にする必要があります。</param>
        <param name="returnType">動的メソッドの戻り値の型を指定する <see cref="T:System.Type" /> オブジェクト。メソッドに戻り値の型がない場合は <see langword="null" /> 。</param>
        <param name="parameterTypes">動的メソッドのパラメーターの型を指定する <see cref="T:System.Type" /> オブジェクトの配列。メソッドにパラメーターがない場合は <see langword="null" /> 。</param>
        <param name="owner">動的メソッドを論理的に関連付ける <see cref="T:System.Type" />。 動的メソッドはこの型のすべてのメンバーにアクセスできます。</param>
        <param name="skipVisibility">動的メソッドの MSIL によってアクセスされる型およびメンバーに対して JIT の参照範囲チェックをスキップする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>メソッド名、属性、呼び出し規約、戻り値の型、パラメーターの型、動的メソッドを論理的に関連付ける型を指定し、さらに動的メソッドの MSIL (Microsoft Intermediate Language) によってアクセスされる型およびメンバーに対して JIT (Just-In-Time) の参照範囲チェックをスキップする必要があるかどうかを指定して、動的メソッドを作成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 動的メソッドは、型`owner`を含むモジュールに対してグローバルです。 この型`owner`のすべてのメンバーにアクセスできます。  
  
 このコンストラクターを使用して作成された動的メソッドは、型`owner`のすべてのメンバーに`internal`アクセスできます。また、を含む`owner`モジュールに格納されているすべての型のパブリックおよび (`Friend` Visual Basic) メンバーにアクセスできます。 JIT コンパイラの参照範囲チェックをスキップすると、動的メソッドは、他のすべての型のプライベートメンバーとプロテクトメンバーにもアクセスできます。 これは、たとえば、オブジェクトをシリアル化するコードを記述する場合に便利です。  
  
> [!NOTE]
>  旧バージョンとの互換性を維持<xref:System.Security.Permissions.SecurityPermission>するため<xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType>に、このコンストラクターは、次の条件`owner`が両方とも当てはまる場合はフラグを必要と<xref:System.Security.Permissions.ReflectionPermission>します。は<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 、呼び出し元のモジュール以外のモジュールにあり、フラグが失敗しました。 の<xref:System.Security.Permissions.SecurityPermission>要求が成功した場合、操作は許可されます。  
  
> [!NOTE]
>  以降では[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメンバーはフラグを<xref:System.Security.Permissions.ReflectionPermission>使用する<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>必要がなくなりました。 (「[リフレクション出力のセキュリティの問題」を](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)参照してください)。この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="parameterTypes" /> の要素が <see langword="null" /> または <see cref="T:System.Void" /> です。  
  
- または - 
 <paramref name="owner" /> がインターフェイス、配列、オープン ジェネリック型、ジェネリック型またはジェネリック メソッドの型パラメーターです。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="owner" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="attributes" /> が <see cref="F:System.Reflection.MethodAttributes.Public" /> と <see cref="F:System.Reflection.MethodAttributes.Static" /> 以外のフラグの組み合わせです。  
  
- または - 
 <paramref name="callingConvention" /> が <see cref="F:System.Reflection.CallingConventions.Standard" /> ではありません。  
  
- または - 
 <paramref name="returnType" /> は、<see cref="P:System.Type.IsByRef" /> が <see langword="true" /> を返す型です。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">動的メソッドを、呼び出し元モジュール以外のモジュール内の型に関連付ける場合は。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /> (関連する列挙体)</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">方法: 動的メソッドを定義および実行する</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">リフレクション出力のセキュリティ関連事項</related>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Attributes As MethodAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodAttributes Attributes { System::Reflection::MethodAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.MethodAttributes" Usage="System.Reflection.Emit.DynamicMethod.Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>動的メソッドの作成時に指定した属性を取得します。</summary>
        <value>メソッドの属性を表す <see cref="T:System.Reflection.MethodAttributes" /> 値のビットごとの組み合わせ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現時点では、動的メソッドのメソッド属性は常<xref:System.Reflection.MethodAttributes.Public>に<xref:System.Reflection.MethodAttributes.Static>とです。  
  
   
  
## Examples  
 次のコード例では、動的メソッドのメソッド属性を表示します。 このコード例は、 <xref:System.Reflection.Emit.DynamicMethod>クラスに対して提供される大規模な例の一部です。  
  
 [!code-cpp[Reflection.DynamicMethod.All#21](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#21)]
 [!code-csharp[Reflection.DynamicMethod.All#21](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#21)]
 [!code-vb[Reflection.DynamicMethod.All#21](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public override System.Reflection.CallingConventions CallingConvention { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.CallingConventions CallingConvention" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CallingConvention As CallingConventions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::CallingConventions CallingConvention { System::Reflection::CallingConventions get(); };" />
      <MemberSignature Language="F#" Value="member this.CallingConvention : System.Reflection.CallingConventions" Usage="System.Reflection.Emit.DynamicMethod.CallingConvention" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.CallingConventions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>動的メソッドの作成時に指定した呼び出し規約を取得します。</summary>
        <value>メソッドの呼び出し規約を示す <see cref="T:System.Reflection.CallingConventions" /> 値のいずれか。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現時点では、動的メソッドの呼び出し規約は常<xref:System.Reflection.CallingConventions.Standard>にです。  
  
   
  
## Examples  
 次のコード例では、動的メソッドの呼び出し規約を表示します。 このコード例は、 <xref:System.Reflection.Emit.DynamicMethod>クラスに対して提供される大規模な例の一部です。  
  
 [!code-cpp[Reflection.DynamicMethod.All#22](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#22)]
 [!code-csharp[Reflection.DynamicMethod.All#22](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#22)]
 [!code-vb[Reflection.DynamicMethod.All#22](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>動的メソッドを完了し、それを実行するために使用できるデリゲートを作成します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public override sealed Delegate CreateDelegate (Type delegateType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Delegate CreateDelegate(class System.Type delegateType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function CreateDelegate (delegateType As Type) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Delegate ^ CreateDelegate(Type ^ delegateType);" />
      <MemberSignature Language="F#" Value="override this.CreateDelegate : Type -&gt; Delegate" Usage="dynamicMethod.CreateDelegate delegateType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="delegateType">シグネチャが動的メソッドのシグネチャと一致するデリゲート型。</param>
        <summary>動的メソッドを完了し、それを実行するために使用できるデリゲートを作成します。</summary>
        <returns>動的メソッドの実行に使用できる指定した型のデリゲート。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>メソッドまたはメソッドを呼び出すと、動的メソッド<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>が完了します。 パラメーター定義の変更や Microsoft 中間言語 (MSIL) の出力など、動的メソッドをさらに変更しようとしても無視されます。例外はスローされません。  
  
 独自の MSIL ジェネレーターがあるときに動的メソッドのメソッド本体を作成するには、 <xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A>メソッドを呼び出して<xref:System.Reflection.Emit.DynamicILInfo>オブジェクトを取得します。 独自の MSIL ジェネレーターがない場合は、メソッドを呼び出し<xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A>て、メソッド本体<xref:System.Reflection.Emit.ILGenerator>を生成するために使用できるオブジェクトを取得します。  
  
   
  
## Examples  
 次のコード例では、2つのパラメーターを受け取る動的メソッドを作成します。 この例では、最初のパラメーターをコンソールに出力する単純な関数本体を出力します。この例では、メソッドの戻り値として2番目のパラメーターを使用します。 この例では、デリゲートを作成してメソッドを完了し、異なるパラメーターを使用してデリゲートを呼び出し、 <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>最後にメソッドを使用して動的メソッドを呼び出します。  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">動的メソッドにメソッド本体がありません。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="delegateType" /> のパラメーターの数に誤りがあるか、パラメーターの型に誤りがあります。</exception>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">方法: 動的メソッドを定義および実行する</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public override sealed Delegate CreateDelegate (Type delegateType, object target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Delegate CreateDelegate(class System.Type delegateType, object target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function CreateDelegate (delegateType As Type, target As Object) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Delegate ^ CreateDelegate(Type ^ delegateType, System::Object ^ target);" />
      <MemberSignature Language="F#" Value="override this.CreateDelegate : Type * obj -&gt; Delegate" Usage="dynamicMethod.CreateDelegate (delegateType, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="delegateType">1 つ目のパラメーターがない、シグネチャが動的メソッドのシグネチャと一致するデリゲート型。</param>
        <param name="target">デリゲートのバインド先となるオブジェクト。 動的メソッドの 1 つ目のパラメーターと同じ型であることが必要です。</param>
        <summary>デリゲート型とデリゲートのバインド先となるオブジェクトを指定して、動的メソッドを完了し、メソッドの実行に使用できるデリゲートを作成します。</summary>
        <returns>指定した対象オブジェクトで動的メソッドの実行に使用できる、指定した型のデリゲート。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドオーバーロードは、特定のオブジェクトにバインドされたデリゲートを作成します。 このようなデリゲートは、最初の引数に対して閉じられると言います。 メソッドは静的ですが、インスタンスメソッドであるかのように動作します。インスタンスが`target`です。  
  
 このメソッドのオーバーロード`target`は、動的メソッドの最初のパラメーターと同じ型であるか、その型 (派生クラスなど) に割り当て可能である必要があります。  の`delegateType`シグネチャには、最初のメソッドを除く動的メソッドのすべてのパラメーターがあります。 たとえば、動的メソッド<xref:System.String>にパラメーター <xref:System.Int32>、、 <xref:System.Byte>および`delegateType`が含まれている場合、には<xref:System.Int32>パラメーター <xref:System.Byte>とが含まれます。`target`の型<xref:System.String>はです。  
  
 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>メソッドまたはメソッドを呼び出すと、動的メソッド<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>が完了します。 パラメーター定義の変更や Microsoft 中間言語 (MSIL) の出力など、動的メソッドをさらに変更しようとしても無視されます。例外はスローされません。  
  
 独自の MSIL ジェネレーターがあるときに動的メソッドのメソッド本体を作成するには、 <xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A>メソッドを呼び出して<xref:System.Reflection.Emit.DynamicILInfo>オブジェクトを取得します。 独自の MSIL ジェネレーターがない場合は、メソッドを呼び出し<xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A>て、メソッド本体<xref:System.Reflection.Emit.ILGenerator>を生成するために使用できるオブジェクトを取得します。  
  
   
  
## Examples  
 次のコード例では、を<xref:System.Reflection.Emit.DynamicMethod>型のインスタンスにバインドするデリゲートを作成します。これにより、メソッドが呼び出されるたびに同じインスタンスに対して動作するようになります。  
  
 このコード例では、プライベート`Example`フィールドを持つという名前のクラス`DerivedFromExample`を定義しています。このクラスは、最初の<xref:System.Int32>クラスから派生すると`Example`いう名前のクラスで、を返し、型`UseLikeStatic` <xref:System.Int32>のパラメーターを持つという名前のデリゲート型を指定します。、およびはを返し`UseLikeInstance` <xref:System.Int32> 、型<xref:System.Int32>のパラメーターを1つ持つという名前のデリゲート型。  
  
 このコード例では、 <xref:System.Reflection.Emit.DynamicMethod>のインスタンスのプライベートフィールドを変更し、 `Example`前の値を返すを作成します。  
  
> [!NOTE]
>  一般に、クラスの内部フィールドを変更することは、オブジェクト指向のコーディング手法として適切ではありません。  
  
 このコード例では、の`Example`インスタンスを作成し、2つのデリゲートを作成します。 1つ目の型`UseLikeStatic`はで、動的メソッドと同じパラメーターを持ちます。 2番目のは`UseLikeInstance`型で、最初のパラメーター (型`Example`) が不足しています。 このデリゲートは、 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29>メソッドオーバーロードを使用して作成されます。このメソッドオーバーロードの2番目のパラメーターは、の`Example`インスタンスです。この場合、新しく作成されたデリゲートにバインドされたインスタンスが作成されます。 そのデリゲートが呼び出されるたびに、動的メソッドはの`Example`バインドされたインスタンスに対して動作します。  
  
> [!NOTE]
>  これは、 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]で導入されたデリゲートバインディングの緩やかな規則の例であり、 <xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType>メソッドの新しいオーバーロードと共に使用されます。 詳細については、<xref:System.Delegate> クラスを参照してください。  
  
 デリゲートが呼び出され、 `UseLikeInstance`デリゲートにバインドされ`Example`ているのインスタンスが渡されます。 `UseLikeStatic` 次に、 `Example`デリゲートが呼び出され、両方のデリゲートがの同じインスタンスで動作するよう`UseLikeInstance`になります。 内部フィールドの値の変更は、各呼び出しの後に表示されます。 最後に、 `UseLikeInstance`デリゲートがの`DerivedFromExample`インスタンスにバインドされ、デリゲート呼び出しが繰り返されます。  
  
 [!code-csharp[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/cs/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">動的メソッドにメソッド本体がありません。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="target" /> が動的メソッドの 1 つ目のパラメーターと同じ型でないため、この型に割り当てることはできません。  
  
- または - 
 <paramref name="delegateType" /> のパラメーターの数に誤りがあるか、パラメーターの型に誤りがあります。</exception>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Reflection.Emit.DynamicMethod.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>動的メソッドに対して常に <see langword="null" /> である、メソッドを宣言する型を取得します。</summary>
        <value>常に <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、 `null`動的メソッドに対して常にを返します。 動的メソッドが型に論理的に関連付けられている場合でも、型によって宣言されません。  
  
   
  
## Examples  
 次のコード例では、動的メソッドの宣言型を表示します。 このコード例は、 <xref:System.Reflection.Emit.DynamicMethod>クラスに対して提供される大規模な例の一部です。  
  
 [!code-cpp[Reflection.DynamicMethod.All#23](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#23)]
 [!code-csharp[Reflection.DynamicMethod.All#23](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#23)]
 [!code-vb[Reflection.DynamicMethod.All#23](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineParameter">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ParameterBuilder DefineParameter (int position, System.Reflection.ParameterAttributes attributes, string parameterName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ParameterBuilder DefineParameter(int32 position, valuetype System.Reflection.ParameterAttributes attributes, string parameterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineParameter (position As Integer, attributes As ParameterAttributes, parameterName As String) As ParameterBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ParameterBuilder ^ DefineParameter(int position, System::Reflection::ParameterAttributes attributes, System::String ^ parameterName);" />
      <MemberSignature Language="F#" Value="member this.DefineParameter : int * System.Reflection.ParameterAttributes * string -&gt; System.Reflection.Emit.ParameterBuilder" Usage="dynamicMethod.DefineParameter (position, attributes, parameterName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="attributes" Type="System.Reflection.ParameterAttributes" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="parameterName" Type="System.String" Index="2" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="position">パラメーター リストのパラメーターの位置。 パラメーターのインデックスは 1 から始まります。最初のパラメーターが 1 です。</param>
        <param name="attributes">パラメーターの属性を指定する <see cref="T:System.Reflection.ParameterAttributes" /> 値のビットごとの組み合わせ。</param>
        <param name="parameterName">パラメーターの名前。 名前は長さ 0 の文字列でもかまいません。</param>
        <summary>動的メソッドのパラメーターを定義します。</summary>
        <returns>常に <see langword="null" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 が`position` 0 の場合、 <xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A>メソッドは戻り値を参照します。 パラメーター情報を設定しても、戻り値には影響しません。  
  
 動的メソッドが既に完了している場合、メソッド<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>また<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>はメソッド<xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A>を呼び出すと、メソッドは無効になります。 例外をスローすることはありません。  
  
   
  
## Examples  
 次のコード例は、動的メソッドのパラメーター情報を定義する方法を示しています。 このコード例は、 <xref:System.Reflection.Emit.DynamicMethod>クラスに対して提供される大規模な例の一部です。  
  
 [!code-cpp[Reflection.DynamicMethod.All#33](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#33)]
 [!code-csharp[Reflection.DynamicMethod.All#33](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#33)]
 [!code-vb[Reflection.DynamicMethod.All#33](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">メソッドにパラメーターが指定されていません。  
  
または 
 <paramref name="position" /> が 0 未満です。  
  
- または - 
 <paramref name="position" /> がメソッドのパラメーター数を超える値です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBaseDefinition">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo GetBaseDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo GetBaseDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetBaseDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBaseDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ GetBaseDefinition();" />
      <MemberSignature Language="F#" Value="override this.GetBaseDefinition : unit -&gt; System.Reflection.MethodInfo" Usage="dynamicMethod.GetBaseDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>メソッドの基本実装を返します。</summary>
        <returns>メソッドの基本実装。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、常に`DynamicMethod`現在のオブジェクトを返します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>メソッドに適用されたカスタム属性を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : bool -&gt; obj[]" Usage="dynamicMethod.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="inherit">カスタム属性を見つけるためにメソッドの継承チェーンを検索する場合は <see langword="true" />。現在のメソッドだけをチェックする場合は <see langword="false" />。</param>
        <summary>メソッドに対して定義されているすべてのカスタム属性を返します。</summary>
        <returns>メソッドのすべてのカスタム属性を表すオブジェクトの配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 動的メソッドの場合、 `true`に`inherit`対してを指定しても効果はありません。これは、メソッドが型で宣言されていないためです。  
  
> [!NOTE]
>  動的メソッドでは、カスタム属性は現在サポートされていません。 返される唯一の属性<xref:System.Runtime.CompilerServices.MethodImplAttribute>はです。メソッド<xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A>を使用して、メソッドの実装フラグをより簡単に取得できます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="dynamicMethod.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="inherit" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="attributeType">返されるカスタム属性の型を表す <see cref="T:System.Type" />。</param>
        <param name="inherit">カスタム属性を見つけるためにメソッドの継承チェーンを検索する場合は <see langword="true" />。現在のメソッドだけをチェックする場合は <see langword="false" />。</param>
        <summary>メソッドに適用されている指定した型のカスタム属性を返します。</summary>
        <returns><paramref name="attributeType" /> 型のメソッドまたは <paramref name="attributeType" /> 型から派生したメソッドの属性を表すオブジェクトの配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 動的メソッドの場合、 `true`に`inherit`対してを指定しても効果はありません。これは、メソッドが型で宣言されていないためです。  
  
> [!NOTE]
>  動的メソッドでは、カスタム属性は現在サポートされていません。 返される唯一の属性<xref:System.Runtime.CompilerServices.MethodImplAttribute>はです。メソッド<xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A>を使用して、メソッドの実装フラグをより簡単に取得できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="attributeType" /> は <see langword="null" />です。</exception>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetDynamicILInfo">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.DynamicILInfo GetDynamicILInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.DynamicILInfo GetDynamicILInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDynamicILInfo () As DynamicILInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::DynamicILInfo ^ GetDynamicILInfo();" />
      <MemberSignature Language="F#" Value="member this.GetDynamicILInfo : unit -&gt; System.Reflection.Emit.DynamicILInfo" Usage="dynamicMethod.GetDynamicILInfo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.DynamicILInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>メタデータ トークン、スコープ、および MSIL (Microsoft Intermediate Language) ストリームからメソッド本体を生成する際に使用できる <see cref="T:System.Reflection.Emit.DynamicILInfo" /> オブジェクトを返します。</summary>
        <returns>メタデータ トークン、スコープ、および MSIL ストリームからメソッド本体を生成する際に使用できる <see cref="T:System.Reflection.Emit.DynamicILInfo" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 クラス<xref:System.Reflection.Emit.DynamicILInfo>は、アンマネージコード生成をサポートするために用意されています。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージコードを実行する場合は。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> (関連する列挙体)</permission>
        <altmember cref="T:System.Reflection.Emit.DynamicILInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetILGenerator">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>動的メソッドの本体を出力する際に使用できる MSIL ジェネレーターを返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetILGenerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator () As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator();" />
      <MemberSignature Language="F#" Value="member this.GetILGenerator : unit -&gt; System.Reflection.Emit.ILGenerator" Usage="dynamicMethod.GetILGenerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>既定の MSIL (Microsoft Intermediate Language) ストリーム サイズである 64 バイトを使用して、このメソッドに対応する MSIL ジェネレーターを返します。</summary>
        <returns>メソッドの <see cref="T:System.Reflection.Emit.ILGenerator" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 動的メソッドが完了した後、メソッド<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>または<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>メソッドを呼び出すことにより、さらに MSIL を追加しようとしても無視されます。 例外をスローすることはありません。  
  
> [!NOTE]
>  動的メソッドでは、一部の完全信頼のシナリオでも、検証不可能なコードに制限があります。 <xref:System.Reflection.Emit.DynamicMethod> については、「解説」の「検証」セクションを参照してください。  
  
   
  
## Examples  
 次のコード例では、2つのパラメーターを受け取る動的メソッドを作成します。 この例では、最初のパラメーターをコンソールに出力する単純な関数本体を出力します。この例では、メソッドの戻り値として2番目のパラメーターを使用します。 この例では、デリゲートを作成してメソッドを完了し、異なるパラメーターを使用してデリゲートを呼び出し、 <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>最後にメソッドを使用して動的メソッドを呼び出します。  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">方法: 動的メソッドを定義および実行する</related>
      </Docs>
    </Member>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator (int streamSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator(int32 streamSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator (streamSize As Integer) As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator(int streamSize);" />
      <MemberSignature Language="F#" Value="member this.GetILGenerator : int -&gt; System.Reflection.Emit.ILGenerator" Usage="dynamicMethod.GetILGenerator streamSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="streamSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="streamSize">MSIL ストリームのサイズ (バイト単位)。</param>
        <summary>指定された MSIL (Microsoft Intermediate Language) ストリーム サイズのメソッドに MSIL ジェネレーターを返します。</summary>
        <returns>MSIL ストリームの指定したサイズを使用するメソッドの <see cref="T:System.Reflection.Emit.ILGenerator" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 動的メソッドが完了した後、メソッド<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>または<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>メソッドを呼び出すことにより、さらに MSIL を追加しようとしても無視されます。 例外をスローすることはありません。  
  
> [!NOTE]
>  動的メソッドでは、一部の完全信頼のシナリオでも、検証不可能なコードに制限があります。 <xref:System.Reflection.Emit.DynamicMethod> については、「解説」の「検証」セクションを参照してください。  
  
   
  
## Examples  
 次のコード例は、このメソッドのオーバーロードを示しています。 このコード例は、 <xref:System.Reflection.Emit.DynamicMethod>クラスに対して提供される大規模な例の一部です。  
  
 [!code-cpp[Reflection.DynamicMethod.All#2](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#2)]
 [!code-csharp[Reflection.DynamicMethod.All#2](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#2)]
 [!code-vb[Reflection.DynamicMethod.All#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">方法: 動的メソッドを定義および実行する</related>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes GetMethodImplementationFlags ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.MethodImplAttributes GetMethodImplementationFlags() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMethodImplementationFlags () As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodImplAttributes GetMethodImplementationFlags();" />
      <MemberSignature Language="F#" Value="override this.GetMethodImplementationFlags : unit -&gt; System.Reflection.MethodImplAttributes" Usage="dynamicMethod.GetMethodImplementationFlags " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>メソッドの実装フラグを返します。</summary>
        <returns>メソッドの実装フラグを表す <see cref="T:System.Reflection.MethodImplAttributes" /> 値のビットごとの組み合わせ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現時点では、動的メソッドのメソッド実装属性<xref:System.Reflection.MethodImplAttributes.IL>は<xref:System.Reflection.MethodImplAttributes.NoInlining>常にとです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParameters">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo[] GetParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ParameterInfo[] GetParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetParameters () As ParameterInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::ParameterInfo ^&gt; ^ GetParameters();" />
      <MemberSignature Language="F#" Value="override this.GetParameters : unit -&gt; System.Reflection.ParameterInfo[]" Usage="dynamicMethod.GetParameters " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>動的メソッドのパラメーターを返します。</summary>
        <returns>動的メソッドのパラメーターを表す <see cref="T:System.Reflection.ParameterInfo" /> オブジェクトの配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この<xref:System.Reflection.ParameterInfo>メソッドによって返されるオブジェクトは、情報だけを対象としています。 パラメーターの<xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A>特性を設定または変更するには、メソッドを使用します。  
  
   
  
## Examples  
 次のコード例では、動的メソッドのパラメーターを表示します。 このコード例は、 <xref:System.Reflection.Emit.DynamicMethod>クラスに対して提供される大規模な例の一部です。  
  
 [!code-cpp[Reflection.DynamicMethod.All#34](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#34)]
 [!code-csharp[Reflection.DynamicMethod.All#34](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#34)]
 [!code-vb[Reflection.DynamicMethod.All#34](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#34)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="InitLocals">
      <MemberSignature Language="C#" Value="public bool InitLocals { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InitLocals" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.InitLocals" />
      <MemberSignature Language="VB.NET" Value="Public Property InitLocals As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool InitLocals { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.InitLocals : bool with get, set" Usage="System.Reflection.Emit.DynamicMethod.InitLocals" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メソッドのローカル変数を 0 で初期化するかどうかを示す値を取得または設定します。</summary>
        <value>メソッドのローカル変数を 0 で初期化する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティがに`true`設定されている場合、生成された Microsoft 中間言語 (MSIL) には、ローカル変数の初期化が含まれます。 に`false`設定されている場合、ローカル変数は初期化されず、生成されたコードは検証できません。  
  
   
  
## Examples  
 次のコード例では<xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A> 、動的メソッドのプロパティを表示します。 このコード例は、 <xref:System.Reflection.Emit.DynamicMethod>クラスに対して提供される大規模な例の一部です。  
  
 [!code-cpp[Reflection.DynamicMethod.All#24](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#24)]
 [!code-csharp[Reflection.DynamicMethod.All#24](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#24)]
 [!code-vb[Reflection.DynamicMethod.All#24](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public override object Invoke (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Invoke(object obj, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] parameters, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ Invoke(System::Object ^ obj, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ parameters, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="override this.Invoke : obj * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="dynamicMethod.Invoke (obj, invokeAttr, binder, parameters, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="parameters" Type="System.Object[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="obj">動的メソッドは静的であるため、このパラメーターは動的メソッドでは無視されます。 <see langword="null" />を指定します。</param>
        <param name="invokeAttr"><see cref="T:System.Reflection.BindingFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="binder">バインディング、引数型の強制変換、メンバーの呼び出し、およびリフレクションを使用した <see cref="T:System.Reflection.Binder" /> オブジェクトの取得を有効にする <see cref="T:System.Reflection.MemberInfo" /> オブジェクト。 <paramref name="binder" /> が <see langword="null" /> の場合は、既定のバインダーが使用されます。 詳細については、「<see cref="T:System.Reflection.Binder" />」を参照してください。</param>
        <param name="parameters">引数リスト。 これは、呼び出すメソッドのパラメーターと同じ数、順序、および型の引数の配列です。 パラメーターがない場合は、このパラメーターを <see langword="null" /> にする必要があります。</param>
        <param name="culture">型の強制変換を制御するために使用する <see cref="T:System.Globalization.CultureInfo" /> のインスタンス。 <see langword="null" /> の場合は、現在のスレッドの <see cref="T:System.Globalization.CultureInfo" /> が使用されます。 たとえば、この情報では、1000 を表す <see cref="T:System.String" /> を <see cref="T:System.Double" /> 値に正しく変換する必要があります。これは、カルチャによって 1000 の表記が異なるためです。</param>
        <summary>指定したカルチャ情報で指定したバインダーの制約に基づいて、指定したパラメーターを使用して動的メソッドを呼び出します。</summary>
        <returns>呼び出されたメソッドの戻り値を格納する <see cref="T:System.Object" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 リストされている例外に加えて、呼び出し元のコードは、動的メソッドによってスローされた例外をキャッチできるように準備する必要があります。  
  
 メソッドによって<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>作成されたデリゲートを使用して動的メソッドを実行する方が、 <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>メソッドを使用して実行するよりも効率的です。  
  
 <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>メソッドまたはメソッドを呼び出すと、動的メソッド<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>が完了します。 パラメーター定義の変更や Microsoft 中間言語 (MSIL) の出力など、動的メソッドをさらに変更しようとしても無視されます。例外はスローされません。  
  
 すべての動的メソッドは静的である`obj`ため、パラメーターは常に無視されます。 動的メソッドをインスタンスメソッドと同様に扱うには、オブジェクトインスタンスを<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29>受け取るオーバーロードを使用します。  
  
 動的メソッドにパラメーターがない場合、の`parameters` `null`値はになります。 それ以外の場合、parameters 配列内の要素の数、型、および順序は、動的メソッドのパラメーターの数、型、および順序と同じである必要があります。  
  
> [!NOTE]
>  このメソッドオーバーロードは、 <xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Object%5B%5D%29> <xref:System.Reflection.MethodBase>クラスから継承されたメソッドオーバーロードによって呼び出されるため、前の解説は両方のオーバーロードに適用されます。  
  
 このメソッドはアクセス許可を直接要求しませんが、動的メソッドを呼び出すと、メソッドに応じてセキュリティ要求が発生する可能性があります。 たとえば、 `restrictedSkipVisibility`パラメーターをに`false`設定して作成された、匿名でホストされる動的メソッドに対する要求は行われません。 `restrictedSkipVisibility`一方、をに`true`設定してメソッドを作成し、そのメソッドがターゲットアセンブリの隠しメンバーにアクセスできるようにする場合、メソッドは、 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>ターゲットアセンブリ<xref:System.Security.Permissions.ReflectionPermission>のアクセス許可とフラグを使用して要求を行います。  
  
> [!NOTE]
>  より前[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]では、このメソッド<xref:System.Security.Permissions.ReflectionPermission>は<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess>フラグを指定する必要があります。  
  
   
  
## Examples  
 次のコード例では、米国英語のカルチャを使用して、完全にバインドされた動的メソッドを呼び出します。 このコード例は、 <xref:System.Reflection.Emit.DynamicMethod>クラスに対して提供される大規模な例の一部です。  
  
 [!code-cpp[Reflection.DynamicMethod.All#4](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#4)]
 [!code-csharp[Reflection.DynamicMethod.All#4](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#4)]
 [!code-vb[Reflection.DynamicMethod.All#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="F:System.Reflection.CallingConventions.VarArgs" /> 呼び出し規約はサポートされていません。</exception>
        <exception cref="T:System.Reflection.TargetParameterCountException"><paramref name="parameters" /> 内の要素数が、動的メソッドのパラメーターの数と一致しません。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="parameters" /> の 1 つ以上の要素の型が、動的メソッドの対応するパラメーターの型と一致しません。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">動的メソッドが、モジュールに関連付けられ、匿名でホストされず、<paramref name="skipVisibility" /> が <see langword="false" /> に設定されて作成されました。ただし、<see langword="public" /> または <see langword="internal" /> (Visual Basic では <see langword="Friend" />) 以外のメンバーにアクセスします。  
  
- または - 
動的メソッドが、匿名でホストされ、<paramref name="skipVisibility" /> が <see langword="false" /> に設定されて作成されました。ただし、<see langword="public" /> 以外のメンバーにアクセスします。  
  
- または - 
この動的メソッドには、検査できないコードが含まれています。 <see cref="T:System.Reflection.Emit.DynamicMethod" /> については、「解説」の「検証」セクションを参照してください。</exception>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.IsDefined : Type * bool -&gt; bool" Usage="dynamicMethod.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="inherit" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="attributeType">検索対象のカスタム属性の型を表す <see cref="T:System.Type" />。</param>
        <param name="inherit">カスタム属性を見つけるためにメソッドの継承チェーンを検索する場合は <see langword="true" />。現在のメソッドだけをチェックする場合は <see langword="false" />。</param>
        <summary>指定したカスタム属性の型が定義されているかどうかを示します。</summary>
        <returns>指定されたカスタム属性の型が定義されている場合は<see langword="true" /> 。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 動的メソッドの場合、 `true`に`inherit`を指定しても効果はありません。 動的メソッドに継承チェーンがありません。  
  
> [!NOTE]
>  動的メソッドでは、カスタム属性は現在サポートされていません。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の動的メソッドがセキュリティ クリティカルまたはセキュリティ セーフ クリティカルであり、重要な操作を実行できるかどうかを示す値を取得します。</summary>
        <value>現在の動的メソッドがセキュリティ クリティカルまたはセキュリティ セーフ クリティカルである場合は <see langword="true" />。現在の動的メソッドが透過的な場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 、 <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A> 、<xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>および<xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A>の各プロパティは、共通言語ランタイム (CLR) によって決定される動的メソッドの透明度レベルを報告します。 これらのプロパティの組み合わせを次の表に示します。  
  
|セキュリティ レベル|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|重大|`true`|`false`|`false`|  
|安全クリティカル|`true`|`true`|`false`|  
|透明|`false`|`false`|`true`|  
  
 これらのプロパティを使用する方が、アセンブリとその型のセキュリティの注釈を調べたり、現在の信頼レベルを確認したり、ランタイムの規則を複製したりするより、はるかに簡単です。  
  
 動的メソッドの透過性は、関連付けられているモジュールによって異なります。 動的メソッドがモジュールではなく型に関連付けられている場合、その透過性は、型を含むモジュールに依存します。 動的メソッドにはセキュリティの注釈がないため、関連付けられているモジュールの既定の透明度が割り当てられます。  
  
-   匿名でホストされる動的メソッドは、それらを格納するシステム提供のモジュールが透過的であるため、常に透過的です。  
  
-   信頼されたアセンブリ (グローバルアセンブリキャッシュにインストールされる厳密な名前付きアセンブリ) に関連付けられている動的メソッドの透過性を次の表に示します。  
  
    |アセンブリの注釈|レベル1の透過性|レベル2の透過性|  
    |-------------------------|--------------------------|--------------------------|  
    |完全に透明|透明|透明|  
    |完全にクリティカル|重大|重大|  
    |透明度の混合|透明|透明|  
    |セキュリティに依存しない|セーフ クリティカル|重大|  
  
     たとえば、動的メソッドを mscorlib.dll にある型に関連付けていて、レベル2の混合透明度が指定されている場合、動的メソッドは透過的であり、クリティカルコードを実行できません。 透過性レベルの詳細については、「[透過的セキュリティコード](~/docs/framework/misc/security-transparent-code-level-1.md)」、「レベル1」、および「[透過的セキュリティコード (レベル 2](~/docs/framework/misc/security-transparent-code-level-2.md))」を参照してください。  
  
    > [!NOTE]
    >  動的メソッドと、セキュリティに依存しない信頼レベル1のアセンブリ (system.object など) のモジュールとの関連付けは、信頼の昇格を許可しません。 動的メソッドを呼び出すコードの許可セットに、システム .dll の許可セット (つまり、完全信頼) が含まれていない場合は、 <xref:System.Security.SecurityException>動的メソッドが呼び出されると、がスローされます。  
  
-   部分的に信頼されたアセンブリに関連付けられている動的メソッドの透過性は、アセンブリの読み込み方法によって異なります。 アセンブリが部分信頼 (たとえば、サンドボックス化されたアプリケーションドメインに含まれる) で読み込まれた場合、ランタイムはアセンブリのセキュリティ注釈を無視します。 アセンブリと、動的メソッドを含むすべての型およびメンバーは、透過的として扱われます。 ランタイムは、部分信頼アセンブリが完全信頼で読み込まれている場合にのみ、セキュリティ注釈に注意します (たとえば、デスクトップアプリケーションの既定のアプリケーションドメインに)。 この場合、ランタイムは、アセンブリの注釈に従って、メソッドの既定の透過性を動的メソッドに割り当てます。  
  
 リフレクション出力と透明度の詳細については、「[リフレクション出力のセキュリティの問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)」を参照してください。 透明度の詳細については、「[セキュリティの変更](~/docs/framework/security/security-changes.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">動的メソッドにメソッドの本体がありません。</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">リフレクション出力のセキュリティ関連事項</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">リフレクションに関するセキュリティ上の考慮事項</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">.NET Framework バージョン 4 におけるセキュリティの変更点</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf">透過的セキュリティコード、レベル1</related>
        <related type="Article" href="https://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0">透過的セキュリティ コード、レベル 2</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の動的メソッドが現在の信頼レベルでセキュリティ セーフ クリティカルであり、重要な操作を実行でき、透過的なコードからアクセスできるかどうかを示す値を取得します。</summary>
        <value>現在の動的メソッドが現在の信頼レベルでセキュリティ セーフ クリティカルである場合は <see langword="true" />。現在の動的メソッドがセキュリティ クリティカルまたは透過的な場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 、 <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A> 、<xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>および<xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A>の各プロパティは、共通言語ランタイム (CLR) によって決定される動的メソッドの透明度レベルを報告します。 これらのプロパティの組み合わせを次の表に示します。  
  
|セキュリティ レベル|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|重大|`true`|`false`|`false`|  
|安全クリティカル|`true`|`true`|`false`|  
|透明|`false`|`false`|`true`|  
  
 これらのプロパティを使用する方が、アセンブリとその型のセキュリティの注釈を調べたり、現在の信頼レベルを確認したり、ランタイムの規則を複製したりするより、はるかに簡単です。  
  
 動的メソッドの透過性は、関連付けられているモジュールによって異なります。 動的メソッドがモジュールではなく型に関連付けられている場合、その透過性は、型を含むモジュールに依存します。 動的メソッドにはセキュリティの注釈がないため、関連付けられているモジュールの既定の透明度が割り当てられます。  
  
-   匿名でホストされる動的メソッドは、それらを格納するシステム提供のモジュールが透過的であるため、常に透過的です。  
  
-   信頼されたアセンブリ (グローバルアセンブリキャッシュにインストールされる厳密な名前付きアセンブリ) に関連付けられている動的メソッドの透過性を次の表に示します。  
  
    |アセンブリの注釈|レベル1の透過性|レベル2の透過性|  
    |-------------------------|--------------------------|--------------------------|  
    |完全に透明|透明|透明|  
    |完全にクリティカル|重大|重大|  
    |透明度の混合|透明|透明|  
    |セキュリティに依存しない|セーフ クリティカル|重大|  
  
     たとえば、動的メソッドを mscorlib.dll にある型に関連付けていて、レベル2の混合透明度が指定されている場合、動的メソッドは透過的であり、クリティカルコードを実行できません。 透過性レベルの詳細については、「[透過的セキュリティコード](~/docs/framework/misc/security-transparent-code-level-1.md)」、「レベル1」、および「[透過的セキュリティコード (レベル 2](~/docs/framework/misc/security-transparent-code-level-2.md))」を参照してください。  
  
    > [!NOTE]
    >  動的メソッドと、セキュリティに依存しない信頼レベル1のアセンブリ (system.object など) のモジュールとの関連付けは、信頼の昇格を許可しません。 動的メソッドを呼び出すコードの許可セットに、システム .dll の許可セット (つまり、完全信頼) が含まれていない場合は、 <xref:System.Security.SecurityException>動的メソッドが呼び出されると、がスローされます。  
  
-   部分的に信頼されたアセンブリに関連付けられている動的メソッドの透過性は、アセンブリの読み込み方法によって異なります。 アセンブリが部分信頼 (たとえば、サンドボックス化されたアプリケーションドメインに含まれる) で読み込まれた場合、ランタイムはアセンブリのセキュリティ注釈を無視します。 アセンブリと、動的メソッドを含むすべての型およびメンバーは、透過的として扱われます。 ランタイムは、部分信頼アセンブリが完全信頼で読み込まれている場合にのみ、セキュリティ注釈に注意します (たとえば、デスクトップアプリケーションの既定のアプリケーションドメインに)。 この場合、ランタイムは、アセンブリの注釈に従って、メソッドの既定の透過性を動的メソッドに割り当てます。  
  
 リフレクション出力と透明度の詳細については、「[リフレクション出力のセキュリティの問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)」を参照してください。 透明度の詳細については、「[セキュリティの変更](~/docs/framework/security/security-changes.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">動的メソッドにメソッドの本体がありません。</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">リフレクション出力のセキュリティ関連事項</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">リフレクションに関するセキュリティ上の考慮事項</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">.NET Framework バージョン 4 におけるセキュリティの変更点</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf">透過的セキュリティコード、レベル1</related>
        <related type="Article" href="https://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0">透過的セキュリティ コード、レベル 2</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public override bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の動的メソッドが現在の信頼レベルで透過的であり、重要な操作を実行できないかどうかを示す値を取得します。</summary>
        <value>現在の動的メソッドが現在の信頼レベルで透過的セキュリティである場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 、 <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A> 、<xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>および<xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A>の各プロパティは、共通言語ランタイム (CLR) によって決定される動的メソッドの透明度レベルを報告します。 これらのプロパティの組み合わせを次の表に示します。  
  
|セキュリティ レベル|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|重大|`true`|`false`|`false`|  
|安全クリティカル|`true`|`true`|`false`|  
|透明|`false`|`false`|`true`|  
  
 これらのプロパティを使用する方が、アセンブリとその型のセキュリティの注釈を調べたり、現在の信頼レベルを確認したり、ランタイムの規則を複製したりするより、はるかに簡単です。  
  
 動的メソッドの透過性は、関連付けられているモジュールによって異なります。 動的メソッドがモジュールではなく型に関連付けられている場合、その透過性は、型を含むモジュールに依存します。 動的メソッドにはセキュリティの注釈がないため、関連付けられているモジュールの既定の透明度が割り当てられます。  
  
-   匿名でホストされる動的メソッドは、それらを格納するシステム提供のモジュールが透過的であるため、常に透過的です。  
  
-   信頼されたアセンブリ (グローバルアセンブリキャッシュにインストールされる厳密な名前付きアセンブリ) に関連付けられている動的メソッドの透過性を次の表に示します。  
  
    |アセンブリの注釈|レベル1の透過性|レベル2の透過性|  
    |-------------------------|--------------------------|--------------------------|  
    |完全に透明|透明|透明|  
    |完全にクリティカル|重大|重大|  
    |透明度の混合|透明|透明|  
    |セキュリティに依存しない|セーフ クリティカル|重大|  
  
     たとえば、動的メソッドを mscorlib.dll にある型に関連付けていて、レベル2の混合透明度が指定されている場合、動的メソッドは透過的であり、クリティカルコードを実行できません。 透過性レベルの詳細については、「[透過的セキュリティコード](~/docs/framework/misc/security-transparent-code-level-1.md)」、「レベル1」、および「[透過的セキュリティコード (レベル 2](~/docs/framework/misc/security-transparent-code-level-2.md))」を参照してください。  
  
    > [!NOTE]
    >  動的メソッドと、セキュリティに依存しない信頼レベル1のアセンブリ (system.object など) のモジュールとの関連付けは、信頼の昇格を許可しません。 動的メソッドを呼び出すコードの許可セットに、システム .dll の許可セット (つまり、完全信頼) が含まれていない場合は、 <xref:System.Security.SecurityException>動的メソッドが呼び出されると、がスローされます。  
  
-   部分的に信頼されたアセンブリに関連付けられている動的メソッドの透過性は、アセンブリの読み込み方法によって異なります。 アセンブリが部分信頼 (たとえば、サンドボックス化されたアプリケーションドメインに含まれる) で読み込まれた場合、ランタイムはアセンブリのセキュリティ注釈を無視します。 アセンブリと、動的メソッドを含むすべての型およびメンバーは、透過的として扱われます。 ランタイムは、部分信頼アセンブリが完全信頼で読み込まれている場合にのみ、セキュリティ注釈に注意します (たとえば、デスクトップアプリケーションの既定のアプリケーションドメインに)。 この場合、ランタイムは、アセンブリの注釈に従って、メソッドの既定の透過性を動的メソッドに割り当てます。  
  
 リフレクション出力と透明度の詳細については、「[リフレクション出力のセキュリティの問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)」を参照してください。 透明度の詳細については、「[セキュリティの変更](~/docs/framework/security/security-changes.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">動的メソッドにメソッドの本体がありません。</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">リフレクション出力のセキュリティ関連事項</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">リフレクションに関するセキュリティ上の考慮事項</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">.NET Framework バージョン 4 におけるセキュリティの変更点</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf">透過的セキュリティコード、レベル1</related>
        <related type="Article" href="https://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0">透過的セキュリティ コード、レベル 2</related>
      </Docs>
    </Member>
    <Member MemberName="MethodHandle">
      <MemberSignature Language="C#" Value="public override RuntimeMethodHandle MethodHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeMethodHandle MethodHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.MethodHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodHandle As RuntimeMethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeMethodHandle MethodHandle { RuntimeMethodHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodHandle : RuntimeMethodHandle" Usage="System.Reflection.Emit.DynamicMethod.MethodHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeMethodHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>動的メソッドではサポートされていません。</summary>
        <value>動的メソッドではサポートされていません。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">動的メソッドでは使用できません。</exception>
      </Docs>
    </Member>
    <Member MemberName="MethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes MethodImplementationFlags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodImplAttributes MethodImplementationFlags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.MethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodImplementationFlags As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodImplAttributes MethodImplementationFlags { System::Reflection::MethodImplAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodImplementationFlags : System.Reflection.MethodImplAttributes" Usage="System.Reflection.Emit.DynamicMethod.MethodImplementationFlags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Module" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Reflection.Emit.DynamicMethod.Module" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>動的メソッドを論理的に関連付けるモジュールを取得します。</summary>
        <value>現在の動的メソッドを関連付ける <see cref="T:System.Reflection.Module" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 動的メソッドの作成時にモジュールが指定された場合、このプロパティはそのモジュールを返します。 動的メソッドの作成時に所有者として型が指定された場合、このプロパティはその型を含むモジュールを返します。  
  
   
  
## Examples  
 次のコード例では<xref:System.Reflection.Emit.DynamicMethod.Module%2A> 、動的メソッドのプロパティを表示します。 このコード例は、 <xref:System.Reflection.Emit.DynamicMethod>クラスに対して提供される大規模な例の一部です。  
  
 [!code-cpp[Reflection.DynamicMethod.All#26](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#26)]
 [!code-csharp[Reflection.DynamicMethod.All#26](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#26)]
 [!code-vb[Reflection.DynamicMethod.All#26](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#26)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Reflection.Emit.DynamicMethod.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>動的メソッドの名前を取得します。</summary>
        <value>メソッドの簡易名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  動的メソッドに名前を指定する必要はありません。  
  
   
  
## Examples  
 次のコード例では、動的メソッドの名前を表示します。 このコード例は、 <xref:System.Reflection.Emit.DynamicMethod>クラスに対して提供される大規模な例の一部です。  
  
 [!code-cpp[Reflection.DynamicMethod.All#27](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#27)]
 [!code-csharp[Reflection.DynamicMethod.All#27](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#27)]
 [!code-vb[Reflection.DynamicMethod.All#27](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#27)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Reflection.Emit.DynamicMethod.ReflectedType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メソッドを取得するためにリフレクションで使用したクラスを取得します。</summary>
        <value>常に <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、 `null`動的メソッドに対して常にを返します。  
  
   
  
## Examples  
 次のコード例では、動的メソッドのリフレクションされた型を表示します。 このコード例は、 <xref:System.Reflection.Emit.DynamicMethod>クラスに対して提供される大規模な例の一部です。  
  
 [!code-cpp[Reflection.DynamicMethod.All#28](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#28)]
 [!code-csharp[Reflection.DynamicMethod.All#28](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#28)]
 [!code-vb[Reflection.DynamicMethod.All#28](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#28)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnParameter">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo ReturnParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ParameterInfo ReturnParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnParameter As ParameterInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ParameterInfo ^ ReturnParameter { System::Reflection::ParameterInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnParameter : System.Reflection.ParameterInfo" Usage="System.Reflection.Emit.DynamicMethod.ReturnParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>動的メソッドの返されるパラメーターを取得します。</summary>
        <value>常に <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、 `null`動的メソッドに対して常にを返します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnType">
      <MemberSignature Language="C#" Value="public override Type ReturnType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReturnType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReturnType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnType : Type" Usage="System.Reflection.Emit.DynamicMethod.ReturnType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>動的メソッドの戻り値の型を取得します。</summary>
        <value>現在のメソッドの戻り値の型を表す <see cref="T:System.Type" />。メソッドに戻り値の型がない場合は <see cref="T:System.Void" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 動的`null`メソッドの作成時に戻り値の型にが指定された場合<xref:System.Void?displayProperty=nameWithType>、このプロパティはを返します。  
  
   
  
## Examples  
 次のコード例では、動的メソッドの戻り値の型を表示します。 このコード例は、 <xref:System.Reflection.Emit.DynamicMethod>クラスに対して提供される大規模な例の一部です。  
  
 [!code-cpp[Reflection.DynamicMethod.All#30](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#30)]
 [!code-csharp[Reflection.DynamicMethod.All#30](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#30)]
 [!code-vb[Reflection.DynamicMethod.All#30](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#30)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnTypeCustomAttributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnTypeCustomAttributes As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ICustomAttributeProvider ^ ReturnTypeCustomAttributes { System::Reflection::ICustomAttributeProvider ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnTypeCustomAttributes : System.Reflection.ICustomAttributeProvider" Usage="System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>動的メソッドの戻り値の型のカスタム属性を取得します。</summary>
        <value>動的メソッドの戻り値の型のカスタム属性を表す <see cref="T:System.Reflection.ICustomAttributeProvider" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 動的メソッドの戻り値の型ではカスタム属性がサポートされていないため、 <xref:System.Reflection.ICustomAttributeProvider.GetCustomAttributes%2A>メソッドによって返されるカスタム属性の配列は常に空になります。  
  
   
  
## Examples  
 次のコード例は、動的メソッドの戻り値の型のカスタム属性を表示する方法を示しています。 このコード例は、 <xref:System.Reflection.Emit.DynamicMethod>クラスに対して提供される大規模な例の一部です。  
  
 [!code-cpp[Reflection.DynamicMethod.All#31](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#31)]
 [!code-csharp[Reflection.DynamicMethod.All#31](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#31)]
 [!code-vb[Reflection.DynamicMethod.All#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#31)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.ReturnType" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dynamicMethod.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>文字列として表されたメソッドのシグネチャを返します。</summary>
        <returns>メソッドのシグネチャを表す文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 シグネチャには、型とメソッド名 (存在する場合) のみが含まれます。 パラメーター名は含まれません。  
  
   
  
## Examples  
 次のコード例では<xref:System.Reflection.Emit.DynamicMethod.ToString%2A> 、動的メソッドのメソッドを表示します。 このコード例は、 <xref:System.Reflection.Emit.DynamicMethod>クラスに対して提供される大規模な例の一部です。  
  
 [!code-cpp[Reflection.DynamicMethod.All#32](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#32)]
 [!code-csharp[Reflection.DynamicMethod.All#32](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#32)]
 [!code-vb[Reflection.DynamicMethod.All#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>