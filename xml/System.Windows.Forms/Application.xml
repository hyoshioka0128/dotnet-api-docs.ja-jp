<Type Name="Application" FullName="System.Windows.Forms.Application">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5e030aa8a8801c2db61e3fbd8cbc521c6e064615" /><Meta Name="ms.sourcegitcommit" Value="2767b5903996fbd7e2b81eda1114dfc9d0d9db63" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="05/02/2019" /><Meta Name="ms.locfileid" Value="65016205" /></Metadata><TypeSignature Language="C#" Value="public sealed class Application" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Application extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Application" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Application" />
  <TypeSignature Language="C++ CLI" Value="public ref class Application sealed" />
  <TypeSignature Language="F#" Value="type Application = class" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Windows メッセージを処理するために、アプリケーションを開始および停止するメソッドや、アプリケーションの情報を取得するためのプロパティなど、アプリケーションを管理するための <see langword="static" /> メソッドおよびプロパティを提供します。 このクラスは継承できません。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Application>クラスには、次のように、アプリケーションとスレッドを開始および停止したり、Windows メッセージを処理したりするためのメソッドがあります。  
  
-   <xref:System.Windows.Forms.Application.Run%2A>現在のスレッドでアプリケーションメッセージループを開始し、必要に応じてフォームを表示します。  
  
-   <xref:System.Windows.Forms.Application.Exit%2A>また<xref:System.Windows.Forms.Application.ExitThread%2A>はメッセージループを停止します。  
  
-   <xref:System.Windows.Forms.Application.DoEvents%2A>プログラムがループ内にある間にメッセージを処理します。  
  
-   <xref:System.Windows.Forms.Application.AddMessageFilter%2A>Windows メッセージを監視するためのメッセージフィルターをアプリケーションメッセージポンプに追加します。  
  
-   <xref:System.Windows.Forms.IMessageFilter>イベントハンドラーを呼び出す前に、イベントの発生を停止したり、特殊な操作を実行したりできます。  
  
 このクラスに<xref:System.Windows.Forms.Application.CurrentCulture%2A>は<xref:System.Windows.Forms.Application.CurrentInputLanguage%2A> 、現在のスレッドのカルチャ情報を取得または設定するためのプロパティとプロパティがあります。  
  
 このクラスのインスタンスを作成することはできません。  
  
   
  
## Examples  
 次のコード例では、フォームのリストボックス内の数値を一覧表示します。 をクリック`button1`するたびに、アプリケーションによってリストに別の番号が追加されます。  
  
 メソッド`Main`は、 <xref:System.Windows.Forms.Application.Run%2A>アプリケーションを起動するためにを呼び出します。 `listBox1`これ`button1`により、フォームとが作成されます。 ユーザーがをクリック`button1` `button1_Click`すると、メソッドに<xref:System.Windows.Forms.MessageBox>が表示されます。 ユーザーがをクリック`No` <xref:System.Windows.Forms.MessageBox>すると、 `button1_Click`メソッドによってリストに数値が追加されます。 ユーザーがをクリック`Yes`すると、アプリケーション<xref:System.Windows.Forms.Application.Exit%2A>はを呼び出してキュー内の残りのすべてのメッセージを処理し、終了します。  
  
> [!NOTE]
>  部分信頼で<xref:System.Windows.Forms.Application.Exit%2A>は、への呼び出しは失敗します。  
  
 [!code-cpp[Classic Application Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application Example/CS/source.cs#1)]
 [!code-vb[Classic Application Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddMessageFilter">
      <MemberSignature Language="C#" Value="public static void AddMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberSignature Language="F#" Value="static member AddMessageFilter : System.Windows.Forms.IMessageFilter -&gt; unit" Usage="System.Windows.Forms.Application.AddMessageFilter value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">インストールする <see cref="T:System.Windows.Forms.IMessageFilter" /> インターフェイスの実装。</param>
        <summary>メッセージ フィルターを追加して、ルーティング先にルーティングされる Windows メッセージを監視します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メッセージフィルターを使用して、特定のイベントが発生しないようにするか、イベントをイベントハンドラーに渡す前にイベントに対して特別な操作を実行します。 メッセージフィルターは、特定のスレッドに対して一意です。  
  
 メッセージがディスパッチされないようにする`value`には、このメソッドに渡すパラメーターインスタンスが、 <xref:System.Windows.Forms.IMessageFilter.PreFilterMessage%2A>メッセージを処理するコードを使用してメソッドをオーバーライドする必要があります。 メソッドは `false`を返します。  
  
> [!CAUTION]
>  アプリケーションのメッセージポンプにメッセージフィルターを追加すると、パフォーマンスが低下する可能性があります。  
  
   
  
## Examples  
 次のコード例では、という`TestMessageFilter`名前のメッセージフィルターを作成します。 このフィルターは、マウスの左ボタンに関連するすべてのメッセージをブロックします。 メッセージフィルターを使用するには、 <xref:System.Windows.Forms.IMessageFilter>インターフェイスの実装を提供する必要があります。  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">直前の呼び出し元がアンマネージコードを呼び出す場合は。 関連付けられた列挙型:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AllowQuit">
      <MemberSignature Language="C#" Value="public static bool AllowQuit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool AllowQuit" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.AllowQuit" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AllowQuit As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool AllowQuit { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AllowQuit : bool" Usage="System.Windows.Forms.Application.AllowQuit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>呼び出し元がこのアプリケーションを終了できるかどうかを示す値を取得します。</summary>
        <value>呼び出し元がこのアプリケーションを終了できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは`false` 、 <xref:System.Windows.Forms.Control> Web ブラウザー内でホストされているから呼び出された場合にを返します。 したがって<xref:System.Windows.Forms.Control> 、はを<xref:System.Windows.Forms.Application>終了できません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ApplicationExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ApplicationExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ApplicationExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ApplicationExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ApplicationExit;" />
      <MemberSignature Language="F#" Value="member this.ApplicationExit : EventHandler " Usage="member this.ApplicationExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションをシャットダウンしようとすると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントハンドラーを`ApplicationExit`イベントにアタッチして、アプリケーションの実行を停止する前に、未処理の必須タスクを実行する必要があります。 このアプリケーションによって開かれたファイルを閉じることができます。また、ガベージコレクションによって再利用されなかったオブジェクトを破棄することもできます。  
  
 これは静的イベントなので、イベントハンドラー自体でこのイベントにアタッチされて`ApplicationExit`いるすべてのイベントハンドラーをデタッチする必要があります。 これらのハンドラーをデタッチしないと、イベントにアタッチされたままになり、メモリが引き続き使用されます。  
  
   
  
## Examples  
 次のコード例では、2つのフォームを表示し、両方のフォームが閉じられたときにアプリケーションを終了します。 アプリケーションの開始時と終了時には、各フォームの位置が記憶されます。 この例では`ApplicationExit` 、イベントを使用して、フォームの位置をファイルに保存するタイミング、および`FileStream`を閉じる必要があるタイミングを確認します。  
  
 クラス`MyApplicationContext`は、から<xref:System.Windows.Forms.ApplicationContext>継承され、各フォームが閉じられたときにを追跡し、両方ともの場合、現在のスレッドを終了します。 クラスは、各フォームが閉じられたときの位置を記憶します。 `ApplicationExit`イベントが発生すると、クラスはユーザーのの位置をファイルに書き込みます。 フォーム位置データは、によって`appdata.txt` <xref:System.Windows.Forms.Application.UserAppDataPath%2A>決定された場所に作成されるという名前のファイルに格納されます。 メソッド`Main`は、 `Application.Run(context)` を指定してアプリケーションを起動するために<xref:System.Windows.Forms.ApplicationContext>を呼び出します。  
  
 このコードは、 <xref:System.Windows.Forms.ApplicationContext>クラスの概要に示されている例から抜粋したものです。 コード<xref:System.Windows.Forms.ApplicationContext>全体の一覧については、「」を参照してください。  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataPath">
      <MemberSignature Language="C#" Value="public static string CommonAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CommonAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CommonAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommonAppDataPath : string" Usage="System.Windows.Forms.Application.CommonAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>すべてのユーザーで共有するアプリケーション データのパスを取得します。</summary>
        <value>すべてのユーザーで共有するアプリケーション データのパス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 パスが存在しない場合は、次の形式で作成されます。  
  
 *基本パス*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>  
  
 最初にメインの実行可能ファイルを含むアセンブリに `AssemblyInformationalVersion` 属性が含まれているかどうかを調べます。 この属性が存在する場合は、<xref:System.Windows.Forms.Application.ProductVersion%2A>と<xref:System.Windows.Forms.Application.CommonAppDataPath%2A>の両方で <xref:System.Windows.Forms.Application.ProductVersion%2A>が使用されます。 この属性が存在しない場合、両方のプロパティで、実行可能ファイルのバージョンが代わりに使用されます。  
  
 パスは、Windows フォーム アプリケーションの配置に、[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]を使用しているかどうかによって異なります。 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] アプリケーションは、C:\Documents and Settings\\*username* ディレクトリでユーザーごとのアプリケーション キャッシュに格納されます。 詳細については、[ローカルへのアクセスとリモート データには、ClickOnce アプリケーション](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d) を参照してください。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey CommonAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey CommonAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ CommonAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommonAppDataRegistry : Microsoft.Win32.RegistryKey" Usage="System.Windows.Forms.Application.CommonAppDataRegistry" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>すべてのユーザーが共有するアプリケーション データのレジストリ キーを取得します。</summary>
        <value>すべてのユーザーが共有するアプリケーション データのレジストリ キーを表す <see cref="T:Microsoft.Win32.RegistryKey" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キーが存在しない場合は、次の形式で作成されます。  
  
 LocalMachine\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompanyName">
      <MemberSignature Language="C#" Value="public static string CompanyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CompanyName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CompanyName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompanyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CompanyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompanyName : string" Usage="System.Windows.Forms.Application.CompanyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションに関連付けられている会社名を取得します。</summary>
        <value>会社名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例では、このプロパティを取得し、テキストボックスにその値を表示します。 この例では`textBox1` 、がフォームに配置されている必要があります。  
  
 [!code-cpp[Classic Application.CompanyName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CompanyName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CompanyName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CompanyName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="T:System.Reflection.AssemblyCompanyAttribute" />
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public static System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCulture : System.Globalization.CultureInfo with get, set" Usage="System.Windows.Forms.Application.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のスレッドのカルチャ情報を取得または設定します。</summary>
        <value>現在のスレッドのカルチャ情報を表す <see cref="T:System.Globalization.CultureInfo" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例では、このプロパティを取得し、テキストボックスにその値を表示します。 この例では`textBox1` 、がフォームに配置されている必要があります。  
  
 [!code-cpp[Classic Application.CurrentCulture Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentCulture Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentCulture Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">すべてのウィンドウでこのプロパティを設定します。 関連付けられた列挙型:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="CurrentInputLanguage">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.InputLanguage CurrentInputLanguage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.InputLanguage CurrentInputLanguage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentInputLanguage" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentInputLanguage As InputLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::InputLanguage ^ CurrentInputLanguage { System::Windows::Forms::InputLanguage ^ get(); void set(System::Windows::Forms::InputLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentInputLanguage : System.Windows.Forms.InputLanguage with get, set" Usage="System.Windows.Forms.Application.CurrentInputLanguage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InputLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のスレッドの現在の入力言語を取得または設定します。</summary>
        <value>現在のスレッドの現在の入力言語を表す <see cref="T:System.Windows.Forms.InputLanguage" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例では、このプロパティを取得し、テキストボックスにその値を表示します。 この例では`textBox1` 、がフォームに配置されている必要があります。  
  
 [!code-cpp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">直前の呼び出し元がアンマネージコードを呼び出す場合は。 関連付けられた列挙型:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="DoEvents">
      <MemberSignature Language="C#" Value="public static void DoEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DoEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.DoEvents" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DoEvents ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DoEvents();" />
      <MemberSignature Language="F#" Value="static member DoEvents : unit -&gt; unit" Usage="System.Windows.Forms.Application.DoEvents " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>メッセージ キューに現在ある Windows メッセージをすべて処理します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows フォームを実行すると、新しいフォームが作成され、イベントが処理されるまで待機します。 フォームがイベントを処理するたびに、そのイベントに関連付けられているすべてのコードが処理されます。 他のすべてのイベントは、キューで待機します。 コードによってイベントが処理されても、アプリケーションは応答しません。 たとえば、別のウィンドウが上にドラッグされている場合、ウィンドウは再描画されません。  
  
 コードでを<xref:System.Windows.Forms.Application.DoEvents%2A>呼び出すと、アプリケーションは他のイベントを処理できます。 たとえば、に<xref:System.Windows.Forms.ListBox>データを追加してコードに追加<xref:System.Windows.Forms.Application.DoEvents%2A>するフォームがある場合、別のウィンドウをドラッグするとフォームが再描画されます。 コードからを<xref:System.Windows.Forms.Application.DoEvents%2A>削除した場合、ボタンのクリックイベントハンドラーの実行が完了するまでフォームは再描画されません。 メッセージングの詳細については、「 [Windows フォームでのユーザー入力](~/docs/framework/winforms/user-input-in-windows-forms.md)」を参照してください。  
  
 Visual Basic 6.0 とは異なり<xref:System.Windows.Forms.Application.DoEvents%2A> 、メソッドは<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>メソッドを呼び出しません。  
  
 通常、このメソッドをループで使用してメッセージを処理します。  
  
> [!CAUTION]
>  このメソッドを呼び出すと、待機中のすべてのウィンドウメッセージが処理されている間、現在のスレッドが中断されます。 メッセージによってイベントがトリガーされる場合は、アプリケーションコードの他の領域が実行される可能性があります。 これにより、アプリケーションで予期しない動作が発生し、デバッグが困難になる可能性があります。 長い時間がかかる操作や計算を実行する場合は、新しいスレッドでこれらの操作を実行することをお勧めします。 非同期プログラミングの詳細については、「[非同期プログラミングモデル (APM)](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例は、メソッド<xref:System.Windows.Forms.Application.DoEvents%2A>の使用方法を示しています。 この例を実行すると、ユーザーはから<xref:System.Windows.Forms.OpenFileDialog>グラフィックスファイルを選択できます。 選択したファイルがフォームに表示されます。 メソッド<xref:System.Windows.Forms.Application.DoEvents%2A>は、開かれた各グラフィックスファイルのフォームを強制的に再描画します。 この例を実行するには、という名前の、名前<xref:System.Windows.Forms.PictureBox>付き`PictureBox1`の、 <xref:System.Windows.Forms.OpenFileDialog>および`OpenFileDialog1`という`fileButton`名前のボタンを含むフォームに次のコードを貼り付けます。 フォームのコンストラクター `InitializeOpenFileDialog`または`Load`メソッドからおよびメソッドを呼び出します。`InitializePictureBox`  
  
> [!NOTE]
>  Visual Studio でドラッグ操作を使用し<xref:System.Windows.Forms.OpenFileDialog>てをフォームに追加する場合は、の<xref:System.Windows.Forms.OpenFileDialog>新しいインスタンスを作成する行`InitializeOpenFileDialog`を削除することによって、次のメソッドを変更する必要があります。  
  
 また、この例では<xref:System.Windows.Forms.Control.Click?displayProperty=nameWithType> 、 <xref:System.Windows.Forms.Button>コントロールのイベント<xref:System.Windows.Forms.OpenFileDialog>と<xref:System.Windows.Forms.FileDialog.FileOk>のイベントが、この例で定義されているイベントハンドラーに接続されている必要があります。 この例が実行されている場合は、ボタンをクリックしてダイアログボックスを表示します。  
  
 [!code-cpp[System.Windows.Forms.FileDialog#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CPP/filedialogform.cpp#1)]
 [!code-csharp[System.Windows.Forms.FileDialog#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CS/filedialogform.cs#1)]
 [!code-vb[System.Windows.Forms.FileDialog#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/VB/filedialogform.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
      </Docs>
    </Member>
    <Member MemberName="EnableVisualStyles">
      <MemberSignature Language="C#" Value="public static void EnableVisualStyles ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnableVisualStyles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.EnableVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnableVisualStyles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnableVisualStyles();" />
      <MemberSignature Language="F#" Value="static member EnableVisualStyles : unit -&gt; unit" Usage="System.Windows.Forms.Application.EnableVisualStyles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アプリケーションで visual スタイルを有効にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アプリケーションの視覚スタイルを有効にします。 視覚スタイルとは、オペレーティングシステムのテーマを形成する色、フォント、およびその他のビジュアル要素です。 コントロールとオペレーティングシステムでサポートされている場合は、visual スタイルを使用してコントロールが描画されます。 効果を与えるには<xref:System.Windows.Forms.Application.EnableVisualStyles> 、アプリケーションでコントロールを作成する前にを呼び出す必要<xref:System.Windows.Forms.Application.EnableVisualStyles>があります。通常、 `Main`は関数の最初の行です。 を呼び出す<xref:System.Windows.Forms.Application.EnableVisualStyles>ときに、visual スタイルを有効にするために個別のマニフェストは必要ありません。  
  
> [!NOTE]
>  .NET Framework 2.0 `FlatStyle`より前では、コントロールを visual スタイルで描画するために、から<xref:System.Windows.Forms.ButtonBase>派生するコントロールなど、一部<xref:System.Windows.Forms.FlatStyle.System?displayProperty=nameWithType>のコントロールのプロパティをに設定する必要がありました。 .NET Framework 2.0 で記述されたアプリケーションでは、これは不要になりました。  
  
> [!NOTE]
>  このメソッドは、Internet Explorer でホストされているコントロールには影響しません。  
  
   
  
## Examples  
 次のコード例は、 <xref:System.Windows.Forms.Application.EnableVisualStyles%2A> `Main`関数でを呼び出して、アプリケーションの視覚スタイルを有効にする方法を示しています。  
  
 [!code-cpp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
        <altmember cref="P:System.Windows.Forms.Application.VisualStyleState" />
        <altmember cref="T:System.Windows.Forms.FlatStyle" />
      </Docs>
    </Member>
    <Member MemberName="EnterThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler EnterThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EnterThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.EnterThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event EnterThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ EnterThreadModal;" />
      <MemberSignature Language="F#" Value="member this.EnterThreadModal : EventHandler " Usage="member this.EnterThreadModal : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションがモーダル状態に入ろうとすると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  これは静的イベントなので、アプリケーションが破棄されるときにイベントハンドラーをデタッチする必要があります。これを行わないと、メモリリークが発生します。  
  
   
  
## Examples  
 このメンバーの使用例を次のコード例に示します。 この例では、イベントハンドラーが<xref:System.Windows.Forms.Application.EnterThreadModal>イベントの発生を報告します。 このレポートは、イベントがいつ発生し、デバッグに役立つかを理解するのに役立ちます。 複数のイベントまたは頻繁に発生するイベントについてレポート<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>する<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>には、メッセージをに置き換える<xref:System.Windows.Forms.TextBox>か、または複数行に追加することを検討してください。  
  
 コード例を実行するには、コードを Windows フォームに貼り付け、イベントハンドラーが<xref:System.Windows.Forms.Application.EnterThreadModal>イベントに関連付けられていることを確認します。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#3)]
 [!code-vb[System.Windows.Forms.EventExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">イベント<see cref="P:System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" />をリッスンするためのアクセス許可が必要です。</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecutablePath">
      <MemberSignature Language="C#" Value="public static string ExecutablePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ExecutablePath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ExecutablePath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ExecutablePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ExecutablePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExecutablePath : string" Usage="System.Windows.Forms.Application.ExecutablePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションを開始した実行可能ファイルのパスを、ファイル名を含めて取得します。</summary>
        <value>アプリケーションを開始した実行可能ファイルのパスおよびファイル名。  
  
このパスは、Windows フォーム アプリケーションが [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] を使用して配置されているかどうかによって異なります。 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] アプリケーションは、C:\Documents and Settings\\*username* ディレクトリでユーザーごとのアプリケーション キャッシュに格納されます。 詳細については、[ローカルへのアクセスとリモート データには、ClickOnce アプリケーション](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d) を参照してください。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">パスを取得するために使用します。 関連付けられた列挙型:<see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Exit">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>終了する必要があるすべてのメッセージ ポンプを通知し、メッセージが処理されると、すべてのアプリケーション ウィンドウを閉じます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit();" />
      <MemberSignature Language="F#" Value="static member Exit : unit -&gt; unit" Usage="System.Windows.Forms.Application.Exit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>終了する必要があるすべてのメッセージ ポンプを通知し、メッセージが処理されると、すべてのアプリケーション ウィンドウを閉じます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Windows.Forms.Application.Exit%2A>は、すべてのスレッドで実行中のすべてのメッセージループを停止し、アプリケーションのすべてのウィンドウを閉じます。 このメソッドは、必ずしもアプリケーションを強制的に終了するわけではありません。 通常<xref:System.Windows.Forms.Application.Exit%2A> 、メソッドはメッセージループ内から呼び出され、はを<xref:System.Windows.Forms.Application.Run%2A>強制的に返します。 現在のスレッドに対してのみメッセージループを終了する<xref:System.Windows.Forms.Application.ExitThread%2A>には、を呼び出します。  
  
 <xref:System.Windows.Forms.Application.Exit%2A>次のイベントを発生させ、関連する条件付きアクションを実行します。  
  
-   イベントは、 <xref:System.Windows.Forms.Application.OpenForms%2A>プロパティによって表されるすべてのフォームに対して発生します。 <xref:System.Windows.Forms.Form.FormClosing> このイベントは、 <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> <xref:System.Windows.Forms.FormClosingEventArgs>パラメーターのプロパティをに設定する`true`ことによって取り消すことができます。  
  
-   1つ以上のハンドラーがイベントをキャンセルした場合<xref:System.Windows.Forms.Application.Exit%2A>は、それ以上のアクションを行わずにを返します。 それ以外の<xref:System.Windows.Forms.Form.FormClosed>場合は、開いているすべてのフォームに対してイベントが発生し、実行中のすべてのメッセージループとフォームが閉じられます。  
  
> [!NOTE]
>  メソッド<xref:System.Windows.Forms.Application.Exit%2A>は、 <xref:System.Windows.Forms.Form.Closed>およびイベントを発生<xref:System.Windows.Forms.Form.Closing>させません[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]。これは、以降では廃止されています。  
  
   
  
## Examples  
 次のコード例では、フォームのリストボックス内の数値を一覧表示します。 をクリック`button1`するたびに、アプリケーションによってリストに別の番号が追加されます。  
  
 メソッド`Main`は、 <xref:System.Windows.Forms.Application.Run%2A>アプリケーションを起動するためにを呼び出します。 `listBox1`これに`button1`より、、、およびというフォームが作成されます。 ユーザーがをクリック`button1`すると`button1_Click` 、メソッドによってリスト<xref:System.Windows.Forms.MessageBox>ボックスに 1 ~ 3 個の数字が追加され、が表示されます。 ユーザーがで<xref:System.Windows.Forms.MessageBox>**[いいえ]** をクリックし`button1_Click`た場合、メソッドはリストに別の番号を追加します。 ユーザーが **[はい]** をクリックすると<xref:System.Windows.Forms.Application.Exit%2A>、アプリケーションはを呼び出して、キュー内の残りのすべてのメッセージを処理し、終了します。  
  
 この例では`listBox1` 、 `button1`とがインスタンス化され、フォームに配置されている必要があります。  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">直前の呼び出し元がアンマネージコードを呼び出す場合は。 関連付けられた列挙型:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
        <altmember cref="P:System.Windows.Forms.Application.OpenForms" />
        <altmember cref="E:System.Windows.Forms.Form.Closed" />
        <altmember cref="E:System.Windows.Forms.Form.Closing" />
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member Exit : System.ComponentModel.CancelEventArgs -&gt; unit" Usage="System.Windows.Forms.Application.Exit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">アプリケーション内の <see cref="T:System.Windows.Forms.Form" /> が終了をキャンセルしたかどうかを示す値を返します。</param>
        <summary>終了する必要があるすべてのメッセージ ポンプを通知し、メッセージが処理されると、すべてのアプリケーション ウィンドウを閉じます。</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityException">実行中のアプリケーションスレッドを終了するアクセス許可。 関連付けられた列挙型:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="ExitThread">
      <MemberSignature Language="C#" Value="public static void ExitThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExitThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.ExitThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ExitThread ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ExitThread();" />
      <MemberSignature Language="F#" Value="static member ExitThread : unit -&gt; unit" Usage="System.Windows.Forms.Application.ExitThread " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のスレッドのメッセージ ループを終了し、スレッドのウィンドウをすべて閉じます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在のスレッドのメッセージループを終了するには、このメソッドを使用します。 このメソッドにより、現在<xref:System.Windows.Forms.Application.Run%2A>のスレッドのの呼び出しが返されます。 アプリケーション全体を終了するには<xref:System.Windows.Forms.Application.Exit%2A>、を呼び出します。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">直前の呼び出し元がアンマネージコードを呼び出す場合は。 関連付けられた列挙型:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="FilterMessage">
      <MemberSignature Language="C#" Value="public static bool FilterMessage (ref System.Windows.Forms.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool FilterMessage(valuetype System.Windows.Forms.Message&amp; message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.FilterMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FilterMessage (ByRef message As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool FilterMessage(System::Windows::Forms::Message % message);" />
      <MemberSignature Language="F#" Value="static member FilterMessage :  -&gt; bool" Usage="System.Windows.Forms.Application.FilterMessage message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Windows.Forms.Message" RefType="ref" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="message">フィルター処理の対象となる Windows イベント メッセージ。</param>
        <summary>ウィンドウ メッセージに対してフィルターを実行し、変更したメッセージのコピーを返します。</summary>
        <returns>フィルターが処理された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HighDpiMode">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.HighDpiMode HighDpiMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.HighDpiMode HighDpiMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.HighDpiMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property HighDpiMode As HighDpiMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::HighDpiMode HighDpiMode { System::Windows::Forms::HighDpiMode get(); };" />
      <MemberSignature Language="F#" Value="member this.HighDpiMode : System.Windows.Forms.HighDpiMode" Usage="System.Windows.Forms.Application.HighDpiMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HighDpiMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Idle">
      <MemberSignature Language="C#" Value="public static event EventHandler Idle;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Idle" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.Idle" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event Idle As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ Idle;" />
      <MemberSignature Language="F#" Value="member this.Idle : EventHandler " Usage="member this.Idle : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションが処理を完了し、アイドル状態に入ろうとすると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スレッドがアイドル状態になる前に実行する必要のあるタスクがある場合は、このイベントにアタッチします。  
  
> [!CAUTION]
>  これは静的イベントなので、アプリケーションが破棄されるときにイベントハンドラーをデタッチする必要があります。これを行わないと、メモリリークが発生します。  
  
   
  
## Examples  
 このメンバーの使用例を次のコード例に示します。 この例では、イベントハンドラーが<xref:System.Windows.Forms.Application.Idle>イベントの発生を報告します。 このレポートは、イベントがいつ発生し、デバッグに役立つかを理解するのに役立ちます。 複数のイベントまたは頻繁に発生するイベントについてレポート<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>する<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>には、メッセージをに置き換える<xref:System.Windows.Forms.TextBox>か、または複数行に追加することを検討してください。  
  
 コード例を実行するには、それを Windows フォームに貼り付け、イベントハンドラーが<xref:System.Windows.Forms.Application.Idle>イベントに関連付けられていることを確認します。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#2)]
 [!code-vb[System.Windows.Forms.EventExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LeaveThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler LeaveThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LeaveThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.LeaveThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event LeaveThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ LeaveThreadModal;" />
      <MemberSignature Language="F#" Value="member this.LeaveThreadModal : EventHandler " Usage="member this.LeaveThreadModal : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションがモーダル状態を終了するときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  これは静的イベントなので、アプリケーションが破棄されるときにイベントハンドラーをデタッチする必要があります。これを行わないと、メモリリークが発生します。  
  
   
  
## Examples  
 このメンバーの使用例を次のコード例に示します。 この例では、イベントハンドラーが<xref:System.Windows.Forms.Application.LeaveThreadModal>イベントの発生を報告します。 このレポートは、イベントがいつ発生し、デバッグに役立つかを理解するのに役立ちます。 複数のイベントまたは頻繁に発生するイベントについてレポート<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>する<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>には、メッセージをに置き換える<xref:System.Windows.Forms.TextBox>か、または複数行に追加することを検討してください。  
  
 コード例を実行するには、コードを Windows フォームに貼り付け、イベントハンドラーが<xref:System.Windows.Forms.Application.LeaveThreadModal>イベントに関連付けられていることを確認します。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#4)]
 [!code-vb[System.Windows.Forms.EventExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalUserAppDataPath">
      <MemberSignature Language="C#" Value="public static string LocalUserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string LocalUserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.LocalUserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LocalUserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ LocalUserAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalUserAppDataPath : string" Usage="System.Windows.Forms.Application.LocalUserAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ローカルで非ローミング ユーザーのアプリケーション データのパスを取得します。</summary>
        <value>ローカルで非ローミング ユーザーのアプリケーション データのパス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ローカルユーザーとは、ユーザーがログオンしたシステムにユーザープロファイルが格納されているユーザーのことです。 パスが存在しない場合は、次の形式で作成されます。  
  
 *基本パス*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 一般的な基本パスは、c:\documents and および\\Settings*username*\Local Settings\Application Data です。 ただし、Windows フォームアプリケーションがを使用[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]して展開されている場合、このパスは異なります。 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]は、他のすべてのアプリケーションから分離された独自のアプリケーションデータディレクトリを作成します。 詳細については、[ローカルへのアクセスとリモート データには、ClickOnce アプリケーション](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d) を参照してください。  
  
   
  
## Examples  
 次のコード例では、2つのフォームを表示し、両方のフォームが閉じられたときにアプリケーションを終了します。 アプリケーションの開始時と終了時には、各フォームの位置が記憶されます。 この例では、 <xref:System.Windows.Forms.Application.UserAppDataPath%2A>プロパティを使用してユーザーのアプリケーションデータを格納する方法を示していますが、 <xref:System.Windows.Forms.Application.LocalUserAppDataPath%2A>を代わりに使用することもできます。  
  
 クラス`MyApplicationContext`は、から<xref:System.Windows.Forms.ApplicationContext>継承され、各フォームが閉じられたときに追跡を続け、両方ともの場合に現在のスレッドを終了します。 クラスは、ユーザーの各フォームの位置を格納します。 フォーム位置データは、によって`Appdata.txt` <xref:System.Windows.Forms.Application.UserAppDataPath%2A>決定された場所に作成されるという名前のファイルに格納されます。 メソッド`Main`は、 `Application.Run(context)` を指定してアプリケーションを起動するために<xref:System.Windows.Forms.ApplicationContext>を呼び出します。  
  
 このコードは、 <xref:System.Windows.Forms.ApplicationContext>クラスの概要に示されている例から抜粋したものです。 簡潔にするために、一部のコードは表示されません。 コード<xref:System.Windows.Forms.ApplicationContext>全体の一覧については、「」を参照してください。  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MessageLoop">
      <MemberSignature Language="C#" Value="public static bool MessageLoop { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MessageLoop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.MessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MessageLoop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MessageLoop { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.MessageLoop : bool" Usage="System.Windows.Forms.Application.MessageLoop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このスレッドにメッセージ ループが存在するかどうかを示す値を取得します。</summary>
        <value>メッセージ ループが存在する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 管理されていないアプリケーションなど、他の環境で Windows フォームをホストする`false`場合、このプロパティは常にを返します。 を<xref:System.Windows.Forms.Application.RegisterMessageLoop%2A>使用すると、ホスト環境にアクティブなメッセージループがまだある場合に Windows フォームに指示できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OleRequired">
      <MemberSignature Language="C#" Value="public static System.Threading.ApartmentState OleRequired ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.ApartmentState OleRequired() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OleRequired" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OleRequired () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::ApartmentState OleRequired();" />
      <MemberSignature Language="F#" Value="static member OleRequired : unit -&gt; System.Threading.ApartmentState" Usage="System.Windows.Forms.Application.OleRequired " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のスレッドで OLE を初期化します。</summary>
        <returns><see cref="T:System.Threading.ApartmentState" /> 値のいずれか 1 つ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 OLE を必要とするメソッド`Microsoft.Win32`を呼び出す前に、このメソッドを呼び出します。 <xref:System.Windows.Forms.Application.OleRequired%2A>は、最初に、OLE が現在のスレッドで初期化されているかどうかを確認します。 そうでない場合は、OLE のスレッドを初期化します。  
  
> [!NOTE]
>  スレッドが OLE メソッドを直接呼び出す場合を除き、このメソッドを呼び出す必要はありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnThreadException">
      <MemberSignature Language="C#" Value="public static void OnThreadException (Exception t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void OnThreadException(class System.Exception t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OnThreadException(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub OnThreadException (t As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void OnThreadException(Exception ^ t);" />
      <MemberSignature Language="F#" Value="static member OnThreadException : Exception -&gt; unit" Usage="System.Windows.Forms.Application.OnThreadException t" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="t">スローされた例外を表す <see cref="T:System.Exception" />。</param>
        <summary><see cref="E:System.Windows.Forms.Application.ThreadException" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 を<xref:System.Windows.Forms.Application.OnThreadException%2A>呼び出して、アプリケーションの処理を停止する例外を発生させます。  
  
 クラスには<xref:System.Windows.Forms.Application.ThreadException>イベントがあります。 <xref:System.Windows.Forms.Application> このイベントにイベントハンドラーをアタッチして、未処理の例外に必要なカスタム処理を行うことができます。 イベントハンドラーをアタッチしない場合、 <xref:System.Windows.Forms.Application.OnThreadException%2A>は既定の動作を実行します。これには、エラーが発生したことをユーザーに通知するダイアログボックスが表示されます。  
  
 <xref:System.Windows.Forms.Application.OnThreadException%2A>Windows フォームによって所有されているスレッドで発生する未処理の例外に対してのみ、既定の例外動作を実装します。 他のスレッドでのハンドルされない<xref:System.AppDomain.UnhandledException>例外は、イベントによって処理されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenForms">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.FormCollection OpenForms { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.FormCollection OpenForms" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.OpenForms" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OpenForms As FormCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::FormCollection ^ OpenForms { System::Windows::Forms::FormCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OpenForms : System.Windows.Forms.FormCollection" Usage="System.Windows.Forms.Application.OpenForms" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションが所有している、開かれたフォームのコレクションを取得します。</summary>
        <value>アプリケーションによって所有されている、現在開いているすべてのフォームが格納された <see cref="T:System.Windows.Forms.FormCollection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティ<xref:System.Windows.Forms.Application.OpenForms%2A>は、アプリケーションが所有するフォームの読み取り専用コレクションを表します。 このコレクションは、 <xref:System.Windows.Forms.Control.Name%2A> <xref:System.Windows.Forms.Form>インデックス位置またはので検索できます。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">呼び出し元は、 <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /> <see cref="T:System.Security.Permissions.UIPermissionWindow" />列挙体の値で定義されているように、すべてのウィンドウにアクセスするためのアクセス許可を持っている必要があります。</permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="T:System.Windows.Forms.FormCollection" />
      </Docs>
    </Member>
    <Member MemberName="ProductName">
      <MemberSignature Language="C#" Value="public static string ProductName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductName : string" Usage="System.Windows.Forms.Application.ProductName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このアプリケーションに関連付けられている製品名を取得します。</summary>
        <value>製品名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ProductName`は、現在のアプリケーションのメインフォームを含むアセンブリのメタデータから取得されます。 これは、アセンブリマニフェスト内<xref:System.Reflection.AssemblyProductAttribute>でを設定することによって設定できます。 詳細については、「[アセンブリ マニフェスト](~/docs/framework/app-domains/assembly-manifest.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、このプロパティを取得し、テキストボックスにその値を表示します。 この例では`textBox1` 、がフォームに配置されている必要があります。  
  
 [!code-cpp[Classic Application.ProductName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyProductAttribute" />
      </Docs>
    </Member>
    <Member MemberName="ProductVersion">
      <MemberSignature Language="C#" Value="public static string ProductVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductVersion" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductVersion" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductVersion : string" Usage="System.Windows.Forms.Application.ProductVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このアプリケーションに関連付けられている製品のバージョンを取得します。</summary>
        <value>製品のバージョン。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常、バージョン番号は*メジャー番号*として表示されます。*マイナー番号*。*ビルド番号*。*プライベートパート番号*。 アセンブリのバージョンをアセンブリマニフェスト内で設定することによって、明示的に設定できます。 詳細については、「[アセンブリ マニフェスト](~/docs/framework/app-domains/assembly-manifest.md)」を参照してください。  
  
 最初にメインの実行可能ファイルを含むアセンブリに `AssemblyInformationalVersion` 属性が含まれているかどうかを調べます。 この属性が存在する場合は、<xref:System.Windows.Forms.Application.ProductVersion%2A>と<xref:System.Windows.Forms.Application.CommonAppDataPath%2A>の両方で <xref:System.Windows.Forms.Application.ProductVersion%2A>が使用されます。 この属性が存在しない場合、両方のプロパティで、実行可能ファイルのバージョンが代わりに使用されます。  
  
   
  
## Examples  
 次のコード例では、このプロパティを取得し、テキストボックスにその値を表示します。 この例では`textBox1` 、がフォームに配置されている必要があります。  
  
 [!code-cpp[Classic Application.ProductVersion Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductVersion Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductVersion Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductVersion Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyVersionAttribute" />
      </Docs>
    </Member>
    <Member MemberName="RaiseIdle">
      <MemberSignature Language="C#" Value="public static void RaiseIdle (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RaiseIdle(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RaiseIdle(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RaiseIdle (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RaiseIdle(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member RaiseIdle : EventArgs -&gt; unit" Usage="System.Windows.Forms.Application.RaiseIdle e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> イベントに渡す <see cref="E:System.Windows.Forms.Application.Idle" /> オブジェクト。</param>
        <summary>ホストされているシナリオで <see cref="E:System.Windows.Forms.Application.Idle" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージアプリケーションなどの別の環境で Windows フォームをホストするときに使用されます。 ホスティングアプリケーションが<xref:System.Windows.Forms.Application.RaiseIdle%2A>アイドル状態になると、を呼び出す必要があります。 これにより、ユーザーがアプリケーションと対話していないときに、一部の Windows フォームコントロールとコンポーネントが重要なバックグラウンド作業を実行できるようになります。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Application.Idle" />
      </Docs>
    </Member>
    <Member MemberName="RegisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void RegisterMessageLoop (System.Windows.Forms.Application.MessageLoopCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterMessageLoop(class System.Windows.Forms.Application/MessageLoopCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterMessageLoop (callback As Application.MessageLoopCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterMessageLoop(System::Windows::Forms::Application::MessageLoopCallback ^ callback);" />
      <MemberSignature Language="F#" Value="static member RegisterMessageLoop : System.Windows.Forms.Application.MessageLoopCallback -&gt; unit" Usage="System.Windows.Forms.Application.RegisterMessageLoop callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Windows.Forms.Application+MessageLoopCallback" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">ホスト環境が依然としてメッセージを送信しているかどうかを Windows フォームでチェックする必要がある場合に呼び出すメソッド。</param>
        <summary>メッセージ ループがホストされている環境で実行されているかどうかをチェックするためのコールバックを登録します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージアプリケーションなどの別の環境で Windows フォームをホストするときに使用されます。 ホスト環境では、 <xref:System.Windows.Forms.Application.MessageLoop%2A> Windows フォームがメッセージを処理していない場合、プロパティは常に false を返します。 このコールバックを使用して、ホスト環境がまだメッセージを処理しているかどうかを Windows フォームに伝えます。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Application.MessageLoopCallback" />
      </Docs>
    </Member>
    <Member MemberName="RemoveMessageFilter">
      <MemberSignature Language="C#" Value="public static void RemoveMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RemoveMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberSignature Language="F#" Value="static member RemoveMessageFilter : System.Windows.Forms.IMessageFilter -&gt; unit" Usage="System.Windows.Forms.Application.RemoveMessageFilter value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">アプリケーションから削除する <see cref="T:System.Windows.Forms.IMessageFilter" /> の実装。</param>
        <summary>アプリケーションのメッセージ ポンプからメッセージ フィルターを削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows メッセージをディスパッチする前にキャプチャする必要がなくなった場合は、メッセージフィルターを削除できます。  
  
   
  
## Examples  
 メッセージフィルターを使用するには、 <xref:System.Windows.Forms.IMessageFilter>インターフェイスの実装を提供する必要があります。 次のクラスは、という名前`TestMessageFilter`のメッセージフィルターを作成します。 このフィルターは、マウスの左ボタンに関連するすべてのメッセージをブロックします。  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      </Docs>
    </Member>
    <Member MemberName="RenderWithVisualStyles">
      <MemberSignature Language="C#" Value="public static bool RenderWithVisualStyles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool RenderWithVisualStyles" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property RenderWithVisualStyles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool RenderWithVisualStyles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RenderWithVisualStyles : bool" Usage="System.Windows.Forms.Application.RenderWithVisualStyles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のアプリケーションが visual スタイルを使用してコントロールを描画しているかどうかを示す値を取得します。</summary>
        <value>アプリケーション ウィンドウのクライアント領域のコントロールで visual スタイルが有効な場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 カスタムコントロールを描画する場合は、このプロパティを使用して、コントロールの外観がアプリケーション内の他のコントロールと一致するように、visual スタイルを使用するかどうかを決定します。  
  
 次の表は、がを返す<xref:System.Windows.Forms.Application.RenderWithVisualStyles%2A> `true`ために必要な4つの条件を示しています。  
  
|条件|説明|  
|---------------|-----------------|  
|オペレーティングシステムは、視覚スタイルをサポートしています|この条件を個別に確認するには、 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsSupportedByOS%2A> クラスの <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> プロパティを使用します。|  
|ユーザーがオペレーティングシステムで視覚スタイルを有効にしている|この条件を個別に確認するには、 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsEnabledByUser%2A> クラスの <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> プロパティを使用します。|  
|アプリケーションで Visual スタイルが有効になっている|アプリケーションで視覚スタイルを有効にするには、 <xref:System.Windows.Forms.Application.EnableVisualStyles> メソッドを呼び出すか、ComCtl32.dll バージョン 6 以降をコントロールの描画に使用することを指定するアプリケーション マニフェストを使用します。|  
|アプリケーションウィンドウのクライアント領域を描画するために Visual スタイルが使用されています|この条件を個別に確認するには、 <xref:System.Windows.Forms.Application.VisualStyleState%2A> クラスの <xref:System.Windows.Forms.Application> プロパティを使用し、その値が <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAreaEnabled?displayProperty=nameWithType> または <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAndNonClientAreasEnabled?displayProperty=nameWithType>になっていることを確認します。|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Restart">
      <MemberSignature Language="C#" Value="public static void Restart ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Restart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Restart" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Restart ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Restart();" />
      <MemberSignature Language="F#" Value="static member Restart : unit -&gt; unit" Usage="System.Windows.Forms.Application.Restart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アプリケーションをシャット ダウンし、直後に新しいインストールを開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 を呼び出す`Restart`最も一般的な理由は、メソッド`Update`または`UpdateAsync`メソッド[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]を使用してダウンロードしたアプリケーションの新しいバージョンを起動することです。  
  
 アプリケーションは、最初に実行されたコンテキストで再起動されます。 アプリケーションのメインの実行可能ファイルを直接指す URL を使用してアプリケーションが起動された場合は、同じ URL を使用して再起動されます。 アプリケーションが[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]アプリケーションである場合は、を使用し[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]てアプリケーションが再起動されます。  
  
 アプリケーションが最初に実行されたときにコマンドラインオプションを指定<xref:System.Windows.Forms.Application.Restart%2A>した場合、は同じオプションを使用してアプリケーションを再び起動します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Windows フォーム アプリケーションのコードではありません。 このコンテキストではこのメソッドを呼び出すことはできません。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">権限<see cref="M:System.Security.Permissions.SecurityPermission.IsUnrestricted" />が必要です。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在のスレッドで標準のアプリケーション メッセージ ループの実行を開始します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run();" />
      <MemberSignature Language="F#" Value="static member Run : unit -&gt; unit" Usage="System.Windows.Forms.Application.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のスレッドで標準のアプリケーション メッセージ ループの実行を、フォームなしで開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Win32 ベースまたは Windows フォームアプリケーションでは、メッセージループは、マウスのクリックやキーボードのストロークなどのユーザーイベントを処理するコード内のルーチンです。 Windows ベースのすべてのアプリケーションを実行するには、メインメッセージループと呼ばれるアクティブなメッセージループが必要です。 メインメッセージループが終了すると、アプリケーションは終了します。 Windows フォームでは、このループは、 <xref:System.Windows.Forms.Application.Exit%2A>メソッドが呼び出されたとき、または<xref:System.Windows.Forms.Application.ExitThread%2A>メインメッセージループを実行しているスレッドでメソッドが呼び出されたときに閉じられます。  
  
 ほとんどの Windows フォーム開発者は、このバージョンのメソッドを使用する必要はありません。 メインフォームが閉じ<xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.Form%29>られたときにアプリケーションが終了するように、メインフォームでアプリケーションを起動するには、オーバーロードを使用する必要があります。 それ以外の場合は、 <xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.ApplicationContext%29>オーバーロードを使用します。これにより、アプリケーションの有効期間をより適切に制御するための<xref:System.Windows.Forms.ApplicationContext>オブジェクトの提供がサポートされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メイン メッセージ ループが既にこのスレッドで実行中です。</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.ApplicationContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.ApplicationContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.ApplicationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (context As ApplicationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::ApplicationContext ^ context);" />
      <MemberSignature Language="F#" Value="static member Run : System.Windows.Forms.ApplicationContext -&gt; unit" Usage="System.Windows.Forms.Application.Run context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Windows.Forms.ApplicationContext" />
      </Parameters>
      <Docs>
        <param name="context">アプリケーションが実行される <see cref="T:System.Windows.Forms.ApplicationContext" />。</param>
        <summary><see cref="T:System.Windows.Forms.ApplicationContext" /> を使用して、現在のスレッドで標準のアプリケーション メッセージ ループの実行を開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メッセージループは、また<xref:System.Windows.Forms.Application.Exit%2A> <xref:System.Windows.Forms.Application.ExitThread%2A>はが呼び出さ<xref:System.Windows.Forms.Application.ThreadExit>れるか、コンテキストオブジェクトでイベントが発生するまで実行されます。  
  
   
  
## Examples  
 この例では、2つのフォームを表示し、両方のフォームが閉じられたときにアプリケーションを終了します。 アプリケーションの開始時と終了時には、各フォームの位置が記憶されます。 この例では、 <xref:System.Windows.Forms.ApplicationContext>を`Application.Run(context)`メソッドと共に使用して、アプリケーションの起動時に複数のフォームを表示する方法を示します。  
  
 クラス`MyApplicationContext`は、から<xref:System.Windows.Forms.ApplicationContext>継承され、各フォームが閉じられたときに追跡を続け、両方ともの場合に現在のスレッドを終了します。 クラスは、ユーザーの各フォームの位置を格納します。 フォーム位置データは、によって`Appdata.txt` <xref:System.Windows.Forms.Application.UserAppDataPath%2A>決定された場所に作成されるという名前のファイルに格納されます。 メソッド`Main`は、 `Application.Run(context)` を指定してアプリケーションを起動するために<xref:System.Windows.Forms.ApplicationContext>を呼び出します。  
  
 簡潔にするため`AppForm1`に`AppForm2` 、フォームとフォームのコードは示されていません。 コードリスト全体については、クラスの概要を参照してください。<xref:System.Windows.Forms.ApplicationContext>  
  
 [!code-cpp[Application#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#2)]
 [!code-csharp[Application#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#2)]
 [!code-vb[Application#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メイン メッセージ ループが既にこのスレッドで実行中です。</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.Form mainForm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.Form mainForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.Form)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (mainForm As Form)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::Form ^ mainForm);" />
      <MemberSignature Language="F#" Value="static member Run : System.Windows.Forms.Form -&gt; unit" Usage="System.Windows.Forms.Application.Run mainForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mainForm" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="mainForm">表示するフォームを表す <see cref="T:System.Windows.Forms.Form" />。</param>
        <summary>現在のスレッドで標準のアプリケーション メッセージ ループの実行を開始し、指定したフォームを表示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常、アプリケーションの main 関数は、このメソッドを呼び出し、アプリケーションのメインウィンドウに渡します。  
  
 このメソッドは、イベント`mainForm` <xref:System.Windows.Forms.Form.Closed>のパラメーターにイベントハンドラーを追加します。 イベントハンドラーは、 <xref:System.Windows.Forms.Application.ExitThread%2A>アプリケーションをクリーンアップするためにを呼び出します。  
  
> [!NOTE]
>  クラスのメソッドは、このメソッドが返される前に呼び出されます。 <xref:System.Windows.Forms.Control.Dispose%2A> <xref:System.Windows.Forms.Form>  
  
   
  
## Examples  
 次のコード例では、フォームのリストボックス内の数値を一覧表示します。 をクリック`button1`するたびに、アプリケーションによってリストに別の番号が追加されます。  
  
 メソッド`Main`は、 <xref:System.Windows.Forms.Application.Run%2A>アプリケーションを起動するためにを呼び出します。 `listBox1`これに`button1`より、、、およびというフォームが作成されます。 ユーザーがをクリック`button1`すると`button1_Click` 、メソッドによってリスト<xref:System.Windows.Forms.MessageBox>ボックスに 1 ~ 3 個の数字が追加され、が表示されます。 ユーザーがで<xref:System.Windows.Forms.MessageBox>**[いいえ]** をクリックし`button1_Click`た場合、メソッドはリストに別の番号を追加します。 ユーザーが **[はい]** をクリックすると<xref:System.Windows.Forms.Application.Exit%2A> 、アプリケーションはを呼び出してキュー内の残りのすべてのメッセージを処理し、終了します。  
  
 この例では`listBox1` 、 `button1`とが作成され、フォームに配置されている必要があります。  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メイン メッセージ ループが既に現在のスレッドで実行中です。</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="SafeTopLevelCaptionFormat">
      <MemberSignature Language="C#" Value="public static string SafeTopLevelCaptionFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string SafeTopLevelCaptionFormat" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.SafeTopLevelCaptionFormat" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property SafeTopLevelCaptionFormat As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ SafeTopLevelCaptionFormat { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeTopLevelCaptionFormat : string with get, set" Usage="System.Windows.Forms.Application.SafeTopLevelCaptionFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>警告見出しと共に表示された場合にトップレベル ウィンドウのキャプションに適用する書式指定文字列を取得または設定します。</summary>
        <value>トップレベル ウィンドウのキャプションに適用する書式指定文字列。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">すべてのウィンドウでこのプロパティを設定します。 関連付けられた列挙型:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetCompatibleTextRenderingDefault">
      <MemberSignature Language="C#" Value="public static void SetCompatibleTextRenderingDefault (bool defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCompatibleTextRenderingDefault(bool defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCompatibleTextRenderingDefault (defaultValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCompatibleTextRenderingDefault(bool defaultValue);" />
      <MemberSignature Language="F#" Value="static member SetCompatibleTextRenderingDefault : bool -&gt; unit" Usage="System.Windows.Forms.Application.SetCompatibleTextRenderingDefault defaultValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="defaultValue">新しいコントロールに適用する既定値。 <see langword="true" /> の場合、<c>UseCompatibleTextRendering</c> をサポートする新しいコントロールは、テキスト レンダリングに [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] ベースの <see cref="T:System.Drawing.Graphics" /> クラスを使用します。<see langword="false" /> の場合、新しいコントロールは [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] ベースの <see cref="T:System.Windows.Forms.TextRenderer" /> クラスを使用します。</param>
        <summary>特定のコントロールで定義された <c>UseCompatibleTextRendering</c> プロパティにアプリケーション全体で有効な既定値を設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 特定の Windows フォーム<xref:System.Windows.Forms.TextRenderer>コントロールでは、 [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] <xref:System.Drawing.Graphics>グラフィックスライブラリに基づくクラスか、 [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]グラフィックスライブラリに基づくクラスを使用して、テキストを表示できます。 この変更は、での[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]パフォーマンスとローカリゼーションの[!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]問題により、で行われました。 を<xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A>サポートするコントロールの`UseCompatibleTextRendering`プロパティの既定値を設定するには、を使用します。  
  
 プロパティは、 <xref:System.Windows.Forms.TextRenderer>クラスを[!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)]使用してテキストを表示する Windows フォームコントロールと[!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)] 、を使用してカスタムテキストレンダリングを実行するアプリケーションの間で、視覚的な互換性を提供するためのものです。 `UseCompatibleTextRendering` <xref:System.Drawing.Graphics>クラス。 ほとんどの場合、 [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)]アプリケーションがまたは[!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)]からアップグレードされていない場合は、を既定`UseCompatibleTextRendering`値の`false`に設定したままにしておくことをお勧めします。  
  
 ベース[!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]のクラスは、パフォーマンスを向上させるために、テキストの外観を改善し、国際対応フォントのサポートを強化するためにで導入されました。 <xref:System.Windows.Forms.TextRenderer> 以前の[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]バージョンのでは、 [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]ベース<xref:System.Drawing.Graphics>のクラスを使用してすべてのテキスト表示を実行していました。 [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)]とは異なり、文字間隔と単語[!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]の折り返しを計算します。 クラスを使用し<xref:System.Drawing.Graphics>てテキストを表示する Windows フォームアプリケーションでは、を使用<xref:System.Windows.Forms.TextRenderer>するコントロールのテキストが、アプリケーション内の他のテキストとは異なるものとして表示されることがあります。 この非互換性を解決するには、 `UseCompatibleTextRendering`プロパティを`true`に設定します。 アプリケーションで`UseCompatibleTextRendering`サポート`true`されているすべてのコントロールに対して<xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A>をに設定するに`true`は、のパラメーターを指定してメソッドを呼び出します。  
  
 Windows フォームコードが Internet Explorer などの別のアプリケーションでホストされている場合は、このメソッドを呼び出さないでください。 スタンドアロンの Windows フォームアプリケーションでのみ、このメソッドを呼び出します。  
  
   
  
## Examples  
  
> [!IMPORTANT]
>  以降のの`UseCompatibleTextRendering` [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]既定値を設定するには、 <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering%2A?displayProperty=nameWithType>「」を参照してください。  
  
 以降[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]では、Program.cs ファイルに<xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A>の呼び出しが自動的に生成されます。 テキスト表示の既定値を変更するには、生成されたコードを変更します。  
  
```scr  
static class Program  
{  
    /// <summary>  
    /// The main entry point for the application.  
    /// </summary>  
    [STAThread]  
    static void Main()  
    {  
        Application.EnableVisualStyles();  
        Application.SetCompatibleTextRenderingDefault(false);  
        Application.Run(new Form1());  
    }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">このメソッドは、Windows フォーム アプリケーションによって最初のウィンドウが作成される前にしか呼び出すことができません。</exception>
        <altmember cref="P:System.Windows.Forms.ButtonBase.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.CheckedListBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.GroupBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.Label.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.LinkLabel.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.PropertyGrid.UseCompatibleTextRendering" />
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering" />
        <altmember cref="M:System.Drawing.Text.PrivateFontCollection.AddMemoryFont(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SetHighDpiMode">
      <MemberSignature Language="C#" Value="public static bool SetHighDpiMode (System.Windows.Forms.HighDpiMode highDpiMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetHighDpiMode(valuetype System.Windows.Forms.HighDpiMode highDpiMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetHighDpiMode(System.Windows.Forms.HighDpiMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetHighDpiMode(System::Windows::Forms::HighDpiMode highDpiMode);" />
      <MemberSignature Language="F#" Value="static member SetHighDpiMode : System.Windows.Forms.HighDpiMode -&gt; bool" Usage="System.Windows.Forms.Application.SetHighDpiMode highDpiMode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="highDpiMode" Type="System.Windows.Forms.HighDpiMode" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="highDpiMode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSuspendState">
      <MemberSignature Language="C#" Value="public static bool SetSuspendState (System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetSuspendState(valuetype System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetSuspendState(System.Windows.Forms.PowerState,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetSuspendState (state As PowerState, force As Boolean, disableWakeEvent As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetSuspendState(System::Windows::Forms::PowerState state, bool force, bool disableWakeEvent);" />
      <MemberSignature Language="F#" Value="static member SetSuspendState : System.Windows.Forms.PowerState * bool * bool -&gt; bool" Usage="System.Windows.Forms.Application.SetSuspendState (state, force, disableWakeEvent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Windows.Forms.PowerState" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="force" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="disableWakeEvent" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="state">移行後の電源の動作モードを示す <see cref="T:System.Windows.Forms.PowerState" />。</param>
        <param name="force">すぐに、強制的に中断モードにする場合は <see langword="true" />。Windows からすべてのアプリケーションに中断の要求が送られるようにする場合は <see langword="false" />。</param>
        <param name="disableWakeEvent">システムの電源ステータスの復元が wake イベントでアクティブにならないようにするには <see langword="true" />。システムの電源ステータスの復元が wake イベントでアクティブになるようにするには <see langword="false" />。</param>
        <summary>システムを中断または休止状態にするか、システムが中断または休止状態になるよう要求します。</summary>
        <returns>システムが中断中の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アプリケーションが20秒以内に中断要求に応答しない場合、Windows は応答しない状態であると判断し、アプリケーションをスリープ状態または終了時に配置できます。 ただし、アプリケーションが中断要求に応答すると、リソースをクリーンアップし、アクティブなプロセスをシャットダウンするために必要な時間がかかることがあります。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.PowerState" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetUnhandledExceptionMode">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>未処理の例外への対応方法をアプリケーションに指示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例では、Windows フォームのスレッドで発生する例外と、他のスレッドで発生する例外のイベントハンドラーを設定します。 アプリケーションの<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>ユーザー構成ファイルの設定に関係なく、すべての例外がアプリケーションによって処理されるようにを設定します。 この例で<xref:System.Windows.Forms.Application.ThreadException>は、イベントを使用して ui スレッド<xref:System.AppDomain.UnhandledException>例外を処理し、イベントを使用して ui 以外のスレッド例外を処理します。 は<xref:System.AppDomain.UnhandledException> 、アプリケーションが終了するのを防ぐことができないため、この例では、終了する前にアプリケーションイベントログにエラーを記録するだけです。  
  
 この例で<xref:System.Windows.Forms.Button>は、 <xref:System.Windows.Forms.Form>クラスで`button1`とと`button2`いう2つのコントロールが定義されていることを前提としています。  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode);" />
      <MemberSignature Language="F#" Value="static member SetUnhandledExceptionMode : System.Windows.Forms.UnhandledExceptionMode -&gt; unit" Usage="System.Windows.Forms.Application.SetUnhandledExceptionMode mode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="mode">キャッチされない例外がスローされた場合に必要なアプリケーションの動作方法を説明する <see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> 値。</param>
        <summary>未処理の例外への対応方法をアプリケーションに指示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 多くの場合、Windows フォームによってスローされたすべての例外をキャッチすることはできません。 このメソッドを使用して、Windows フォームコンポーネントによってスローされた未処理の例外をすべてキャッチし、操作を続行するかどうか、またはユーザーに公開して実行を中止するかどうかをアプリケーションに指示できます。  
  
 メソッドを使用して、アプリケーションのメインフォームをインスタンス化する前に、を呼び出し<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>ます。 <xref:System.Windows.Forms.Application.Run%2A>  
  
 Windows フォームによって作成および所有されていないスレッドで発生し<xref:System.AppDomain.UnhandledException>た例外をキャッチするには、イベントハンドラーを使用します。  
  
   
  
## Examples  
 次のコード例では、Windows フォームのスレッドで発生する例外と、他のスレッドで発生する例外のイベントハンドラーを設定します。 アプリケーションの<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>ユーザー構成ファイルの設定に関係なく、すべての例外がアプリケーションによって処理されるようにを設定します。 この例で<xref:System.Windows.Forms.Application.ThreadException>は、イベントを使用して ui スレッド<xref:System.AppDomain.UnhandledException>例外を処理し、イベントを使用して ui 以外のスレッド例外を処理します。 は<xref:System.AppDomain.UnhandledException> 、アプリケーションが終了するのを防ぐことができないため、この例では、終了する前にアプリケーションイベントログにエラーを記録するだけです。  
  
 この例で<xref:System.Windows.Forms.Button>は、 <xref:System.Windows.Forms.Form>クラスで`button1`とと`button2`いう2つのコントロールが定義されていることを前提としています。  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">アプリケーションが最初のウィンドウを作成した後に、例外モードを設定することはできません。</exception>
        <altmember cref="T:System.Windows.Forms.UnhandledExceptionMode" />
      </Docs>
    </Member>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode, threadScope As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode, bool threadScope);" />
      <MemberSignature Language="F#" Value="static member SetUnhandledExceptionMode : System.Windows.Forms.UnhandledExceptionMode * bool -&gt; unit" Usage="System.Windows.Forms.Application.SetUnhandledExceptionMode (mode, threadScope)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="threadScope" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="mode">キャッチされない例外がスローされた場合に必要なアプリケーションの動作方法を説明する <see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> 値。</param>
        <param name="threadScope">スレッド例外モードを設定する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>未処理の例外に応答する方法をアプリケーションに指示し、オプションでスレッド固有の動作を適用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 多くの場合、Windows フォームによってスローされたすべての例外をキャッチすることはできません。 このメソッドを使用して、Windows フォームコンポーネントによってスローされた未処理の例外をすべてキャッチし、操作を続行するかどうか、またはユーザーに公開して実行を中止するかどうかをアプリケーションに指示できます。  
  
 メソッドを使用して、アプリケーションのメインフォームをインスタンス化する前に、を呼び出し<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>ます。 <xref:System.Windows.Forms.Application.Run%2A>  
  
 `threadScope` が`true`の場合、スレッド例外モードが設定されます。 がに`mode` <xref:System.Windows.Forms.UnhandledExceptionMode.Automatic>設定されていない場合、スレッド例外モードはアプリケーション例外モードをオーバーライドします。  
  
 `threadScope` が`false`の場合、アプリケーションの例外モードが設定されます。 アプリケーション例外モードは、 <xref:System.Windows.Forms.UnhandledExceptionMode.Automatic>モードを持つすべてのスレッドで使用されます。 アプリケーション例外モードを設定しても、現在のスレッドの設定には影響しません。  
  
 Windows フォームによって作成および所有されていないスレッドで発生し<xref:System.AppDomain.UnhandledException>た例外をキャッチするには、イベントハンドラーを使用します。  
  
   
  
## Examples  
 次のコード例では、Windows フォームのスレッドで発生する例外と、他のスレッドで発生する例外のイベントハンドラーを設定します。 アプリケーションの<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>ユーザー構成ファイルの設定に関係なく、すべての例外がアプリケーションによって処理されるようにを設定します。 この例で<xref:System.Windows.Forms.Application.ThreadException>は、イベントを使用して ui スレッド<xref:System.AppDomain.UnhandledException>例外を処理し、イベントを使用して ui 以外のスレッド例外を処理します。 は<xref:System.AppDomain.UnhandledException> 、アプリケーションが終了するのを防ぐことができないため、この例では、終了する前にアプリケーションイベントログにエラーを記録するだけです。  
  
 この例で<xref:System.Windows.Forms.Button>は、 <xref:System.Windows.Forms.Form>クラスで`button1`とと`button2`いう2つのコントロールが定義されていることを前提としています。  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">アプリケーションが最初のウィンドウを作成した後に、例外モードを設定することはできません。</exception>
      </Docs>
    </Member>
    <Member MemberName="StartupPath">
      <MemberSignature Language="C#" Value="public static string StartupPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string StartupPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.StartupPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property StartupPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ StartupPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StartupPath : string" Usage="System.Windows.Forms.Application.StartupPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションを開始した実行可能ファイルの、ファイル名を含まないパスを取得します。</summary>
        <value>アプリケーションを開始した実行可能ファイルのパス。  
  
このパスは、Windows フォーム アプリケーションが [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] を使用して配置されているかどうかによって異なります。 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] アプリケーションは、C:\Documents and Settings\\*username* ディレクトリでユーザーごとのアプリケーション キャッシュに格納されます。 詳細については、[ローカルへのアクセスとリモート データには、ClickOnce アプリケーション](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d) を参照してください。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例では、このプロパティを取得し、テキストボックスにその値を表示します。 この例では`textBox1` 、がフォームに配置されている必要があります。  
  
 [!code-cpp[Classic Application.StartupPath Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.StartupPath Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CS/source.cs#1)]
 [!code-vb[Classic Application.StartupPath Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.StartupPath Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">パスを取得するために使用します。 関連付けられた列挙型:<see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadException">
      <MemberSignature Language="C#" Value="public static event System.Threading.ThreadExceptionEventHandler ThreadException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Threading.ThreadExceptionEventHandler ThreadException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadException As ThreadExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event System::Threading::ThreadExceptionEventHandler ^ ThreadException;" />
      <MemberSignature Language="F#" Value="member this.ThreadException : System.Threading.ThreadExceptionEventHandler " Usage="member this.ThreadException : System.Threading.ThreadExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>トラップされないスレッドの例外がスローされると、発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントを使用すると、Windows フォームアプリケーションは、Windows フォームスレッドで発生する未処理の例外を処理できます。 イベントハンドラーを<xref:System.Windows.Forms.Application.ThreadException>イベントにアタッチして、これらの例外を処理します。これにより、アプリケーションは不明な状態のままになります。 可能であれば、構造化例外処理ブロックで例外を処理する必要があります。  
  
 を設定<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>することによって、このコールバックが未処理の Windows フォームスレッド例外に使用されるかどうかを変更できます。 Windows フォームによって作成および所有されていないスレッドで発生し<xref:System.AppDomain.UnhandledException>た例外をキャッチするには、イベントハンドラーを使用します。  
  
> [!NOTE]
>  このイベントのアクティブ化が欠落していないことを保証するには、を<xref:System.Windows.Application.Run%2A?displayProperty=nameWithType>呼び出す前にハンドラーをアタッチする必要があります。  
  
> [!CAUTION]
>  これは静的イベントなので、アプリケーションが破棄されるときにイベントハンドラーをデタッチする必要があります。これを行わないと、メモリリークが発生します。  
  
   
  
## Examples  
 次のコード例では、Windows フォームのスレッドで発生する例外と、他のスレッドで発生する例外のイベントハンドラーを設定します。 アプリケーションの<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>ユーザー構成ファイルの設定に関係なく、すべての例外がアプリケーションによって処理されるようにを設定します。 この例で<xref:System.Windows.Forms.Application.ThreadException>は、イベントを使用して ui スレッド<xref:System.AppDomain.UnhandledException>例外を処理し、イベントを使用して ui 以外のスレッド例外を処理します。 は<xref:System.AppDomain.UnhandledException> 、アプリケーションが終了するのを防ぐことができないため、この例では、終了する前にアプリケーションイベントログにエラーを記録するだけです。  
  
 この例で<xref:System.Windows.Forms.Button>は、 <xref:System.Windows.Forms.Form>クラスで`button1`とと`button2`いう2つのコントロールが定義されていることを前提としています。  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">このイベントにハンドラーを追加するときに、直前の呼び出し元がアンマネージコードを呼び出す場合は。 関連付けられた列挙型:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ThreadExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ThreadExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ThreadExit;" />
      <MemberSignature Language="F#" Value="member this.ThreadExit : EventHandler " Usage="member this.ThreadExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スレッドをシャットダウンしようとすると発生します。 アプリケーションのメイン スレッドをシャットダウンしようとするとこのイベントが発生し、続いて <see cref="E:System.Windows.Forms.Application.ApplicationExit" /> イベントが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントハンドラーを<xref:System.Windows.Forms.Application.ThreadExit>イベントにアタッチして、スレッドが実行を停止する前に未処理の必須タスクを実行する必要があります。 このスレッドによって開かれたファイルを閉じるか、ガベージコレクターによって再利用されなかったオブジェクトを破棄します。  
  
> [!CAUTION]
>  これは静的イベントなので、アプリケーションが破棄されるときにイベントハンドラーをデタッチする必要があります。これを行わないと、メモリリークが発生します。  
  
   
  
## Examples  
 このメンバーの使用例を次のコード例に示します。 この例では、イベントハンドラーが<xref:System.Windows.Forms.Application.ThreadExit>イベントの発生を報告します。 このレポートは、イベントがいつ発生し、デバッグに役立つかを理解するのに役立ちます。 複数のイベントまたは頻繁に発生するイベントについてレポート<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>する<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>には、メッセージをに置き換える<xref:System.Windows.Forms.TextBox>か、または複数行に追加することを検討してください。  
  
 コード例を実行するには、コードを Windows フォームに貼り付け、イベントハンドラーが<xref:System.Windows.Forms.Application.ThreadExit>イベントに関連付けられていることを確認します。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#6)]
 [!code-vb[System.Windows.Forms.EventExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
      </Docs>
    </Member>
    <Member MemberName="UnregisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void UnregisterMessageLoop ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void UnregisterMessageLoop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.UnregisterMessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub UnregisterMessageLoop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void UnregisterMessageLoop();" />
      <MemberSignature Language="F#" Value="static member UnregisterMessageLoop : unit -&gt; unit" Usage="System.Windows.Forms.Application.UnregisterMessageLoop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" /> によって行われたメッセージ ループ コールバックを登録解除します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UserAppDataPath">
      <MemberSignature Language="C#" Value="public static string UserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAppDataPath : string" Usage="System.Windows.Forms.Application.UserAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーのアプリケーション データのパスを取得します。</summary>
        <value>ユーザーのアプリケーション データのパス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 パスが存在しない場合は、次の形式で作成されます。  
  
 *基本パス*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>  
  
 このパスに格納されるデータは、ローミングが有効になっているユーザープロファイルの一部です。 ローミングユーザーは、ネットワーク内の複数のコンピューターで動作します。 ローミングユーザーのユーザープロファイルはネットワーク上のサーバーに保存され、ユーザーがログオンするとシステムに読み込まれます。 ユーザープロファイルがローミング対象と見なされるようにするには、オペレーティングシステムがローミングプロファイルをサポートしている必要があり、有効になっている必要があります。  
  
 一般的な基本パスは、c:\documents and および\\Settings*username*\Application Data です。 ただし、Windows フォームアプリケーションがを使用[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]して展開されている場合、このパスは異なります。 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]は、他のすべてのアプリケーションから分離された独自のアプリケーションデータディレクトリを作成します。 詳細については、[ローカルへのアクセスとリモート データには、ClickOnce アプリケーション](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d) を参照してください。  
  
   
  
## Examples  
 次のコード例では、2つのフォームを表示し、両方のフォームが閉じられたときにアプリケーションを終了します。 アプリケーションの開始時と終了時には、各フォームの位置が記憶されます。 この例では、 <xref:System.Windows.Forms.Application.UserAppDataPath%2A>プロパティを使用して、ユーザーのアプリケーションデータを格納する方法を示します。  
  
 クラス`MyApplicationContext`は、から<xref:System.Windows.Forms.ApplicationContext>継承され、各フォームが閉じられたときに追跡を続け、両方ともの場合に現在のスレッドを終了します。 クラスは、ユーザーの各フォームの位置を格納します。 フォーム位置データは、によって`Appdata.txt` <xref:System.Windows.Forms.Application.UserAppDataPath%2A>決定された場所に作成されるという名前のファイルに格納されます。 メソッド`Main`は、 `Application.Run(context)` を指定してアプリケーションを起動するために<xref:System.Windows.Forms.ApplicationContext>を呼び出します。  
  
 このコードは、 <xref:System.Windows.Forms.ApplicationContext>クラスの概要に示されている例から抜粋したものです。 簡潔にするために、一部のコードは表示されません。 コード<xref:System.Windows.Forms.ApplicationContext>全体の一覧については、「」を参照してください。  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="UserAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey UserAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey UserAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ UserAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAppDataRegistry : Microsoft.Win32.RegistryKey" Usage="System.Windows.Forms.Application.UserAppDataRegistry" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーのアプリケーション データのレジストリ キーを取得します。</summary>
        <value>ユーザー固有のアプリケーション データのレジストリ キーを表す <see cref="T:Microsoft.Win32.RegistryKey" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キーが存在しない場合は、次の形式で作成されます。  
  
 CurrentUser\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 このキーに格納されているデータは、ローミングが有効になっているユーザープロファイルの一部です。 ローミングユーザーは、ネットワーク内の複数のコンピューターで動作します。 ローミングユーザーのユーザープロファイルはネットワーク上のサーバーに保存され、ユーザーがログオンするとシステムに読み込まれます。 ユーザープロファイルがローミング対象と見なされるようにするには、オペレーティングシステムがローミングプロファイルをサポートしている必要があり、有効になっている必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.SystemInformation" />
      </Docs>
    </Member>
    <Member MemberName="UseVisualStyles">
      <MemberSignature Language="C#" Value="public static bool UseVisualStyles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseVisualStyles" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UseVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UseVisualStyles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UseVisualStyles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.UseVisualStyles : bool" Usage="System.Windows.Forms.Application.UseVisualStyles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseWaitCursor">
      <MemberSignature Language="C#" Value="public static bool UseWaitCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseWaitCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UseWaitCursor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property UseWaitCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UseWaitCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseWaitCursor : bool with get, set" Usage="System.Windows.Forms.Application.UseWaitCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションの開いているフォームすべてに待機カーソルを使用するかどうかについて、取得または設定します。</summary>
        <value>すべての開いているフォームで待機カーソルが使用される場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティをに`true`設定すると、アプリケーションで開いて<xref:System.Windows.Forms.Control.UseWaitCursor%2A>いるすべてのフォームのプロパティがに`true`設定されます。 この呼び出しは、このプロパティがすべてのフォームに設定されるまでは戻りません。 このプロパティは、実行時間の長い操作があり、その操作がまだ処理中であることをすべてのアプリケーションフォームで示す場合に使用します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualStyleState">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.VisualStyleState" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property VisualStyleState As VisualStyleState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::VisualStyles::VisualStyleState VisualStyleState { System::Windows::Forms::VisualStyles::VisualStyleState get(); void set(System::Windows::Forms::VisualStyles::VisualStyleState value); };" />
      <MemberSignature Language="F#" Value="member this.VisualStyleState : System.Windows.Forms.VisualStyles.VisualStyleState with get, set" Usage="System.Windows.Forms.Application.VisualStyleState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.VisualStyles.VisualStyleState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーション ウィンドウに visual スタイルをどのように適用するかを指定する値を取得します。</summary>
        <value><see cref="T:System.Windows.Forms.VisualStyles.VisualStyleState" /> 値のビットごとの組み合わせ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この<xref:System.Windows.Forms.Application.VisualStyleState%2A>プロパティは、アプリケーションウィンドウのクライアント領域または非クライアント領域で visual スタイルを有効にするかどうかを決定します。 通常、このプロパティは、メインフォームのコンストラクターまたは<xref:System.Windows.Forms.Form.Load>イベントハンドラー内で設定する必要があります。  
  
   
  
## Examples  
 次のコード例では<xref:System.Windows.Forms.Application.VisualStyleState%2A> 、プロパティを、 <xref:System.Windows.Forms.Button>コントロール<xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType>の<xref:System.Windows.Forms.Control.Click>イベントハンドラー内のいずれかの値に設定します。 このコード例は、 <xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType>列挙型に対して提供されるより大きな例の一部です。  
  
 [!code-cpp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/cpp/visualstylestate.cpp#10)]
 [!code-csharp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/CS/visualstylestate.cs#10)]
 [!code-vb[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/VB/visualstylestate.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>