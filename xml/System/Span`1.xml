<Type Name="Span&lt;T&gt;" FullName="System.Span&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="803bd441bc38213f4fa96e5e062b6bb6e5453f5c" /><Meta Name="ms.sourcegitcommit" Value="61757d0366a172cdbc11436deb1c1ffa49d97238" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="06/28/2019" /><Meta Name="ms.locfileid" Value="67458077" /></Metadata><TypeSignature Language="C#" Value="public struct Span&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Span`1&lt;T&gt; extends System.ValueType" />
  <TypeSignature Language="DocId" Value="T:System.Span`1" />
  <TypeSignature Language="VB.NET" Value="Public Structure Span(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public value class Span" />
  <TypeSignature Language="F#" Value="type Span&lt;'T&gt; = struct" />
  <AssemblyInfo>
    <AssemblyName>System.Memory</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.2;netcore-2.1;netcore-3.0;netstandard-2.1">
      <AttributeName>System.Runtime.CompilerServices.IsByRefLike</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.2;netcore-2.1;netcore-3.0;netstandard-2.1">
      <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T"><see cref="System.Span`1" />内の項目の型。</typeparam>
    <summary>任意のメモリの隣接した領域をタイプセーフかつメモリセーフで表します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  

`Span<T>`はマネージド ヒープではなく、スタックに割り当てられる[ref 構造体](~/docs/csharp/language-reference/keywords/ref.md#ref-struct-types)です。 ref 構造体は、ボックス化できない、<xref:System.Object>、`dynamic`または任意のインターフェイス型の変数に割り当てられない、参照型のフィールドにできない、`await`や`yield`をまたいで使用できないなど、マネージド ヒープに昇格しないようにするためのいくつかの制限があります。 さらに、<xref:System.Span%601.Equals(System.Object)>と<xref:System.Span%601.GetHashCode%2A>の2つのメソッドを呼び出すと、<xref:System.NotSupportedException>をスローします。 

> [!IMPORTANT]
> `Span<T>`はスタック専用の型であるため、ヒープ上でバッファーへの参照を格納する必要のある、多くのシナリオには適していません。 たとえば、非同期メソッドの呼び出しを行うルーチンなどが当てはまります。 このようなシナリオでは、補完的な<xref:System.Memory%601?displayProperty=nameWithType>と<xref:System.ReadOnlyMemory%601?displayProperty=nameWithType>型を使用できます。

不変、または読み取り専用の構造を表すスパンの場合、<xref:System.ReadOnlySpan%601?displayProperty=nameWithType>を使用してください。

## <a name="spant-and-memory"></a>Span\<T> とメモリ

`Span<T>`は任意のメモリの連続した領域を表します。 `Span<T>`インスタンスは、配列の要素または配列の一部を保持するためによく使用されます。 ただし、配列とは異なり、`Span<T>`インスタンスは、マネージド メモリ、ネイティブ メモリ、スタック上で管理されたメモリを指すことができます。 次の例では、配列から`Span<Byte>`を作成します。

[!code-csharp[Creating a Span\<Byte> from an array](~/samples/snippets/csharp/api/system/span/program.cs#1)]
     
次の例では、ネイティブ メモリの 100 バイトから`Span<Byte>`を作成します。

[!code-csharp[Creating a Span\<Byte> from native memory](~/samples/snippets/csharp/api/system/span/program.cs#2)]

次の例では、 C#の[stackalloc](~/docs/csharp/language-reference/keywords/stackalloc.md)キーワードを用いて、スタック上に 100 バイトのメモリを割り当てます。

[!code-csharp[Creating a Span\<Byte> from stack-allocated memory](~/samples/snippets/csharp/api/system/span/program.cs#3)]

`Span<T>`は、メモリ上の任意のブロックを抽象化したものであるため、`Span<T>`クラスのメソッドと`Span<T>`をパラメーターに持つメソッドは、カプセル化するメモリの種類に関係なく、任意の`Span<T>`オブジェクトで動作します。 たとえば、スパンを初期化して、その要素を合計するコードの各セクションは、次の例のように単一の初期化メソッドと計算メソッドに変更できます。

[!code-csharp[Creating a Span\<Byte> from stack-allocated memory](~/samples/snippets/csharp/api/system/span/program.cs#4)]

## <a name="spant-and-arrays"></a>Span\<T> と配列

[Span\<T> とメモリ](#spant-and-memory)セクションの例のように、配列をラップした場合、`Span<T>`は配列全体をラップすることができます。 スライスをサポートするため、`Span<T>`は配列内の連続する範囲を指すこともできます。  

次の例では、10 要素ある整数配列の中間 5 つの要素のスライスを作成します。 コードがスライス内の各整数の値を 2 倍することに注意してください。 出力のとおり、スパンで加えられた変更は、配列の値に反映されます。

[!code-csharp[Creating a slice from a portion of a span](~/samples/snippets/csharp/api/system/span/slice/program.cs)]

## <a name="spant-and-slices"></a>Span\<T> とスライス

`Span<T>`には、現在のスパンより、指定したインデックスから始まるスライスを形成する<xref:System.Span%601.Slice%2A>メソッドの 2 つのオーバー ロードが含まれています。 これにより、`Span<T>`のデータを、パフォーマンスの影響を最小限にしながら、データ処理パイプラインの一部で必要に応じて処理できる、一連の論理的なまとまりとして扱うことができます。 たとえば、最新のサーバー プロトコルは多くの場合、テキスト ベースであるため、文字列と部分文字列の操作は特に重要です。 <xref:System.String>クラスの場合、部分文字列の抽出に使う主要なメソッドは<xref:System.String.Substring%2A>です。 広範な文字列操作に依存するデータ パイプラインは、次のように、いくつかのパフォーマンスの低下を招きます。

1. 部分文字列を保持するために新しい文字列を作成します。

2. 元の文字列から文字のサブセットを新しい文字列にコピーします。

次の例に示すように、この割り当てとコピー操作は、`Span<T>`または<xref:System.ReadOnlySpan%601>いずれかを使用して削除できます。

[!code-csharp[Creating a slice from a substring](~/samples/snippets/csharp/api/system/span/slice2/program.cs)]


      ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Span (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.#ctor(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="new Span&lt;'T&gt; : 'T[] -&gt; Span&lt;'T&gt;" Usage="new System.Span&lt;'T&gt; array" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array"><see cref="T:System.Span`1" /> オブジェクトの作成元になる配列。</param>
        <summary>指定された配列全体で新しい <see cref="T:System.Span`1" /> オブジェクトを作成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

`array`が`null`の場合、このコンストラクターは`null` `Span<T>`を返します。

      ]]></format>
        </remarks>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="T" /> は参照型です。<paramref name="array" /> は型 <paramref name="T" /> の配列ではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Span (void* pointer, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(void* pointer, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.#ctor(System.Void*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span(void* pointer, int length);" />
      <MemberSignature Language="F#" Value="new Span&lt;'T&gt; : nativeptr&lt;unit&gt; * int -&gt; Span&lt;'T&gt;" Usage="new System.Span&lt;'T&gt; (pointer, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.2;netcore-2.1;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pointer" Type="System.Void*" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pointer">メモリ内で指定された数の <typeparamref name="T" /> 要素の開始アドレスを指すポインター。</param>
        <param name="length"><see cref="T:System.Span`1" /> 内に格納される <typeparamref name="T" /> 要素の数。</param>
        <summary>指定されたメモリ アドレスで始まり、指定された数の <typeparamref name="T" /> 要素を持つ、新しい <see cref="T:System.Span`1" /> オブジェクトを作成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

        このコンストラクターは、`void*`型のメモリ ブロックから、任意の`T`型の要素を作成し、長さはチェックされないため、注意して使用する必要があります。ただし、コンストラクターが新しい<xref:System.Span%601>オブジェクトの作成に成功した場合、後続のすべての使用は正しいです。

      ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="T" /> は参照型であるか、ポインターを含むため、アンマネージ メモリに格納できません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length" /> が負の値です。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Span (T[] array, int start, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T[] array, int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.#ctor(`0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (array As T(), start As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span(cli::array &lt;T&gt; ^ array, int start, int length);" />
      <MemberSignature Language="F#" Value="new Span&lt;'T&gt; : 'T[] * int * int -&gt; Span&lt;'T&gt;" Usage="new System.Span&lt;'T&gt; (array, start, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">ソースの配列。</param>
        <param name="start">新しい <see cref="T:System.Span`1" /> に含める最初の要素のインデックス。</param>
        <param name="length">新しい <see cref="T:System.Span`1" /> に含める要素の数。</param>
        <summary>指定インデックスで始まる配列の指定要素数を含む新しい <see cref="T:System.Span`1" /> オブジェクトを作成します。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="array" /> は <see langword="null" /> ですが、<paramref name="start" /> または <paramref name="length" /> は 0 以外です。

- または -

<paramref name="start" /> は配列の境界の外側にあります。

- または -

<paramref name="start" /> と <paramref name="length" /> は配列の要素数を超えています。</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="T" /> は参照型です。<paramref name="array" /> は型 <paramref name="T" /> の配列ではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="span.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この <see cref="T:System.Span`1" /> オブジェクトの内容を消去します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

`Clear`メソッドは、<xref:System.Span%601>オブジェクト内の項目をデフォルト値に設定します。 <xref:System.Span%601>から項目は削除されません。  

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Span&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(valuetype System.Span`1&lt;!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.CopyTo(System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (destination As Span(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(Span&lt;T&gt; destination);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : Span&lt;'T&gt; -&gt; unit" Usage="span.CopyTo destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="destination">コピー先 <see cref="System.Span`1" /> オブジェクト。</param>
        <summary>この <see cref="System.Span`1" /> の内容をコピー先 <see cref="System.Span`1" /> にコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

このメソッドは、`source`と`destination`が重なる場合でも、`source`のすべてを`destination`にコピーします。

         ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="destination" /> が元の <see cref="System.Span`1" /> より短くなります。</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; Empty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Span`1&lt;!T&gt; Empty" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Empty As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Span&lt;T&gt; Empty { Span&lt;T&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.Empty : Span&lt;'T&gt;" Usage="System.Span&lt;'T&gt;.Empty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>空の <see cref="T:System.Span`1" /> オブジェクトを返します。</summary>
        <value>空の <see cref="T:System.Span`1" /> オブジェクト。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="span.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Equals() on Span will always throw an exception. Use == instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">サポートされていません。</param>
        <summary>このメソッドを呼び出すことはできません。</summary>
        <returns>このメソッドを呼び出すことはできません。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
<xref:System.Span%601.Equals%2A>メソッドの呼び出しはサポートされていません。 <xref:System.Span%601.Equals%2A>メソッド呼び出しは 2 つの結果のいずれかを生成します。

- `obj`が<xref:System.Span%601>の場合、メソッド呼び出しには、コンパイラ エラー CS1503:「'System.Span' から 'object' に変換できません。」 が生成されます。これは、<xref:System.Span%601>が、[ref 構造体](~/docs/csharp/reference-semantics-with-value-types.md#ref-struct-type)であり、ボックス化できず、そのため<xref:System.Object>に変換することはできないからです。

- `obj`の型が<xref:System.Span%601>でない場合、メソッド呼び出しは<xref:System.NotSupportedException>をスローします。 

2 つの<xref:System.Span%601>オブジェクトが等しいかどうかを比較するには、<xref:System.Span%601.op_Equality%2A>比較演算子を使用します。

        ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">このメソッドを呼び出すことはできません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public void Fill (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Fill(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Fill(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Fill (value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Fill(T value);" />
      <MemberSignature Language="F#" Value="member this.Fill : 'T -&gt; unit" Usage="span.Fill value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">スパンの各要素に割り当てる値。</param>
        <summary>このスパンの要素に指定の値を入力します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public Span&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Span`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As Span(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; Span&lt;'T&gt;.Enumerator" Usage="span.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この <see cref="T:System.Span`1" /> の列挙子を返します。</summary>
        <returns>このスパンの列挙子。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
<xref:System.Span%601.GetEnumerator%2A>メソッドを直接呼び出す代わりに、C#の`foreach`ステートメントと Visual Basicの`For Each`...`Next`構造を<xref:System.Span%601>の列挙に使用することができます。

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="span.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("GetHashCode() on Span will always throw an exception.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.NotSupportedException" /> をスローします。</summary>
        <returns>このメソッドを呼び出すと、必ず <see cref="T:System.NotSupportedException" /> がスローされます。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">このメソッドを呼び出すことはできません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPinnableReference">
      <MemberSignature Language="C#" Value="public T GetPinnableReference ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T GetPinnableReference() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.GetPinnableReference" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPinnableReference () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T % GetPinnableReference();" />
      <MemberSignature Language="F#" Value="member this.GetPinnableReference : unit -&gt; " Usage="span.GetPinnableReference " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T@</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>インデックス 0 にある <see cref="T:System.Span`1" /> の要素の参照を返します。</summary>
        <returns>インデックス 0 にある <see cref="T:System.Span`1" /> の要素の参照。<see cref="M:System.Span`1.IsEmpty" /> が <see langword="true" /> の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

`GetPinnableReference`メソッドは[ref 構造体](~/docs/csharp/reference-semantics-with-value-types.md#ref-struct-type)を返します。 <xref:System.Span%601>をメモリにピン留めするために使用できます。 [fixed](~/docs/csharp/language-reference/keywords/fixed-statement.md)ステートメント内で<xref:System.Span%601>の使用をサポートするために必要です。

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEmpty">
      <MemberSignature Language="C#" Value="public bool IsEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.IsEmpty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEmpty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEmpty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEmpty : bool" Usage="System.Span&lt;'T&gt;.IsEmpty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Span`1" /> が空かどうかを示す値を返します。</summary>
        <value>現在の範囲が空の場合に<see langword="true" />を、それ以外の場合に<see langword="false" />を返します。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public T this[Index index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(valuetype System.Index)" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.Item(System.Index)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(index As Index) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T % default[Index] { T % get(Index index); };" />
      <MemberSignature Language="F#" Value="member this.Item(Index) : " Usage="System.Span&lt;'T&gt;.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Index" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public T this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(index As Integer) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T % default[int] { T % get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : " Usage="System.Span&lt;'T&gt;.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">要素の、0 から始まるインデックス。</param>
        <summary>0 から始まる指定したインデックス位置にある要素を取得します。</summary>
        <value>指定したインデックス位置にある要素。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> が 0 未満か、<see cref="P:System.Span`1.Length" /> 以上です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public Span&lt;T&gt; this[Range range] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Span`1&lt;!T&gt; Item(valuetype System.Range)" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.Item(System.Range)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(range As Range) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Span&lt;T&gt; default[Range] { Span&lt;T&gt; get(Range range); };" />
      <MemberSignature Language="F#" Value="member this.Item(Range) : Span&lt;'T&gt;" Usage="System.Span&lt;'T&gt;.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Range" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="range">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.Span&lt;'T&gt;.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のスパンの長さを返します。</summary>
        <value>現在のスパンの長さ。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Span&lt;T&gt; left, Span&lt;T&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Span`1&lt;!T&gt; left, valuetype System.Span`1&lt;!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Equality(System.Span{`0},System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Span(Of T), right As Span(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Span&lt;T&gt; left, Span&lt;T&gt; right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Span&lt;'T&gt; * Span&lt;'T&gt; -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Span&lt;T&gt;" />
        <Parameter Name="right" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="left">比較対象とする最初のスパン。</param>
        <param name="right">比較対象とする 2 つ目のスパン。</param>
        <summary>2 つの <see cref="T:System.Span`1" /> オブジェクトが等しいかどうかを示す値を返します。</summary>
        <returns>2 つの <see cref="T:System.Span`1" /> オブジェクトが等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

同じ長さで、`left`と`right`が同じメモリを指している場合、2 つ<xref:System.Span%601>オブジェクトは等しいです。 等値のテストでは、内容が等しいかどうかを判断しようと*しない*ことに注意してください。

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator Span&lt;T&gt; (ArraySegment&lt;T&gt; arraySegment);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Span`1&lt;!T&gt; op_Implicit(valuetype System.ArraySegment`1&lt;!T&gt; arraySegment) cil managed" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (arraySegment As ArraySegment(Of T)) As Span(Of T)" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator Span&lt;T&gt;(ArraySegment&lt;T&gt; arraySegment);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="C#" Value="public static implicit operator Span&lt;T&gt; (ArraySegment&lt;T&gt; segment);" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Span`1&lt;!T&gt; op_Implicit(valuetype System.ArraySegment`1&lt;!T&gt; segment) cil managed" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Implicit(System.ArraySegment{`0})~System.Span{`0}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (segment As ArraySegment(Of T)) As Span(Of T)" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator Span&lt;T&gt;(ArraySegment&lt;T&gt; segment);" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="static member op_Implicit : ArraySegment&lt;'T&gt; -&gt; Span&lt;'T&gt;" Usage="System.Span&lt;'T&gt;.op_Implicit segment" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="segment"><see cref="T:System.Span`1" /> に変換する配列セグメント。</param>
        <summary><see cref="T:System.ArraySegment`1" /> から <see cref="T:System.Span`1" /> への暗黙の型変換を定義します。</summary>
        <returns>配列セグメントに対応するスパン。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator ReadOnlySpan&lt;T&gt; (Span&lt;T&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.ReadOnlySpan`1&lt;!T&gt; op_Implicit(valuetype System.Span`1&lt;!T&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Implicit(System.Span{`0})~System.ReadOnlySpan{`0}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (span As Span(Of T)) As ReadOnlySpan(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator ReadOnlySpan&lt;T&gt;(Span&lt;T&gt; span);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : Span&lt;'T&gt; -&gt; ReadOnlySpan&lt;'T&gt;" Usage="System.Span&lt;'T&gt;.op_Implicit span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="span"><see cref="T:System.ReadOnlySpan`1" /> に変換するオブジェクト。</param>
        <summary><see cref="T:System.Span`1" /> から <see cref="T:System.ReadOnlySpan`1" /> への暗黙の型変換を定義します。</summary>
        <returns>現在のインスタンスに対応する読み取り専用スパン。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator Span&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Span`1&lt;!T&gt; op_Implicit(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Implicit(`0[])~System.Span{`0}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (array As T()) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator Span&lt;T&gt;(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : 'T[] -&gt; Span&lt;'T&gt;" Usage="System.Span&lt;'T&gt;.op_Implicit array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array"><see cref="T:System.Span`1" /> に変換する配列。</param>
        <summary>配列から <see cref="T:System.Span`1" /> への暗黙の型変換を定義します。</summary>
        <returns><paramref name="array" /> に対応するスパン。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Span&lt;T&gt; left, Span&lt;T&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Span`1&lt;!T&gt; left, valuetype System.Span`1&lt;!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Inequality(System.Span{`0},System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Span(Of T), right As Span(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Span&lt;T&gt; left, Span&lt;T&gt; right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Span&lt;'T&gt; * Span&lt;'T&gt; -&gt; bool" Usage="System.Span&lt;'T&gt;.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Span&lt;T&gt;" />
        <Parameter Name="right" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="left">比較対象とする最初のスパン。</param>
        <param name="right">比較対象とする 2 つ目のスパン。</param>
        <summary>2 つの <see cref="T:System.Span`1" /> オブジェクトが等しくないかどうかを示す値を返します。</summary>
        <returns>2 つの <see cref="T:System.Span`1" /> オブジェクトが等しくない場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  


長さが異なる、あるいは`left`と`right`が同じメモリを指していない場合、2 つの<xref:System.Span%601>オブジェクトは等しくありません。


         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Slice">
      <MemberSignature Language="C#" Value="public Span&lt;T&gt; Slice (Index startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Span`1&lt;!T&gt; Slice(valuetype System.Index startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Slice(System.Index)" />
      <MemberSignature Language="VB.NET" Value="Public Function Slice (startIndex As Index) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span&lt;T&gt; Slice(Index startIndex);" />
      <MemberSignature Language="F#" Value="member this.Slice : Index -&gt; Span&lt;'T&gt;" Usage="span.Slice startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Index" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="startIndex">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Slice">
      <MemberSignature Language="C#" Value="public Span&lt;T&gt; Slice (int start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Span`1&lt;!T&gt; Slice(int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Slice(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Slice (start As Integer) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span&lt;T&gt; Slice(int start);" />
      <MemberSignature Language="F#" Value="member this.Slice : int -&gt; Span&lt;'T&gt;" Usage="span.Slice start" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">スライスの開始位置を示すインデックス。</param>
        <summary>指定のインデックスで始まる現在のスパンからスライスを形成します。</summary>
        <returns><paramref name="start" /> からスパンの終わりまで、現在のスパンの全要素で構成されるスパン。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="start" /> が 0 未満であるか、<see cref="T:System.Span`1.Length" /> を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Slice">
      <MemberSignature Language="C#" Value="public Span&lt;T&gt; Slice (Range range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Span`1&lt;!T&gt; Slice(valuetype System.Range range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Slice(System.Range)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span&lt;T&gt; Slice(Range range);" />
      <MemberSignature Language="F#" Value="member this.Slice : Range -&gt; Span&lt;'T&gt;" Usage="span.Slice range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Range" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="range">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Slice">
      <MemberSignature Language="C#" Value="public Span&lt;T&gt; Slice (int start, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Span`1&lt;!T&gt; Slice(int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Slice(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Slice (start As Integer, length As Integer) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span&lt;T&gt; Slice(int start, int length);" />
      <MemberSignature Language="F#" Value="member this.Slice : int * int -&gt; Span&lt;'T&gt;" Usage="span.Slice (start, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">このスライスの開始位置を示すインデックス。</param>
        <param name="length">スライスに求められる長さ。</param>
        <summary>指定インデックスから始まる現在のスパンからスライスを指定の長さで形成します。</summary>
        <returns><paramref name="start" /> で始まる現在のスパンからの <paramref name="length" /> 要素で構成されるスパン。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="start" /> または <paramref name="start" /> + <paramref name="length" /> が 0 より小さいか、<see cref="T:System.Span`1.Length" /> より大きいです。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="member this.ToArray : unit -&gt; 'T[]" Usage="span.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このスパンの内容を新しい配列にコピーします。</summary>
        <returns>現在のスパンのデータを含む配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

このメソッドは、ヒープ割り当てを実行するため、可能であれば避ける必要があります。 <xref:System.Span%601>オブジェクトを使用する API がなく、配列を使用する API を利用できる場合には必要となります。

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="span.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この <see cref="T:System.Span`1" /> オブジェクトの文字列表現を返します。</summary>
        <returns>この <see cref="T:System.Span`1" /> オブジェクトの文字列表現。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
`Span<Char>`の場合、`ToString`メソッドは<xref:System.Span%601>が指す<xref:System.Char>を含む<xref:System.String>を返します。 それ以外の場合は、型の名前と<xref:System.Span%601>の要素数を含む<xref:System.String>を返します。

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCopyTo">
      <MemberSignature Language="C#" Value="public bool TryCopyTo (Span&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryCopyTo(valuetype System.Span`1&lt;!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.TryCopyTo(System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function TryCopyTo (destination As Span(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryCopyTo(Span&lt;T&gt; destination);" />
      <MemberSignature Language="F#" Value="member this.TryCopyTo : Span&lt;'T&gt; -&gt; bool" Usage="span.TryCopyTo destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="destination">コピー操作の対象。</param>
        <summary>コピー先 <see cref="T:System.Span`1" /> に対して現在の <see cref="T:System.Span`1" /> のコピーを試行し、コピー操作が成功したかどうかを示す値を返します。</summary>
        <returns>コピー操作が成功した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

このメソッドは、`source`と`destination`が重なる場合でも、`source`のすべてを`destination`にコピーします。

`destination`が元の<xref:System.Span%601>よりも短い場合、このメソッドは`false`を返し、`destination`にデータは書き込まれません。

         ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
