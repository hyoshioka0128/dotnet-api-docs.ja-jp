<Type Name="FileSystemWatcher" FullName="System.IO.FileSystemWatcher">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a0e57bcd8632ec302753a2471d27c2e55714b410" /><Meta Name="ms.sourcegitcommit" Value="634678f7ccd2928c6b2cf792a301b079b63639af" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="07/26/2019" /><Meta Name="ms.locfileid" Value="68541130" /></Metadata><TypeSignature Language="C#" Value="public class FileSystemWatcher : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileSystemWatcher extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileSystemWatcher" />
  <TypeSignature Language="VB.NET" Value="Public Class FileSystemWatcher&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystemWatcher : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type FileSystemWatcher = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
      <AttributeName>System.ComponentModel.DefaultEvent("Changed")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.IO.IODescription("")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.IO.IODescription("FileSystemWatcherDesc")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>ファイル システムの変更通知を待機し、ディレクトリまたはディレクトリ内のファイルが変更されたときにイベントを発生させます。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定<xref:System.IO.FileSystemWatcher>されたディレクトリの変更を監視するために使用します。 指定されたディレクトリのファイルおよびサブディレクトリの変更を監視できます。 コンポーネントを作成して、ローカルコンピューター、ネットワークドライブ、またはリモートコンピューター上のファイルを監視することができます。  
  
 すべてのファイルの変更を監視するには<xref:System.IO.FileSystemWatcher.Filter%2A> 、プロパティを空の文字列 ("") に設定するか、ワイルド\*カード ("*.") を使用します。 特定のファイルを監視するには<xref:System.IO.FileSystemWatcher.Filter%2A> 、プロパティをファイル名に設定します。 たとえば、MyDoc ファイルの変更を監視するには、 <xref:System.IO.FileSystemWatcher.Filter%2A>プロパティを "MyDoc" に設定します。 また、特定の種類のファイルの変更を監視することもできます。 たとえば、テキストファイルの変更を監視するには、 <xref:System.IO.FileSystemWatcher.Filter%2A>プロパティを "\*.txt" に設定します。  
  
 ディレクトリまたはファイルで監視できる変更には、いくつかの種類があります。 たとえば、の変更`Attributes` `LastWrite` 、日付`Size`と時刻、またはファイルやディレクトリのを監視することができます。 これを行うには、 <xref:System.IO.FileSystemWatcher.NotifyFilter%2A>プロパティを<xref:System.IO.NotifyFilters>値のいずれかに設定します。 監視できる変更の種類の詳細については、「 <xref:System.IO.NotifyFilters>」を参照してください。  
  
 ファイルまたはディレクトリの名前変更、削除、または作成を監視できます。 たとえば、テキストファイルの名前変更を監視するには、 <xref:System.IO.FileSystemWatcher.Filter%2A>プロパティを "* .txt" に設定し、 <xref:System.IO.FileSystemWatcher.WaitForChanged%2A>パラメーターに指定<xref:System.IO.WatcherChangeTypes.Renamed>されたを使用してメソッドを呼び出します。  
  
 Windows オペレーティングシステムは、 <xref:System.IO.FileSystemWatcher>によって作成されたバッファー内のファイル変更をコンポーネントに通知します。 短時間で多くの変更が加えられた場合、バッファーがオーバーフローする可能性があります。 これにより、コンポーネントはディレクトリの変更を追跡できなくなり、一括通知のみが提供されます。 <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>プロパティを使用してバッファーのサイズを大きくすると、ディスクにスワップできない非ページメモリから取得されるため、コストが高くなります。そのため、ファイル変更イベントを見逃すことがないように、バッファーのサイズを小さくしておく必要があります。 バッファーオーバーフローを回避するには、 <xref:System.IO.FileSystemWatcher.NotifyFilter%2A>プロパティ<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>とプロパティを使用して、不要な変更通知を除外できるようにします。  
  
 の<xref:System.IO.FileSystemWatcher>インスタンスの初期プロパティ値の一覧につい<xref:System.IO.FileSystemWatcher.%23ctor%2A>ては、コンストラクターを参照してください。  
  
 <xref:System.IO.FileSystemWatcher>クラスを使用する場合は、次の点に注意してください。  
  
-   隠しファイルは無視されません。  
  
-   システムによって<xref:System.IO.FileSystemWatcher>は、短い8.3 ファイル名形式を使用してファイルが変更されることがあります。 たとえば、"LongFileName. Longfilename" への変更は、"LongFil ~ として報告される可能性があります。Lon "。  
  
-   このクラスには、リンク確認要求と、すべてのメンバーに適用されるクラス レベルの継承確認要求が含まれています。 直接の呼び出し元か派生クラスのいずれかに完全信頼アクセス許可がない場合、<xref:System.Security.SecurityException> がスローされます。 セキュリティ要求の詳細については、「[リンク確認要求](~/docs/framework/misc/link-demands.md)」を参照してください。  
  
-   ネットワーク経由でディレクトリを監視するため<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>のプロパティに設定できる最大サイズは 64 KB です。  
  
> [!NOTE]
>  Windows <xref:System.IO.FileSystemWatcher> 98 での実行はサポートされていません。  
  
## <a name="copying-and-moving-folders"></a>フォルダーのコピーと移動  
 オペレーティングシステムと<xref:System.IO.FileSystemWatcher>オブジェクトは、フォルダーとそのコンテンツの名前変更アクションとして、切り取りと貼り付けの操作または移動操作を解釈します。 ファイルが含まれているフォルダーを切り取って、監視されて<xref:System.IO.FileSystemWatcher>いるフォルダーに貼り付けると、オブジェクトはフォルダーのみを新規として報告しますが、基本的には名前が変更されるだけなので、その内容は報告しません。  
  
 フォルダーの内容が監視対象フォルダーに移動またはコピーされたことを通知する<xref:System.IO.FileSystemWatcher.OnChanged%2A>に<xref:System.IO.FileSystemWatcher.OnRenamed%2A>は、次の表に示すように、イベントハンドラーメソッドを指定します。  
  
|イベント ハンドラー|処理されたイベント|実行|  
|-------------------|--------------------|--------------|  
|<xref:System.IO.FileSystemWatcher.OnChanged%2A>|<xref:System.IO.FileSystemWatcher.Changed>、<xref:System.IO.FileSystemWatcher.Created>、<xref:System.IO.FileSystemWatcher.Deleted>|ファイル属性、作成されたファイル、および削除されたファイルの変更を報告します。|  
|<xref:System.IO.FileSystemWatcher.OnRenamed%2A>|<xref:System.IO.FileSystemWatcher.Renamed>|名前を変更したファイルとフォルダーの古いパスと新しいパスを一覧表示し、必要に応じて再帰的に展開します。|  
  
## <a name="events-and-buffer-sizes"></a>イベントとバッファーサイズ  
 次に示すように、いくつかの要因によって、発生するファイルシステム変更イベントが影響を受ける場合があることに注意してください。  
  
-   一般的なファイルシステム操作では、複数のイベントが発生する可能性があります。 たとえば、あるディレクトリから別のディレクトリにファイルを移動すると、 <xref:System.IO.FileSystemWatcher.OnChanged%2A>いくつ<xref:System.IO.FileSystemWatcher.OnCreated%2A>かの<xref:System.IO.FileSystemWatcher.OnDeleted%2A>イベントとイベントが発生する可能性があります。 ファイルの移動は、複数の単純な操作で構成される複雑な操作であるため、複数のイベントが発生します。 同様に、一部のアプリケーション (ウイルス対策ソフトウェアなど) によって、によって<xref:System.IO.FileSystemWatcher>検出された追加のファイルシステムイベントが発生する可能性があります。  
  
-   は<xref:System.IO.FileSystemWatcher> 、スイッチまたは削除されていない限り、ディスクを見ることができます。 <xref:System.IO.FileSystemWatcher>では、タイムスタンプとプロパティを変更できないため、cd と dvd のイベントは発生しません。 コンポーネントが正常に機能するためには、リモートコンピューターに必要なプラットフォームのいずれかがインストールされている必要があります。  
  
-   Service Pack <xref:System.IO.FileSystemWatcher> 1 または windows 2000 SP2 以前の windows XP で、複数のオブジェクトが同じ UNC パスを監視している場合、1つのオブジェクトだけがイベントを発生させます。 Windows XP SP1 以降、windows 2000 SP3 以降、または windows Server 2003 を実行している<xref:System.IO.FileSystemWatcher>コンピューターでは、すべてのオブジェクトが適切なイベントを発生させます。  
  
 で<xref:System.IO.FileSystemWatcher>は、バッファーサイズを超えた場合にイベントが発生しない可能性があることに注意してください。 見つからないイベントを回避するには、次のガイドラインに従ってください。  
  
-   <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>プロパティを設定して、バッファーサイズを増やします。  
  
-   長いファイル名によってバッファーがいっぱいになることがあるため、長いファイル名を使用してファイルを監視しないようにしてください。 短い名前を使用してファイルの名前を変更することを検討してください。  
  
-   イベント処理コードをできるだけ短くしてください。  
  
   
  
## Examples  
 次の例では<xref:System.IO.FileSystemWatcher> 、を作成して、実行時に指定されたディレクトリを監視します。 コンポーネントは、ディレクトリ内のテキストファイルの`LastWrite`変更`LastAccess` 、作成、削除、または名前変更を監視するように設定されています。 ファイルが変更、作成、または削除された場合、ファイルへのパスがコンソールに出力されます。 ファイルの名前を変更すると、古いパスと新しいパスがコンソールに出力されます。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission"><see cref="T:System.Diagnostics.ProcessStartInfo" />クラスから派生するために使用します。 要求の値<see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />:、名前付きアクセス許可<see langword="FullTrust" />セット:。</permission>
    <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
    <altmember cref="T:System.IO.NotifyFilters" />
    <altmember cref="T:System.IO.FileSystemEventArgs" />
    <altmember cref="T:System.IO.FileSystemEventHandler" />
    <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
    <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
    <altmember cref="T:System.IO.InternalBufferOverflowException" />
    <altmember cref="T:System.IO.RenamedEventArgs" />
    <altmember cref="T:System.IO.RenamedEventHandler" />
    <altmember cref="T:System.IO.WaitForChangedResult" />
    <altmember cref="T:System.IO.WatcherChangeTypes" />
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Using-a-FileSystemWatcher-4bc97af4">Windows フォームでの FileSystemWatcher コンポーネントの使用</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.IO.FileSystemWatcher" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.IO.FileSystemWatcher" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows NT または Windows 2000 がインストールされていないリモートコンピューターを見ることはできません。 Windows nt 4.0 コンピューターからリモートの Windows NT 4.0 コンピューターを視聴することはできません。  
  
 次の表に、の<xref:System.IO.FileSystemWatcher>インスタンスのプロパティの初期値を示します。  
  
|プロパティ|初期値|  
|--------------|-------------------|  
|<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>|`LastWrite` 、`FileName`、およびのビットごとの or の組み合わせ`DirectoryName`|  
|<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>|`false`|  
|<xref:System.IO.FileSystemWatcher.Filter%2A>|"*.\*"(すべてのファイルをウォッチします)。|  
|<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>|`false`|  
|<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>|8192|  
|<xref:System.IO.FileSystemWatcher.Path%2A>|空の文字列 ("")|  
  
> [!NOTE]
>  <xref:System.IO.FileSystemWatcher.Path%2A>が`true`設定<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>されるまで、指定したディレクトリはコンポーネントによって監視されず、はになります。  
  
   
  
## Examples  
 次の例では<xref:System.IO.FileSystemWatcher> 、実行時に指定されたディレクトリを監視するオブジェクトを作成します。 オブジェクト<xref:System.IO.FileSystemWatcher>は、 `LastWrite`および`LastAccess`の時刻の変更、およびディレクトリ内のテキストファイルの作成、削除、または名前変更を監視します。 ファイルが変更、作成、または削除されると、ファイルへのパスがコンソールに表示されます。 ファイルの名前を変更すると、古いパスと新しいパスがコンソールに表示されます。  
  
 この例では<xref:System.Diagnostics> 、 <xref:System.IO>名前空間と名前空間を使用します。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.IO.FileSystemWatcher : string -&gt; System.IO.FileSystemWatcher" Usage="new System.IO.FileSystemWatcher path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">標準表記または UNC (Universal Naming Convention) 表記での監視するディレクトリ。</param>
        <summary>監視するディレクトリを指定して、<see cref="T:System.IO.FileSystemWatcher" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <xref:System.IO.FileSystemWatcher.Path%2A>が`true`設定<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>されるまで、指定したディレクトリはコンポーネントによって監視されず、はになります。  
  
 このコンポーネントは、パーソナルコンピューター、ネットワークドライブ、またはリモートコンピューター上のファイルをウォッチできます。  
  
 Windows NT または Windows 2000 がインストールされていないリモートコンピューターを見ることはできません。 Windows nt 4.0 コンピューターからリモートの Windows NT 4.0 コンピューターを視聴することはできません。 プロパティ<xref:System.IO.FileSystemWatcher.Filter%2A>は、すべてのファイルを監視するために既定で設定されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> パラメーターが空の文字列 ("") です。  
  
- または - 
<paramref name="path" /> パラメーターで指定されたパスが存在しません。</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" /> が長すぎます。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher (string path, string filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, string filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, filter As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher(System::String ^ path, System::String ^ filter);" />
      <MemberSignature Language="F#" Value="new System.IO.FileSystemWatcher : string * string -&gt; System.IO.FileSystemWatcher" Usage="new System.IO.FileSystemWatcher (path, filter)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">標準表記または UNC (Universal Naming Convention) 表記での監視するディレクトリ。</param>
        <param name="filter">ウォッチするファイルの種類。 たとえば、すべてのテキスト ファイルの変更をウォッチするには、"*.txt" に設定します。</param>
        <summary><see cref="T:System.IO.FileSystemWatcher" /> クラスの新しいインスタンスを、監視するディレクトリとファイルの種類を指定して初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <xref:System.IO.FileSystemWatcher.Path%2A>が`true`設定<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>されるまで、指定したディレクトリはコンポーネントによって監視されず、はになります。  
  
 このコンポーネントは、パーソナルコンピューター、ネットワークドライブ、またはリモートコンピューター上のファイルをウォッチできます。  
  
 Windows NT または Windows 2000 がインストールされていないリモートコンピューターを見ることはできません。 Windows nt 4.0 コンピューターからリモートの Windows NT 4.0 コンピューターを視聴することはできません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> パラメーターが <see langword="null" /> です。  
  
または 
<paramref name="filter" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> パラメーターが空の文字列 ("") です。  
  
または 
<paramref name="path" /> パラメーターで指定されたパスが存在しません。</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" /> が長すぎます。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="fileSystemWatcher.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>フォームまたは別のコンポーネントで使用する <see cref="T:System.IO.FileSystemWatcher" /> の初期化を開始します。 初期化は実行時に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 デザイン[!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]環境では、このメソッドを使用して、フォームまたは別のコンポーネントで使用されるコンポーネントの初期化を開始します。 メソッド<xref:System.IO.FileSystemWatcher.EndInit%2A>は、初期化を終了します。 メソッドとメソッド<xref:System.IO.FileSystemWatcher.EndInit%2A>を使用すると、完全に初期化される前に、コントロールが使用されなくなります。 <xref:System.IO.FileSystemWatcher.BeginInit%2A>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : System.IO.FileSystemEventHandler " Usage="member this.Changed : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory change matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Changed")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した <see cref="P:System.IO.FileSystemWatcher.Path" /> のファイルまたはディレクトリが変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベント<xref:System.IO.FileSystemWatcher.Changed>は、監視されているディレクトリ内のファイルまたはディレクトリのサイズ、システム属性、最終書き込み時刻、最終アクセス時刻、またはセキュリティアクセス許可が変更されたときに発生します。  
  
> [!NOTE]
>  一般的なファイルシステム操作では、複数のイベントが発生する可能性があります。 たとえば、あるディレクトリから別のディレクトリにファイルを移動すると、 <xref:System.IO.FileSystemWatcher.OnChanged%2A>いくつ<xref:System.IO.FileSystemWatcher.OnCreated%2A>かの<xref:System.IO.FileSystemWatcher.OnDeleted%2A>イベントとイベントが発生する可能性があります。 ファイルの移動は、複数の単純な操作で構成される複雑な操作であるため、複数のイベントが発生します。 同様に、一部のアプリケーション (ウイルス対策ソフトウェアなど) によって、によって<xref:System.IO.FileSystemWatcher>検出された追加のファイルシステムイベントが発生する可能性があります。  
  
 この<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>イベントが処理されるときに発生する通知の数を制限するには、を使用します。  
  
> [!NOTE]
>  この<xref:System.IO.FileSystemWatcher.Changed>イベントは、ファイルの名前が変更されたときに予期せず発生しますが、ディレクトリの名前が変更されたときには発生しません。 名前の変更を監視するに<xref:System.IO.FileSystemWatcher.Renamed>は、イベントを使用します。  
  
> [!NOTE]
>  <xref:System.IO.FileSystemWatcher.Changed>他の<xref:System.IO.FileSystemWatcher> イベントに`null`関連してイベントが発生する順序は、プロパティがではない場合に変更される可能性があります。<xref:System.IO.FileSystemWatcher.SynchronizingObject%2A>  
  
   
  
## Examples  
 次の例では<xref:System.IO.FileSystemWatcher.Changed> 、イベントを使用して、監視対象のファイルが変更されるたびにコンソールへのファイルパスを表示します。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Created">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Created;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Created" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Created" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Created As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Created;" />
      <MemberSignature Language="F#" Value="member this.Created : System.IO.FileSystemEventHandler " Usage="member this.Created : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory creation matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Created")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した <see cref="P:System.IO.FileSystemWatcher.Path" /> のファイルまたはディレクトリが作成されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ファイルやディレクトリのコピーや移動など、いくつかの一般的な原因はイベントに直接対応していませんが、これらの発生によってイベントが発生します。 ファイルまたはディレクトリをコピーすると、そのディレクトリが<xref:System.IO.FileSystemWatcher.Created>監視されている場合、ファイルのコピー先のディレクトリでイベントが発生します。 コピー元のディレクトリがの別の<xref:System.IO.FileSystemWatcher>インスタンスによって監視されていた場合、イベントは発生しません。 たとえば、の2つの<xref:System.IO.FileSystemWatcher>インスタンスを作成したとします。 FileSystemWatcher1 は "C:\My Documents" を監視するように設定されており、FileSystemWatcher2 は "C:\ your Documents" を監視するように設定されています。 "マイドキュメント" から "ドキュメント<xref:System.IO.FileSystemWatcher.Created> " にファイルをコピーすると、FileSystemWatcher2 によってイベントが発生しますが、FileSystemWatcher1 に対してイベントは発生しません。 コピーとは異なり、ファイルまたはディレクトリを移動すると、2つのイベントが発生します。 前の例では、ファイルを "My documents" から "your documents" <xref:System.IO.FileSystemWatcher.Created>に移動した場合、FileSystemWatcher2 によってイベントが発生<xref:System.IO.FileSystemWatcher.Deleted>し、FileSystemWatcher1 によってイベントが発生します。  
  
> [!NOTE]
>  一般的なファイルシステム操作では、複数のイベントが発生する可能性があります。 たとえば、あるディレクトリから別のディレクトリにファイルを移動すると、 <xref:System.IO.FileSystemWatcher.OnChanged%2A>いくつ<xref:System.IO.FileSystemWatcher.OnCreated%2A>かの<xref:System.IO.FileSystemWatcher.OnDeleted%2A>イベントとイベントが発生する可能性があります。 ファイルの移動は、複数の単純な操作で構成される複雑な操作であるため、複数のイベントが発生します。 同様に、一部のアプリケーション (ウイルス対策ソフトウェアなど) によって、によって<xref:System.IO.FileSystemWatcher>検出された追加のファイルシステムイベントが発生する可能性があります。  
  
> [!NOTE]
>  <xref:System.IO.FileSystemWatcher.Created>他の<xref:System.IO.FileSystemWatcher> イベントに`null`関連してイベントが発生する順序は、プロパティがではない場合に変更される可能性があります。<xref:System.IO.FileSystemWatcher.SynchronizingObject%2A>  
  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A>イベントは、ファイルが作成されるとすぐに発生します。 監視対象のディレクトリ<xref:System.IO.FileSystemWatcher.OnCreated%2A>にファイルをコピーまたは転送する場合、イベントはすぐに発生し、その後に1つ<xref:System.IO.FileSystemWatcher.OnChanged%2A>以上のイベントが続きます。  
  
   
  
## Examples  
 次の例では<xref:System.IO.FileSystemWatcher.Created> 、イベントを使用して、監視対象のファイルが作成されるたびにコンソールへのファイルパスを表示します。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Deleted">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Deleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Deleted" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Deleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deleted As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Deleted;" />
      <MemberSignature Language="F#" Value="member this.Deleted : System.IO.FileSystemEventHandler " Usage="member this.Deleted : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory deletion matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Deleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した <see cref="P:System.IO.FileSystemWatcher.Path" /> のファイルまたはディレクトリが削除されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ファイルやディレクトリのコピーや移動など、いくつかの一般的な原因はイベントに直接対応していませんが、これらの発生によってイベントが発生します。 ファイルまたはディレクトリをコピーすると、そのディレクトリが<xref:System.IO.FileSystemWatcher.Created>監視されている場合、ファイルのコピー先のディレクトリでイベントが発生します。 コピー元のディレクトリがの別の<xref:System.IO.FileSystemWatcher>インスタンスによって監視されていた場合、イベントは発生しません。 たとえば、の2つの<xref:System.IO.FileSystemWatcher>インスタンスを作成したとします。 FileSystemWatcher1 は "C:\My Documents" を監視するように設定されており、FileSystemWatcher2 は "C:\ your Documents" を監視するように設定されています。 "マイドキュメント" から "ドキュメント<xref:System.IO.FileSystemWatcher.Created> " にファイルをコピーすると、FileSystemWatcher2 によってイベントが発生しますが、FileSystemWatcher1 に対してイベントは発生しません。 コピーとは異なり、ファイルまたはディレクトリを移動すると、2つのイベントが発生します。 前の例では、ファイルを "My documents" から "your documents" <xref:System.IO.FileSystemWatcher.Created>に移動した場合、FileSystemWatcher2 によってイベントが発生<xref:System.IO.FileSystemWatcher.Deleted>し、FileSystemWatcher1 によってイベントが発生します。  
  
> [!NOTE]
>  一般的なファイルシステム操作では、複数のイベントが発生する可能性があります。 たとえば、あるディレクトリから別のディレクトリにファイルを移動すると、 <xref:System.IO.FileSystemWatcher.OnChanged%2A>いくつ<xref:System.IO.FileSystemWatcher.OnCreated%2A>かの<xref:System.IO.FileSystemWatcher.OnDeleted%2A>イベントとイベントが発生する可能性があります。 ファイルの移動は、複数の単純な操作で構成される複雑な操作であるため、複数のイベントが発生します。 同様に、一部のアプリケーション (ウイルス対策ソフトウェアなど) によって、によって<xref:System.IO.FileSystemWatcher>検出された追加のファイルシステムイベントが発生する可能性があります。  
  
> [!NOTE]
>  <xref:System.IO.FileSystemWatcher.Deleted>他の<xref:System.IO.FileSystemWatcher> イベントに`null`関連してイベントが発生する順序は、プロパティがではない場合に変更される可能性があります。<xref:System.IO.FileSystemWatcher.SynchronizingObject%2A>  
  
   
  
## Examples  
 次の例では<xref:System.IO.FileSystemWatcher.Deleted> 、イベントを使用して、監視対象のファイルが削除されるたびにコンソールへのファイルパスを表示します。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public virtual void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="override this.Dispose : unit -&gt; unit" Usage="fileSystemWatcher.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.IO.FileSystemWatcher" /> によって使用されているアンマネージ リソースを解放します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="fileSystemWatcher.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">マネージド リソースとアンマネージド リソースの両方を解放する場合は <see langword="true" />。アンマネージド リソースだけを解放する場合は <see langword="false" />。</param>
        <summary><see cref="T:System.IO.FileSystemWatcher" /> によって使用されているアンマネージド リソースを解放し、オプションでマネージド リソースも解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、パブリック<xref:System.ComponentModel.Component.Dispose%2A>メソッド<xref:System.Object.Finalize%2A>とメソッドによって呼び出されます。 <xref:System.ComponentModel.Component.Dispose%2A>`disposing`パラメーターをに<xref:System.IO.FileSystemWatcher.Dispose%2A> 設定して、保護されたメソッド`true`を呼び出します。 <xref:System.Object.Finalize%2A>をに`disposing` <xref:System.IO.FileSystemWatcher.Dispose%2A> 設定してを呼び出します`false`。  
  
 `disposing` パラメーターが `true` の場合、このメソッドは、この <xref:System.IO.Compression.DeflateStream> が参照しているすべてのマネージド オブジェクトによって保持されているリソースをすべて解放します。 このメソッドは、参照される各オブジェクトの <xref:System.ComponentModel.Component.Dispose%2A> メソッドを呼び出します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.ComponentModel.Component.Dispose" /> は、他のオブジェクトから複数回呼び出すことができます。 をオーバーライド<see cref="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />する場合は、以前にを<see cref="M:System.ComponentModel.Component.Dispose" />呼び出したときに破棄されたオブジェクトを参照しないように注意してください。 を実装<see cref="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />する方法の詳細については、「 [Dispose メソッドの実装](~/docs/standard/garbage-collection/implementing-dispose.md)」を参照してください。  
  
<see cref="M:System.ComponentModel.Component.Dispose" /> および<see cref="M:System.Object.Finalize" />の詳細については、「[アンマネージリソースのクリーンアップ](~/docs/standard/garbage-collection/unmanaged.md)」を参照してください。</para></block>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.IO.FileSystemWatcher.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Flag to indicate if this instance is active")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Enabled")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コンポーネントが有効かどうかを示す値を取得または設定します。</summary>
        <value>コンポーネントが有効な場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] のデザイナーでコンポーネントを使用している場合、既定値は <see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 をに設定<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>しない限り、コンポーネントはイベント`true`を発生させません。  
  
> [!NOTE]
>  <xref:System.IO.FileSystemWatcher.Path%2A>プロパティ`true`が<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>設定され、がである場合、コンポーネントは指定されたディレクトリを監視しません。  
  
 メソッド<xref:System.IO.FileSystemWatcher.WaitForChanged%2A>を使用すると、このプロパティがに`false`設定されている場合でも、ファイルの変更に応答するためにイベントハンドラーを呼び出すことができます。  
  
   
  
## Examples  
 次の例では<xref:System.IO.FileSystemWatcher> 、を作成して、実行時に指定されたディレクトリを監視します。 コンポーネントは、ディレクトリ内のテキストファイルの`LastWrite`変更`LastAccess` 、作成、削除、または名前変更を監視するように設定されています。 ファイルが変更、作成、または削除された場合、ファイルへのパスがコンソールに出力されます。 ファイルの名前を変更すると、古いパスと新しいパスがコンソールに出力されます。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.IO.FileSystemWatcher" /> オブジェクトは破棄されました。</exception>
        <exception cref="T:System.PlatformNotSupportedException">現在のオペレーティング システムは Microsoft Windows NT 以降ではありません。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><see cref="P:System.IO.FileSystemWatcher.Path" /> で指定したディレクトリが見つかりませんでした。</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.IO.FileSystemWatcher.Path" /> が設定されていないか、無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="fileSystemWatcher.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>フォームまたは別のコンポーネントで使用する <see cref="T:System.IO.FileSystemWatcher" /> の初期化を終了します。 初期化は実行時に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 デザイン[!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]環境では、このメソッドを使用して、フォームまたは別のコンポーネントで使用されるコンポーネントの初期化を終了します。 メソッド<xref:System.IO.FileSystemWatcher.BeginInit%2A>は、初期化を開始します。 メソッドとメソッド<xref:System.IO.FileSystemWatcher.EndInit%2A>を使用すると、完全に初期化される前に、コントロールが使用されなくなります。 <xref:System.IO.FileSystemWatcher.BeginInit%2A>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public event System.IO.ErrorEventHandler Error;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.ErrorEventHandler Error" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Error" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Error As ErrorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::ErrorEventHandler ^ Error;" />
      <MemberSignature Language="F#" Value="member this.Error : System.IO.ErrorEventHandler " Usage="member this.Error : System.IO.ErrorEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.ErrorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.IO.FileSystemWatcher" /> のインスタンスが変更の監視を続けられない場合、または内部バッファー オーバーフローの場合に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、オブジェクトによる変更<xref:System.IO.FileSystemWatcher>の監視が禁止されている場合に発生します。 たとえば、オブジェクトがリモートディレクトリの変更を監視していて、そのディレクトリへの接続が失わ<xref:System.IO.FileSystemWatcher.Error>れた場合、イベントが発生します。  
  
 システムは、ファイルの変更を通知し、コンポーネントによって作成および Api に渡されるバッファーにそれらの変更を保存します。 短時間で多くの変更が加えられた場合、バッファーがオーバーフローする可能性があります。 これにより、コンポーネントはディレクトリの変更を追跡できなくなり、一括通知のみが提供されます。 バッファーのサイズを大きくすると、ディスクにスワップできないページングされていないメモリからのものであるため、サイズが大きくなります。バッファーはできるだけ小さくしてください。 バッファーオーバーフローを回避するには、 <xref:System.IO.FileSystemWatcher.NotifyFilter%2A>、 <xref:System.IO.FileSystemWatcher.Filter%2A>、および<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>の各プロパティを使用して、不要な変更通知を除外します。  
  
> [!NOTE]
>  一般的なファイルシステム操作では、複数のイベントが発生する可能性があります。 たとえば、あるディレクトリから別のディレクトリにファイルを移動すると、 <xref:System.IO.FileSystemWatcher.OnChanged%2A>いくつ<xref:System.IO.FileSystemWatcher.OnCreated%2A>かの<xref:System.IO.FileSystemWatcher.OnDeleted%2A>イベントとイベントが発生する可能性があります。 ファイルの移動は、複数の単純な操作で構成される複雑な操作であるため、複数のイベントが発生します。 同様に、一部のアプリケーション (ウイルス対策ソフトウェアなど) によって、によって<xref:System.IO.FileSystemWatcher>検出された追加のファイルシステムイベントが発生する可能性があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.ErrorEventArgs" />
        <altmember cref="T:System.IO.ErrorEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public string Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Filter" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Filter { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Filter : string with get, set" Usage="System.IO.FileSystemWatcher.Filter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue("*.*")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("File name filter pattern")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ディレクトリで監視するファイルを決定するために使用するフィルター文字列を取得または設定します。</summary>
        <value>フィルター文字列。 既定値は "* です。\*"(すべてのファイルをウォッチします)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 すべてのファイルの変更を監視するに<xref:System.IO.FileSystemWatcher.Filter%2A>は、プロパティを空の文字列 ("") に設定します。 特定のファイルを監視するには<xref:System.IO.FileSystemWatcher.Filter%2A> 、プロパティをファイル名に設定します。 たとえば、MyDoc ファイルの変更を監視するには、 <xref:System.IO.FileSystemWatcher.Filter%2A>プロパティを "MyDoc" に設定します。 また、特定の種類のファイルの変更を監視することもできます。 たとえば、テキストファイルの変更を監視するには、 <xref:System.IO.FileSystemWatcher.Filter%2A>プロパティを "* .txt" に設定します。 "\*&#124;.Txt\*" などの複数のフィルターの使用はサポートされていません。  
  
 プロパティは、 <xref:System.IO.FileSystemWatcher>オブジェクトがイベントの受信を開始した後に変更できます。 <xref:System.IO.FileSystemWatcher.Filter%2A>  
  
 不要な通知を除外する方法の詳細につい<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>て<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>は、 <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> 「」、「」、および「」プロパティを参照してください。  
  
 <xref:System.IO.FileSystemWatcher.Filter%2A>では、次の例に示すように、一致するファイルに対してワイルドカードを使用できます。  
  
|フィルター文字列|次のファイルを監視します|  
|-------------------|---------------------------------|  
|*.\*|すべてのファイル (既定)。 空の文字列 ("") もすべてのファイルを監視します。|  
|*.txt|"Txt" 拡張子を持つすべてのファイル。|  
|*recipe.doc|"レシピ" で終わるすべてのファイルを "doc" 拡張機能と共に使用します。|  
|win* .xml|"Xml" 拡張機能を持つ "win" で始まるすべてのファイル。|  
|売上 * 200?。xls|次のものと一致します。<br /><br />-Sales (2001 年7月) .xls <br/>-Sales (2002 年8月) .xls <br/>-Sales (2004 年3月) .xls<br /><br /> が一致しません。<br /><br />-Sales 11 月 .xls|  
|MyReport.Doc|MyReport .doc のみを監視します|  
  
   
  
## Examples  
 次の例では<xref:System.IO.FileSystemWatcher> 、を作成して、実行時に指定されたディレクトリを監視します。 コンポーネントは、ディレクトリ内のテキストファイルの`LastWrite`変更`LastAccess` 、作成、削除、または名前変更を監視するように設定されています。 ファイルが変更、作成、または削除された場合、ファイルへのパスがコンソールに出力されます。 ファイルの名前を変更すると、古いパスと新しいパスがコンソールに出力されます。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      </Docs>
    </Member>
    <Member MemberName="Filters">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;string&gt; Filters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.Collection`1&lt;string&gt; Filters" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Filters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Filters As Collection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::Collection&lt;System::String ^&gt; ^ Filters { System::Collections::ObjectModel::Collection&lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Filters : System.Collections.ObjectModel.Collection&lt;string&gt;" Usage="System.IO.FileSystemWatcher.Filters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ディレクトリ内で監視するファイルを決定するために、使用されているすべてのフィルターのコレクションを取得します。</summary>
        <value>フィルターコレクション。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~FileSystemWatcher ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!FileSystemWatcher ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="fileSystemWatcher.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のインスタンスに保持されているリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!NOTE]
> アプリケーションコードはこのメソッドを呼び出しません。ガベージコレクターによる終了処理が無効になっていない限り、ガベージコレクションの実行中に自動的に呼び出されます。 詳細については、次のトピックを参照してください。 <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> および <xref:System.Object.Finalize> このメソッドは、<xref:System.Object.Finalize> をオーバーライドします。

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IncludeSubdirectories">
      <MemberSignature Language="C#" Value="public bool IncludeSubdirectories { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeSubdirectories" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeSubdirectories As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeSubdirectories { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IncludeSubdirectories : bool with get, set" Usage="System.IO.FileSystemWatcher.IncludeSubdirectories" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Flag to indicate we want to watch subdirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_IncludeSubdirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定したパスのサブディレクトリを監視するかどうかを示す値を取得または設定します。</summary>
        <value>サブディレクトリを監視する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティと`true`そのサブディレクトリによって<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>指定されたディレクトリ内に含まれるファイルとディレクトリの変更通知を監視する場合は、に設定します。 <xref:System.IO.FileSystemWatcher.Path%2A> プロパティをに設定`false`すると、内部バッファーに送信される通知の数を減らすことができます。 <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> 不要な通知を除外する方法の詳細につい<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>て<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>は、「」および「」プロパティを参照してください。  
  
 の`true`場合<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> 、は直下の子ディレクトリだけでなく、サブツリー全体を再帰的に処理します。 このサブツリー内のファイルまたはディレクトリへの相対パスは、 <xref:System.IO.FileSystemEventArgs.Name%2A>監視している<xref:System.IO.RenamedEventArgs.OldName%2A>変更に<xref:System.IO.RenamedEventArgs>応じて、の<xref:System.IO.FileSystemEventArgs>プロパティとのプロパティに戻ります。 監視している変更に応じて、 <xref:System.IO.FileSystemEventArgs.FullPath%2A>の<xref:System.IO.FileSystemEventArgs>プロパティと<xref:System.IO.RenamedEventArgs.OldFullPath%2A>の<xref:System.IO.RenamedEventArgs>プロパティから完全修飾パスを取得できます。  
  
 監視して<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>いるディレクトリのサブツリーにディレクトリが作成され、が`true`である場合、そのディレクトリは自動的に監視されます。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemEventArgs.FullPath" />
        <altmember cref="P:System.IO.RenamedEventArgs.OldFullPath" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
        <altmember cref="P:System.IO.FileSystemEventArgs.Name" />
        <altmember cref="P:System.IO.RenamedEventArgs.OldName" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="InternalBufferSize">
      <MemberSignature Language="C#" Value="public int InternalBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 InternalBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property InternalBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int InternalBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.InternalBufferSize : int with get, set" Usage="System.IO.FileSystemWatcher.InternalBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(8192)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>内部バッファーのサイズ (バイト単位) を取得または設定します。</summary>
        <value>内部バッファー サイズ (バイト単位)。 既定値は 8192 (8 KB) です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 バッファーは 4 KB 以上に設定できますが、64 KB を超えることはできません。 <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>プロパティを4096バイト未満に設定しよう<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>とすると、値は破棄され、プロパティは4096バイトに設定されます。 最高のパフォーマンスを得るには、Intel ベースのコンピューターで 4 KB の倍数を使用します。  
  
 システムは、ファイルの変更をコンポーネントに通知し、コンポーネントが作成して Api に渡すバッファーにそれらの変更を保存します。 各イベントは、16バイトまでのメモリを使用できます。ファイル名は含まれません。 短時間で多くの変更が加えられた場合、バッファーがオーバーフローする可能性があります。 これにより、コンポーネントはディレクトリの変更を追跡できなくなり、一括通知のみが提供されます。 バッファーのサイズを大きくすると、ファイルシステムの変更イベントが見つからない可能性があります。 ただし、バッファーサイズの増加は、ディスクにスワップアウトできない非ページメモリからのものであるため、コストが高くなります。バッファーはできるだけ小さくしてください。 バッファーオーバーフローを回避するには、 <xref:System.IO.FileSystemWatcher.NotifyFilter%2A>プロパティ<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>とプロパティを使用して、不要な変更通知を除外します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
      </Docs>
    </Member>
    <Member MemberName="NotifyFilter">
      <MemberSignature Language="C#" Value="public System.IO.NotifyFilters NotifyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.NotifyFilters NotifyFilter" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.NotifyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property NotifyFilter As NotifyFilters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::NotifyFilters NotifyFilter { System::IO::NotifyFilters get(); void set(System::IO::NotifyFilters value); };" />
      <MemberSignature Language="F#" Value="member this.NotifyFilter : System.IO.NotifyFilters with get, set" Usage="System.IO.FileSystemWatcher.NotifyFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Flag to indicate which change event we want to monitor")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_ChangedFilter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.NotifyFilters</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ウォッチする変更の種類を取得または設定します。</summary>
        <value><see cref="T:System.IO.NotifyFilters" /> 値のいずれか 1 つ。 既定値は <see langword="LastWrite" />、<see langword="FileName" />、および <see langword="DirectoryName" /> のビットごとの OR の組み合わせです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.NotifyFilters>列挙体のメンバーを組み合わせて、一度に複数の種類の変更を監視することができます。 たとえば、ファイルのサイズの変更や、 `LastWrite`時間の変化を監視することができます。 これにより、ファイルまたはフォルダーのサイズが変更された場合、またはファイル`LastWrite`またはフォルダーの変更時にイベントが発生します。  
  
 これは、不要な通知を除外するための1つの方法です。 不要な通知を除外する方法の詳細につい<xref:System.IO.FileSystemWatcher.Filter%2A>て<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>は、 <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> 「」、「」、および「」プロパティを参照してください。  
  
   
  
## Examples  
 次の例では<xref:System.IO.FileSystemWatcher> 、を作成して、実行時に指定されたディレクトリを監視します。 コンポーネントは、ディレクトリ内のテキストファイルの`LastWrite`変更`LastAccess` 、作成、削除、または名前変更を監視するように設定されています。 ファイルが変更、作成、または削除された場合、ファイルへのパスがコンソールに出力されます。 ファイルの名前を変更すると、古いパスと新しいパスがコンソールに出力されます。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">値が、<see cref="T:System.IO.NotifyFilters" /> 値の有効なビットごとの OR の組み合わせになっていません。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">設定されようとしている値が無効です。</exception>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected void OnChanged (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnChanged(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnChanged (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnChanged(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnChanged : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.IO.FileSystemEventArgs" />。</param>
        <summary><see cref="E:System.IO.FileSystemWatcher.Changed" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnChanged%2A>は、監視されているディレクトリ内のファイルまたはディレクトリのサイズ、システム属性、最終書き込み時刻、最終アクセス時刻、またはセキュリティアクセス許可が変更されたときに呼び出されます。  
  
 イベントが<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>処理されるときに発生するイベントの数を制限するには、プロパティを使用します。 <xref:System.IO.FileSystemWatcher.Changed>  
  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A>イベントは、ファイルが作成されるとすぐに発生します。 監視対象のディレクトリ<xref:System.IO.FileSystemWatcher.OnCreated%2A>にファイルをコピーまたは転送する場合、イベントはすぐに発生し、その後に1つ<xref:System.IO.FileSystemWatcher.OnChanged%2A>以上のイベントが続きます。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラス<see cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />でをオーバーライドする場合は、必ず基底クラスの<see cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Changed" />
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnCreated">
      <MemberSignature Language="C#" Value="protected void OnCreated (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnCreated(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnCreated (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnCreated(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnCreated : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnCreated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.IO.FileSystemEventArgs" />。</param>
        <summary><see cref="E:System.IO.FileSystemWatcher.Created" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A>監視対象のディレクトリにファイルまたはディレクトリが作成されると、が呼び出されます。  
  
 ファイルやディレクトリのコピーや移動など、いくつかの一般的な原因はイベントに直接対応していませんが、これらの発生によってイベントが発生します。 ファイルまたはディレクトリをコピーすると、そのディレクトリが<xref:System.IO.FileSystemWatcher.Created>監視されている場合、ファイルのコピー先のディレクトリでイベントが発生します。 コピー元のディレクトリがの別の<xref:System.IO.FileSystemWatcher>インスタンスによって監視されていた場合、イベントは発生しません。 たとえば、の2つの<xref:System.IO.FileSystemWatcher>インスタンスを作成したとします。 FileSystemWatcher1 は "C:\My Documents" を監視するように設定されており、FileSystemWatcher2 は "C:\ your Documents" を監視するように設定されています。 "マイドキュメント" からファイルをコピーして "your documents" <xref:System.IO.FileSystemWatcher.Created>に貼り付けると、FileSystemWatcher2 でイベントが発生しますが、FileSystemWatcher1 に対してイベントは発生しません。 コピーとは異なり、ファイルまたはディレクトリを移動すると、2つのイベントが発生します。 前の例では、ファイルを "My documents" から "your documents" <xref:System.IO.FileSystemWatcher.Created>に移動した場合、FileSystemWatcher2 でイベントが発生<xref:System.IO.FileSystemWatcher.Deleted>し、FileSystemWatcher1 でイベントが発生します。  
  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A>イベントは、ファイルが作成されるとすぐに発生します。 監視対象のディレクトリ<xref:System.IO.FileSystemWatcher.OnCreated%2A>にファイルをコピーまたは転送する場合、イベントはすぐに発生し、その後に1つ<xref:System.IO.FileSystemWatcher.OnChanged%2A>以上のイベントが続きます。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラス<see cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />でをオーバーライドする場合は、必ず基底クラスの<see cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnDeleted">
      <MemberSignature Language="C#" Value="protected void OnDeleted (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnDeleted(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnDeleted (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnDeleted(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnDeleted : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnDeleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.IO.FileSystemEventArgs" />。</param>
        <summary><see cref="E:System.IO.FileSystemWatcher.Deleted" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnDeleted%2A>監視されているディレクトリ内のファイルまたはディレクトリが削除されると、が呼び出されます。  
  
 ファイルやディレクトリのコピーや移動など、いくつかの一般的な原因はイベントに直接対応していませんが、これらの発生によってイベントが発生します。 ファイルまたはディレクトリをコピーすると、そのディレクトリが<xref:System.IO.FileSystemWatcher.Created>監視されている場合、ファイルのコピー先のディレクトリでイベントが発生します。 コピー元のディレクトリがの別の<xref:System.IO.FileSystemWatcher>インスタンスによって監視されていた場合、イベントは発生しません。 たとえば、の2つの<xref:System.IO.FileSystemWatcher>インスタンスを作成したとします。 FileSystemWatcher1 は "C:\My Documents" を監視するように設定されており、FileSystemWatcher2 は "C:\ your Documents" を監視するように設定されています。 "マイドキュメント" から "ドキュメント<xref:System.IO.FileSystemWatcher.Created> " にファイルをコピーすると、FileSystemWatcher2 によってイベントが発生しますが、FileSystemWatcher1 に対してイベントは発生しません。 コピーとは異なり、ファイルまたはディレクトリを移動すると、2つのイベントが発生します。 前の例では、ファイルを "My documents" から "your documents" <xref:System.IO.FileSystemWatcher.Created>に移動した場合、FileSystemWatcher2 によってイベントが発生<xref:System.IO.FileSystemWatcher.Deleted>し、FileSystemWatcher1 によってイベントが発生します。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラス<see cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />でをオーバーライドする場合は、必ず基底クラスの<see cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnError">
      <MemberSignature Language="C#" Value="protected void OnError (System.IO.ErrorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnError(class System.IO.ErrorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnError (e As ErrorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnError(System::IO::ErrorEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnError : System.IO.ErrorEventArgs -&gt; unit" Usage="fileSystemWatcher.OnError e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.ErrorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.IO.ErrorEventArgs" />。</param>
        <summary><see cref="E:System.IO.FileSystemWatcher.Error" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnError%2A>は、エラーが発生したときに呼び出されます。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラス<see cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />でをオーバーライドする場合は、必ず基底クラスの<see cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Error" />
        <altmember cref="T:System.IO.ErrorEventArgs" />
        <altmember cref="T:System.IO.ErrorEventHandler" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
      </Docs>
    </Member>
    <Member MemberName="OnRenamed">
      <MemberSignature Language="C#" Value="protected void OnRenamed (System.IO.RenamedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnRenamed(class System.IO.RenamedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnRenamed (e As RenamedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnRenamed(System::IO::RenamedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnRenamed : System.IO.RenamedEventArgs -&gt; unit" Usage="fileSystemWatcher.OnRenamed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.RenamedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.IO.RenamedEventArgs" />。</param>
        <summary><see cref="E:System.IO.FileSystemWatcher.Renamed" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnRenamed%2A>監視対象のディレクトリ内のファイルまたはディレクトリの名前が変更されると、が呼び出されます。 この<xref:System.IO.RenamedEventArgs>引数には、変更の種類、古いパスと新しいパス、新旧の名前など、名前の変更操作に関する情報が含まれています。 がオペレーティングシステム<xref:System.IO.FileSystemEventArgs.Name>から古い名前と新しい名前のイベントに<xref:System.IO.FileSystemWatcher>一致しない場合、そのプロパティは名前が変更されたイベントに対して null になることがあります。 
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラス<see cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />でをオーバーライドする場合は、必ず基底クラスの<see cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Renamed" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Path : string with get, set" Usage="System.IO.FileSystemWatcher.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("The directory to monitor")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Path")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ウォッチするディレクトリのパスを取得または設定します。</summary>
        <value>監視するパス。 既定値は、空の文字列 ("") です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これは、ディレクトリへの完全修飾パスです。 <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>プロパティが`true`の場合、このディレクトリはシステムが変更を監視するルートです。それ以外の場合は、監視されている唯一のディレクトリです。 特定のファイルを監視するには<xref:System.IO.FileSystemWatcher.Path%2A> 、プロパティを完全修飾されたディレクトリ<xref:System.IO.FileSystemWatcher.Filter%2A>に設定し、プロパティをファイル名に設定します。  
  
 プロパティ<xref:System.IO.FileSystemWatcher.Path%2A>は、汎用名前付け規則 (UNC) パスをサポートします。  
  
> [!NOTE]
>  コンポーネントが変更を監視できるようにするには、このプロパティを設定する必要があります。  
  
 ディレクトリの名前を変更すると<xref:System.IO.FileSystemWatcher> 、は、新しく名前が変更された項目に自動的に再度アタッチします。 たとえば、 <xref:System.IO.FileSystemWatcher.Path%2A>プロパティを "C:\My documents" に設定し、ディレクトリの名前を手動で "c:\ your documents" に変更した場合、コンポーネントは、新しく名前を変更したディレクトリに対する変更通知のリッスンを続行します。 ただし、 <xref:System.IO.FileSystemWatcher.Path%2A>プロパティを要求するときには、古いパスが含まれています。 これは、コンポーネントが、ディレクトリの名前ではなく、ハンドルに基づいてどのディレクトリを監視するかを決定するために発生します。 名前を変更してもハンドルには影響しません。 そのため、コンポーネントを破棄し、 <xref:System.IO.FileSystemWatcher.Path%2A>プロパティを更新せずにコンポーネントを再作成すると、ディレクトリが存在しなくなったため、アプリケーションは失敗します。  
  
   
  
## Examples  
 次の例では<xref:System.IO.FileSystemWatcher> 、を作成して、実行時に指定されたディレクトリを監視します。 コンポーネントは、ディレクトリ内のテキストファイルの`LastWrite`変更`LastAccess` 、作成、削除、または名前変更を監視するように設定されています。 ファイルが変更、作成、または削除された場合、ファイルへのパスがコンソールに出力されます。 ファイルの名前を変更すると、古いパスと新しいパスがコンソールに出力されます。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定されたパスが存在しないか、見つかりませんでした。  
  
 または  
  
 指定したパスにワイルドカード文字が含まれています。  
  
 - または -  
  
 指定したパスに無効なパス文字が含まれています。</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
      </Docs>
    </Member>
    <Member MemberName="Renamed">
      <MemberSignature Language="C#" Value="public event System.IO.RenamedEventHandler Renamed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.RenamedEventHandler Renamed" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Renamed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Renamed As RenamedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::RenamedEventHandler ^ Renamed;" />
      <MemberSignature Language="F#" Value="member this.Renamed : System.IO.RenamedEventHandler " Usage="member this.Renamed : System.IO.RenamedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory rename matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Renamed")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.RenamedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した <see cref="P:System.IO.FileSystemWatcher.Path" /> のファイルまたはディレクトリの名前が変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントは、次のシグネチャを持つデリゲートです。<xref:System.IO.RenamedEventHandler> `Renamed`

 ```csharp
public delegate void Renamed(object sender, RenamedEventArgs e);
 ```
 ```vb
Public Delegate Sub RenamedEventHandler(sender As Object, e As RenamedEventArgs)
 ```
 オブジェクト<xref:System.IO.RenamedEventArgs>は、名前の変更操作に関する情報を提供します。たとえば、名前<xref:System.IO.FileSystemEventArgs.ChangeType>変更の種類 (プロパティ)、old と new の名前、新旧のパスなどです。 がオペレーティングシステム<xref:System.IO.FileSystemEventArgs.Name>から古い名前と新しい名前の<xref:System.IO.FileSystemWatcher>イベントに一致しない場合、プロパティは名前が変更されたイベントに対して null になる可能性があることに注意してください。

 監視しているディレクトリの名前を変更しても、通知は生成されません。 通知は、監視しているディレクトリ内のエントリに対してのみ発生します。  
  
   
  
## Examples  
 次の例では<xref:System.IO.FileSystemWatcher.Renamed> 、イベントを使用して、監視対象のファイルの名前が変更されるたびに、コンソールへのファイルパスを表示します。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.IO.FileSystemWatcher.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.ComponentModel.ISite" /> の <see cref="T:System.IO.FileSystemWatcher" /> を取得または設定します。</summary>
        <value><see cref="T:System.ComponentModel.ISite" /> の <see cref="T:System.IO.FileSystemWatcher" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サイトは<xref:System.ComponentModel.Component> 、を<xref:System.ComponentModel.Design.IDesignerHost.Container%2A>にバインドし、それらの間の通信を可能にします。さらに、コンテナーがそのコンポーネントを管理する方法を提供します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.IO.FileSystemWatcher.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("The object used to marshal the event handler calls resulting from a directory change")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_SynchronizingObject")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ディレクトリ変更の結果として発行されるイベント ハンドラー呼び出しをマーシャリングするために使用するオブジェクトを取得または設定します。</summary>
        <value>ディレクトリ変更の結果として発行されるイベント ハンドラー呼び出しをマーシャリングするために使用するオブジェクトを表す <see cref="T:System.ComponentModel.ISynchronizeInvoke" />。 既定値は、<see langword="null" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 が<xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> <xref:System.IO.FileSystemWatcher.Changed>の場合<xref:System.IO.FileSystemWatcher.Created>、、、 <xref:System.IO.FileSystemWatcher.Deleted>、およびの各イベントを処理するメソッドは、システムスレッドプールからのスレッドで呼び出されます。<xref:System.IO.FileSystemWatcher.Renamed> `null` システムスレッドプールの詳細については<xref:System.Threading.ThreadPool>、「」を参照してください。  
  
 <xref:System.IO.FileSystemWatcher.Changed> <xref:System.Windows.Forms.Button>、、、および<xref:System.IO.FileSystemWatcher.Renamed>の各イベントが、などのビジュアル Windows フォームコンポーネントによって処理される場合、システムスレッドプールを介してコンポーネントにアクセスしても動作しない可能性があります。または、例外が発生する可能性があります。 <xref:System.IO.FileSystemWatcher.Deleted> <xref:System.IO.FileSystemWatcher.Created> これを回避する<xref:System.IO.FileSystemWatcher.SynchronizingObject%2A>には、を Windows フォームコンポーネントに設定します。これ<xref:System.IO.FileSystemWatcher.Changed>に<xref:System.IO.FileSystemWatcher.Created>より<xref:System.IO.FileSystemWatcher.Deleted>、、 <xref:System.IO.FileSystemWatcher.Renamed> 、、およびの各イベントを処理するメソッドが、コンポーネントが作成されたのと同じスレッドで呼び出されます。  
  
 が Windows フォームデザイナーの内部[!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]で使用されて<xref:System.IO.FileSystemWatcher.SynchronizingObject%2A>いる場合、はを含むコントロールに<xref:System.IO.FileSystemWatcher>を自動的に設定します。 <xref:System.IO.FileSystemWatcher> たとえば、を<xref:System.IO.FileSystemWatcher> form1 のデザイナー (から<xref:System.Windows.Forms.Form>継承) <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A>に配置すると、の<xref:System.IO.FileSystemWatcher>プロパティは、form1 のインスタンスに設定されます。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.ISynchronizeInvoke" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForChanged">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>発生した変更についての固有な情報を格納する構造体を返す同期メソッド。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForChanged">
      <MemberSignature Language="C#" Value="public System.IO.WaitForChangedResult WaitForChanged (System.IO.WatcherChangeTypes changeType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.IO.WaitForChangedResult WaitForChanged(valuetype System.IO.WatcherChangeTypes changeType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.WaitForChanged(System.IO.WatcherChangeTypes)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForChanged (changeType As WatcherChangeTypes) As WaitForChangedResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::WaitForChangedResult WaitForChanged(System::IO::WatcherChangeTypes changeType);" />
      <MemberSignature Language="F#" Value="member this.WaitForChanged : System.IO.WatcherChangeTypes -&gt; System.IO.WaitForChangedResult" Usage="fileSystemWatcher.WaitForChanged changeType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.WaitForChangedResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeType" Type="System.IO.WatcherChangeTypes" />
      </Parameters>
      <Docs>
        <param name="changeType">ウォッチする <see cref="T:System.IO.WatcherChangeTypes" />。</param>
        <summary>監視する変更の種類を指定して、発生した変更についての固有な情報を格納する構造体を返す同期メソッド。</summary>
        <returns>発生した変更についての固有な情報を格納する <see cref="T:System.IO.WaitForChangedResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、最初の変更が発生するまで無期限に待機してから、を返します。 これは、 `timeout`パラメーターを- <xref:System.IO.FileSystemWatcher.WaitForChanged%2A> 1 に設定してを使用する場合と同じです。  
  
> [!NOTE]
>  このメソッドを使用すると、プロパティがに<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> `false`設定されている場合でも、ファイルの変更に応答するためにイベントハンドラーを呼び出すことができます。  
  
 システムによって<xref:System.IO.FileSystemWatcher>は、短い8.3 ファイル名形式を使用してファイルが変更されることがあります。 たとえば、"LongFileName. Longfilename" への変更は、"Longfilename ~" として報告されます。Lon "。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.WaitForChangedResult" />
      </Docs>
    </Member>
    <Member MemberName="WaitForChanged">
      <MemberSignature Language="C#" Value="public System.IO.WaitForChangedResult WaitForChanged (System.IO.WatcherChangeTypes changeType, int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.IO.WaitForChangedResult WaitForChanged(valuetype System.IO.WatcherChangeTypes changeType, int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.WaitForChanged(System.IO.WatcherChangeTypes,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForChanged (changeType As WatcherChangeTypes, timeout As Integer) As WaitForChangedResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::WaitForChangedResult WaitForChanged(System::IO::WatcherChangeTypes changeType, int timeout);" />
      <MemberSignature Language="F#" Value="member this.WaitForChanged : System.IO.WatcherChangeTypes * int -&gt; System.IO.WaitForChangedResult" Usage="fileSystemWatcher.WaitForChanged (changeType, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.WaitForChangedResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeType" Type="System.IO.WatcherChangeTypes" />
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="changeType">ウォッチする <see cref="T:System.IO.WatcherChangeTypes" />。</param>
        <param name="timeout">タイムアウトまでの待機時間 (ミリ秒単位)。</param>
        <summary>監視する変更の種類とタイムアウトまでの待機時間 (ミリ秒単位) を指定して、発生した変更についての固有な情報を格納する構造体を返す同期メソッド。</summary>
        <returns>発生した変更についての固有な情報を格納する <see cref="T:System.IO.WaitForChangedResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、変更が発生するか、タイムアウトになるまで待機します。`timeout`パラメーターの値-1 は、無期限に待機することを意味します。  
  
> [!NOTE]
>  このメソッドを使用すると、プロパティがに<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> `false`設定されている場合でも、ファイルの変更に応答するためにイベントハンドラーを呼び出すことができます。  
  
 システムによって<xref:System.IO.FileSystemWatcher>は、短い8.3 ファイル名形式を使用してファイルが変更されることがあります。 たとえば、"LongFileName. Longfilename" への変更は、"Longfilename ~" として報告されます。Lon "。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.WaitForChangedResult" />
      </Docs>
    </Member>
  </Members>
</Type>