<Type Name="Socket" FullName="System.Net.Sockets.Socket">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0e53ed559329dd82f20e5b4a3c153091d170154c" /><Meta Name="ms.sourcegitcommit" Value="f991677a7374c45590a432ff7ab830beb05f2ccd" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="07/27/2019" /><Meta Name="ms.locfileid" Value="68591545" /></Metadata><TypeSignature Language="C#" Value="public class Socket : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Socket extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.Socket" />
  <TypeSignature Language="VB.NET" Value="Public Class Socket&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Socket : IDisposable" />
  <TypeSignature Language="F#" Value="type Socket = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net</AssemblyName>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Berkeley ソケット インターフェイスを実装します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 クラス<xref:System.Net.Sockets.Socket>には、ネットワーク通信用の豊富なメソッドとプロパティのセットが用意されています。 クラス<xref:System.Net.Sockets.Socket>を使用すると、 <xref:System.Net.Sockets.ProtocolType>列挙に示されているいずれかの通信プロトコルを使用して、同期データ転送と非同期データ転送の両方を実行できます。  
  
 クラス<xref:System.Net.Sockets.Socket>は、非同期メソッドの .NET Framework 名前付けパターンに従います。 たとえば、同期<xref:System.Net.Sockets.Socket.Receive%2A>メソッドは、非同期<xref:System.Net.Sockets.Socket.BeginReceive%2A>メソッドと<xref:System.Net.Sockets.Socket.EndReceive%2A>メソッドに対応します。  
  
 アプリケーションで実行中に必要なスレッドが1つだけの場合は、次のメソッドを使用します。これらのメソッドは、同期操作モード用に設計されています。  
  
-   TCP などの接続指向プロトコルを使用している場合、サーバーは<xref:System.Net.Sockets.Socket.Listen%2A>メソッドを使用して接続をリッスンできます。 メソッド<xref:System.Net.Sockets.Socket.Accept%2A>は、受信接続要求を処理し、 <xref:System.Net.Sockets.Socket>データをリモートホストと通信するために使用できるを返します。 この返され<xref:System.Net.Sockets.Socket>たを使用<xref:System.Net.Sockets.Socket.Send%2A>し<xref:System.Net.Sockets.Socket.Receive%2A>て、メソッドまたはメソッドを呼び出します。 ローカル IP アドレスとポート番号を<xref:System.Net.Sockets.Socket.Listen%2A>指定する場合は、メソッドを呼び出す前にメソッドを呼び出します。<xref:System.Net.Sockets.Socket.Bind%2A> 基になるサービスプロバイダーがフリーポートを割り当てる場合は、ポート番号を0にします。 リッスンして<xref:System.Net.Sockets.Socket.Connect%2A>いるホストに接続する場合は、メソッドを呼び出します。 データを通信するに<xref:System.Net.Sockets.Socket.Send%2A>は、メソッドまたは<xref:System.Net.Sockets.Socket.Receive%2A>メソッドを呼び出します。  
  
-   UDP などのコネクションレスプロトコルを使用している場合は、接続をリッスンする必要はありません。 受信データグラム<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>を受け入れるには、メソッドを呼び出します。 メソッドを<xref:System.Net.Sockets.Socket.SendTo%2A>使用して、データグラムをリモートホストに送信します。  
  
 実行中に個別のスレッドを使用して通信を処理するには、非同期操作モード用に設計された次のメソッドを使用します。  
  
-   TCP などの接続指向プロトコルを使用している場合は、、 <xref:System.Net.Sockets.Socket>、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>および<xref:System.Net.Sockets.Socket.EndConnect%2A>の各メソッドを使用して、リッスンしているホストに接続します。 、、 <xref:System.Net.Sockets.Socket.BeginSend%2A> <xref:System.Net.Sockets.Socket.EndSend%2A> および<xref:System.Net.Sockets.Socket.EndReceive%2A>の各メソッドを使用して、データを非同期に通信します。 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 受信接続要求は、および<xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.EndAccept%2A>を使用して処理できます。  
  
-   UDP などのコネクションレスプロトコルを使用している場合は、 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>および<xref:System.Net.Sockets.Socket.EndSendTo%2A>を使用してデータグラム<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>を<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>送信したり、データグラムを受信したりすることができます。  
  
 1つのソケットに対して複数の非同期操作を実行する場合、それらの操作は、開始された順序で完了するとは限りません。  
  
 データの送受信が終了したら、 <xref:System.Net.Sockets.Socket.Shutdown%2A>メソッドを使用して<xref:System.Net.Sockets.Socket>を無効にします。 を呼び出し<xref:System.Net.Sockets.Socket.Shutdown%2A>た後、 <xref:System.Net.Sockets.Socket.Close%2A>メソッドを呼び出して、に関連付け<xref:System.Net.Sockets.Socket>られているすべてのリソースを解放します。  
  
 クラスを<xref:System.Net.Sockets.Socket>使用すると、 <xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドを使用してを構成できます。 <xref:System.Net.Sockets.Socket> メソッドを使用して<xref:System.Net.Sockets.Socket.GetSocketOption%2A> 、これらの設定を取得します。  
  
> [!NOTE]
>  比較的単純なアプリケーションを作成していて、最大のパフォーマンスを必要と<xref:System.Net.Sockets.TcpClient>し<xref:System.Net.Sockets.TcpListener>ない場合<xref:System.Net.Sockets.UdpClient>は、、、およびを使用することを検討してください。 これらのクラスは、通信のため<xref:System.Net.Sockets.Socket>のより簡単でわかりやすいインターフェイスを提供します。  
  
   
  
## Examples  
 次のコード例では、 <xref:System.Net.Sockets.Socket>クラスを使用して HTTP サーバーにデータを送信し、応答を受信する方法を示します。 この例では、ページ全体が受信されるまでブロックします。  
  
 [!code-cpp[System.Net.Sockets.Socket#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CPP/socket.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CS/socket.cs#1)]
 [!code-vb[System.Net.Sockets.Socket#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.Socket/VB/socket.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission">発信接続を確立するか、受信要求を受け入れる。</permission>
    <threadsafe>このクラスのインスタンスは、スレッドセーフです。</threadsafe>
    <altmember cref="N:System.Net" />
    <altmember cref="N:System.Net.Cache" />
    <altmember cref="N:System.Net.Security" />
    <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
    <related type="Article" href="~/docs/framework/network-programming/index.md">.NET Framework のネットワーク プログラミング</related>
    <related type="Article" href="~/docs/framework/network-programming/best-practices-for-system-net-classes.md">System.Net クラスのベスト プラクティス</related>
    <related type="Article" href="~/docs/framework/network-programming/cache-management-for-network-applications.md">ネットワーク アプリケーションのキャッシュ管理</related>
    <related type="Article" href="~/docs/framework/network-programming/internet-protocol-version-6.md">インターネット プロトコル バージョン 6</related>
    <related type="Article" href="~/docs/framework/network-programming/network-programming-samples.md">ネットワーク プログラミングのサンプル</related>
    <related type="Article" href="~/docs/framework/network-programming/network-tracing.md">.NET Framework のネットワークのトレース</related>
    <related type="Article" href="~/docs/framework/network-programming/security-in-network-programming.md">ネットワーク プログラミングにおけるセキュリティ</related>
    <related type="Article" href="~/docs/framework/network-programming/socket-performance-enhancements-in-version-3-5.md">バージョン 3.5 のソケット パフォーマンスの強化</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketInformation socketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketInformation socketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketInformation socketInformation);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketInformation -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket socketInformation" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketInformation" Type="System.Net.Sockets.SocketInformation" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="socketInformation"><see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /> によって返されるソケット情報。</param>
        <summary><see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /> から返された値を指定して、<see cref="T:System.Net.Sockets.Socket" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 各呼び出しの引数<xref:System.Net.Sockets.Socket.%23ctor%2A>と同じバイト配列を使用してコンストラクターを複数回呼び出す場合は、基になる同じ<xref:System.Net.Sockets.Socket>ソケットを使用して複数のマネージを作成します。 この方法は推奨されません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="socketType"><see cref="T:System.Net.Sockets.SocketType" /> 値のいずれか 1 つ。</param>
        <param name="protocolType"><see cref="T:System.Net.Sockets.ProtocolType" /> 値のいずれか。</param>
        <summary>指定したソケットの種類とプロトコルを使用して、<see cref="T:System.Net.Sockets.Socket" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 パラメーター `socketType` <xref:System.Net.Sockets.Socket>はクラスの型を指定し、パラメーター `protocolType`はによって<xref:System.Net.Sockets.Socket>使用されるプロトコルを指定します。 2つのパラメーターは独立していません。 多くの<xref:System.Net.Sockets.Socket>場合、型はプロトコルで暗黙の型になります。 型とプロトコルの<xref:System.Net.Sockets.Socket>型の組み合わせによって無効<xref:System.Net.Sockets.Socket>なが生成された<xref:System.Net.Sockets.SocketException>場合、このコンストラクターはをスローします。  
  
> [!NOTE]
>  このコンストラクターがを<xref:System.Net.Sockets.SocketException>スローする場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketType" /> と <paramref name="protocolType" /> を組み合わせると、無効なソケットになります。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.AddressFamily addressFamily, System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily addressFamily, valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::AddressFamily addressFamily, System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.AddressFamily * System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (addressFamily, socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="addressFamily" Type="System.Net.Sockets.AddressFamily" />
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="addressFamily"><see cref="T:System.Net.Sockets.AddressFamily" /> 値のいずれか 1 つ。</param>
        <param name="socketType"><see cref="T:System.Net.Sockets.SocketType" /> 値のいずれか。</param>
        <param name="protocolType"><see cref="T:System.Net.Sockets.ProtocolType" /> 値のいずれか。</param>
        <summary>指定したアドレス ファミリ、ソケットの種類、およびプロトコルを使用して、<see cref="T:System.Net.Sockets.Socket" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 パラメーター `addressFamily`は、 <xref:System.Net.Sockets.Socket>クラスが使用するアドレス指定スキームを指定`socketType`します。パラメーターは<xref:System.Net.Sockets.Socket>クラスの型を指定`protocolType`し、パラメーターはによっ<xref:System.Net.Sockets.Socket>て使用されるプロトコルを指定します。 この3つのパラメーターは独立していません。 アドレスファミリによっては、それらで使用できるプロトコルが制限さ<xref:System.Net.Sockets.Socket>れます。また、多くの場合、プロトコルでは型が暗黙的に使用されます。 アドレスファミリ、 <xref:System.Net.Sockets.Socket>型、およびプロトコルの種類の組み合わせによって無効<xref:System.Net.Sockets.Socket>なが生成された<xref:System.Net.Sockets.SocketException>場合、このコンストラクターはをスローします。  
  
> [!NOTE]
>  このコンストラクターがを<xref:System.Net.Sockets.SocketException>スローする場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 <xref:System.Net.Sockets.Socket>クラスのインスタンスを作成する方法を次のコード例に示します。  
  
 [!code-cpp[Socket_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="addressFamily" />、<paramref name="socketType" />、および <paramref name="protocolType" /> を組み合わせると、無効なソケットになります。</exception>
        <altmember cref="T:System.Net.Sockets.SocketException" />
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
        <altmember cref="T:System.Net.Sockets.ProtocolType" />
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Accept ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket Accept() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Function Accept () As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ Accept();" />
      <MemberSignature Language="F#" Value="member this.Accept : unit -&gt; System.Net.Sockets.Socket" Usage="socket.Accept " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>新しく作成された接続に対して新しい <see cref="T:System.Net.Sockets.Socket" /> を作成します。</summary>
        <returns>新しく作成された接続に対する <see cref="T:System.Net.Sockets.Socket" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Accept%2A>リッスンしているソケットの接続要求キューから、最初の保留中の接続要求を同期的に抽出し<xref:System.Net.Sockets.Socket>、新しいを作成して返します。 この返された値<xref:System.Net.Sockets.Socket>を使用して、接続キューからの追加の接続を受け入れることはできません。 ただし、返され<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> <xref:System.Net.Sockets.Socket>たのメソッドを呼び出して、リモートホストのネットワークアドレスとポート番号を識別することができます。  
  
 ブロックモードでは<xref:System.Net.Sockets.Socket.Accept%2A> 、着信接続の試行がキューに置かれるまでブロックされます。 接続が受け入れられると、元<xref:System.Net.Sockets.Socket>のは、終了するまで着信接続要求をキューに挿入し続けます。  
  
 非ブロッキング<xref:System.Net.Sockets.Socket>を使用してこのメソッドを呼び出し、接続要求がキューに登録されて<xref:System.Net.Sockets.SocketException>いない場合、 <xref:System.Net.Sockets.Socket.Accept%2A>はをスローします。 を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.Socket.Accept%2A>メソッドを呼び出す前に、まず<xref:System.Net.Sockets.Socket.Listen%2A>メソッドを呼び出して、受信接続要求をリッスンし、キューに挿入する必要があります。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、 <xref:System.Net.Sockets.Socket>単純な接続を受け入れます。  
  
 [!code-cpp[Classic Socket.Accept Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Accept Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Accept Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Accept Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Accept Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Accept Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.InvalidOperationException">受け入れ元のソケットが、接続をリッスンしていません。 <see cref="M:System.Net.Sockets.Socket.Accept" /> の前に <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> および <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出す必要があります。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="AcceptAsync">
      <MemberSignature Language="C#" Value="public bool AcceptAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AcceptAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool AcceptAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.AcceptAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.AcceptAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</param>
        <summary>受信接続の試行を受け入れる非同期操作を開始します。</summary>
        <returns>I/O 操作が保留中の場合は <see langword="true" />。 操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。  
  
 I/O 操作が同期的に完了した場合は <see langword="false" />。 この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向プロトコルでは、メソッド<xref:System.Net.Sockets.Socket.AcceptAsync%2A>を使用して、着信接続の試行を非同期的に処理できます。 接続を非同期に受け入れると、別の実行スレッド内でデータを送受信することができます。 <xref:System.Net.Sockets.Socket.AcceptAsync%2A>メソッドを呼び出す前に、 <xref:System.Net.Sockets.Socket.Listen%2A>メソッドを呼び出して受信接続要求をリッスンし、キューに挿入する必要があります。  
  
 完了が通知されるようにするには、EventHandler\<SocketAsyncEventArgs > delegate を実装するコールバックメソッドを作成し、 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>イベントにフックする必要があります。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>オブジェクトの次のプロパティとイベントが必要です。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼び出し元は、 <xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType>プロパティで使用するを指定することによって、 <xref:System.Net.Sockets.Socket>着信接続に使用する既存のを指定できます。  
  
 <xref:System.Net.Sockets.Socket.SocketType%2A> <xref:System.Net.Sockets.Socket.AddressFamily%2A> <xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.Socket.ProtocolType%2A> <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType>プロパティが null の場合、新しいは、現在<xref:System.Net.Sockets.Socket>のと同じ、、およびを使用して構築され、プロパティとして設定されます。 <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType>  
  
 呼び出し元は、 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> <xref:System.Net.Sockets.Socket.AcceptAsync%2A>メソッドを呼び出す前に、プロパティを任意のユーザー状態オブジェクトに設定できます。これにより、コールバックメソッドで情報を取得できるようになります。 コールバックが1つのオブジェクトよりも多くの情報を必要とする場合は、他の必要な状態情報をメンバーとして保持するために、小さなクラスを作成できます。  
  
 必要に応じて、 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッドが成功した後に、ソケットの最初のデータブロックを受け取るバッファーを指定することもできます。 この場合、プロパティは<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 、受信するデータが格納されているバッファーに設定する必要<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>があります。また、プロパティは、バッファー内で受信するデータの最大バイト数に設定する必要があります。 これらのプロパティは、 <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType>メソッドを使用して設定できます。 渡されたバッファーの一部は、基になる Winsock AcceptEx 呼び出しで使用するために、内部的に使用されます。 これは、返されるデータの量が、指定された<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>インスタンスのプロパティの値よりも小さいことを意味します。 内部で使用されるバッファーの量は、ソケットのアドレスファミリによって異なります。 必要な最小バッファーサイズは288バイトです。 より大きなバッファーサイズが指定されている<xref:System.Net.Sockets.Socket>場合、では、Winsock AcceptEx 呼び出しによって受信されたアドレスデータ以外の追加データが必要になり、この追加データが受信されるまで待機します。 タイムアウトが発生した場合、接続はリセットされます。 したがって、余分なデータが特定の量になることが予想される場合は、バッファーサイズを最小バッファーサイズに設定し、この量を加算する必要があります。  
  
 完了コールバックメソッドは、 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>プロパティを調べて、 <xref:System.Net.Sockets.Socket.AcceptAsync%2A>操作が成功したかどうかを確認する必要があります。  
  
 イベント<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>は、接続が受け入れら<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>れず、プロパティがに<xref:System.Net.Sockets.SocketError.ConnectionReset>設定される場合に発生することがあります。 これは、ハーフオープンの SYN タイプスキャンを使用したポートスキャンの結果として発生する可能性があります (SYN > SYN-ACK-> RST シーケンス)。 この条件を<xref:System.Net.Sockets.Socket.AcceptAsync%2A>処理するには、メソッドを使用するアプリケーションを準備する必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">引数が有効ではありません。 この例外は、提供されたバッファーのサイズが不足している場合に発生します。 バッファーは、2 * (sizeof(SOCKADDR_STORAGE + 16) バイト以上であることが必要です。  
  
この例外は、複数のバッファーが指定されているときに、<see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> プロパティが null 値ではない場合にも発生します。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">引数が範囲外です。 この例外は、<see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> が 0 未満の場合に発生します。</exception>
        <exception cref="T:System.InvalidOperationException">無効な操作が要求されました。 この例外は、受け入れ側の <see cref="T:System.Net.Sockets.Socket" /> が接続をリッスンしていない場合、または受け入れられたソケットがバインドされている場合に発生します。  
  
<see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> メソッドを呼び出す前に、<see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> メソッドと <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> メソッドを呼び出す必要があります。  
  
この例外は、ソケットが既に接続されている、またはソケット操作が指定された <paramref name="e" /> パラメーターを使用して既に進行中の場合にも発生します。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows XP 以降が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.AddressFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AddressFamily As AddressFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::AddressFamily AddressFamily { System::Net::Sockets::AddressFamily get(); };" />
      <MemberSignature Language="F#" Value="member this.AddressFamily : System.Net.Sockets.AddressFamily" Usage="System.Net.Sockets.Socket.AddressFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> のアドレス ファミリを取得します。</summary>
        <value><see cref="T:System.Net.Sockets.AddressFamily" /> 値のいずれか 1 つ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 は<xref:System.Net.Sockets.AddressFamily> 、 <xref:System.Net.Sockets.Socket>クラスのインスタンスが使用できるアドレス指定スキームを指定します。 このプロパティは読み取り専用で、 <xref:System.Net.Sockets.Socket>が作成されるときに設定されます。  
  
   
  
## Examples  
 次のコード例では<xref:System.Net.Sockets.AddressFamily>、 <xref:System.Net.Sockets.SocketType>、、 <xref:System.Net.Sockets.ProtocolType>およびをコンソールに表示します。  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Available" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Available As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Available { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Available : int" Usage="System.Net.Sockets.Socket.Available" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ネットワークから受信した、読み取り可能なデータ量を取得します。</summary>
        <value>ネットワークから受信した、読み取り可能なデータのバイト数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非ブロッキング<xref:System.Net.Sockets.Socket>を使用している場合は<xref:System.Net.Sockets.Socket.Available%2A> 、を呼び出す<xref:System.Net.Sockets.Socket.Receive%2A>前に、データが読み取り用にキューに格納されているかどうかを判断することをお勧めします。 使用可能なデータは、読み取り用にネットワークバッファーにキューに格納されているデータの総量です。 データがネットワークバッファーに格納されてい<xref:System.Net.Sockets.Socket.Available%2A>ない場合、は0を返します。  
  
 リモートホストがシャットダウンまたは接続を閉じると、 <xref:System.Net.Sockets.Socket.Available%2A>はを<xref:System.Net.Sockets.SocketException>スローすることがあります。 を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、Ioonread と使用可能なプロパティを呼び出して、呼び出しの結果を比較しています。  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="F:System.Net.Sockets.SocketType.Dgram" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>受信接続の試行を受け入れる非同期操作を開始します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求のステータス情報を格納するオブジェクト。</param>
        <summary>受信接続の試行を受け入れる非同期操作を開始します。</summary>
        <returns>非同期の <see cref="T:System.Net.Sockets.Socket" /> 作成を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向プロトコルでは、メソッド<xref:System.Net.Sockets.Socket.BeginAccept%2A>を使用して、着信接続の試行を非同期的に処理できます。 接続を非同期に受け入れると、別の実行スレッド内でデータを送受信することができます。 <xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドを呼び出す前に、 <xref:System.Net.Sockets.Socket.Listen%2A>メソッドを呼び出して受信接続要求をリッスンし、キューに挿入する必要があります。  
  
 <xref:System.AsyncCallback>デリゲートを実装するコールバックメソッドを作成し、その名前を<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドに渡す必要があります。 これを行うには、少なくとも、 <xref:System.Net.Sockets.Socket> `state`パラメーターを使用してリッスン<xref:System.Net.Sockets.Socket.BeginAccept%2A>しているオブジェクトをに渡す必要があります。 コールバックでより多くの情報が必要な場合は、 <xref:System.Net.Sockets.Socket>とその他の必要な情報を保持する小さいクラスを作成できます。 パラメーター`state`を使用して、このクラス<xref:System.Net.Sockets.Socket.BeginAccept%2A>のインスタンスをメソッドに渡します。  
  
 コールバックメソッドは、メソッド<xref:System.Net.Sockets.Socket.EndAccept%2A>を呼び出す必要があります。 アプリケーションがを呼び<xref:System.Net.Sockets.Socket.BeginAccept%2A>出すと、通常、システムは別のスレッドを使用して、指定さ<xref:System.Net.Sockets.Socket.EndAccept%2A>れたコールバックメソッドを実行し、保留中の接続が取得されるまでブロックします。 <xref:System.Net.Sockets.Socket.EndAccept%2A>は、リモートホスト<xref:System.Net.Sockets.Socket>との間でデータを送受信するために使用できる新しいオブジェクトを返します。 この返された値<xref:System.Net.Sockets.Socket>を使用して、接続キューからの追加の接続を受け入れることはできません。 <xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドを呼び出した後に元のスレッドがブロックされるように<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>するには、を使用します。 元のスレッドの実行を<xref:System.Threading.ManualResetEvent>継続する場合は、コールバックメソッドので Set メソッドを呼び出します。  
  
 また、呼び出し元のスレッドを使用してコールバックメソッドを呼び出すこともできます。 この場合、 <xref:System.IAsyncResult.CompletedSynchronously%2A>返さ<xref:System.IAsyncResult>れるのプロパティは、メソッドが<xref:System.Net.Sockets.Socket.BeginAccept%2A>同期的に完了したことを示すように設定されます。  
  
 コールバックメソッドの記述の詳細については[、「コールバックメソッドとしてのデリゲートのマーシャリング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)」を参照してください。  
  
 <xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドへの保留中の呼び出しを取り消すには<xref:System.Net.Sockets.Socket>、を閉じます。 非同期操作の実行中に<xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドが呼び出されると、メソッドに渡されたコールバックが呼び出されます。<xref:System.Net.Sockets.Socket.Close%2A>  後続のメソッドの<xref:System.Net.Sockets.Socket.EndAccept%2A>呼び出しでは、操作が取り消されたことを示すためにが<xref:System.ObjectDisposedException>スローされます。  
  
> [!NOTE]
>  返され<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> <xref:System.Net.Sockets.Socket>たのプロパティを使用して、リモートホストのネットワークアドレスとポート番号を識別できます。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
> [!NOTE]
>  非同期<xref:System.Net.Sockets.Socket>メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。 特定のコンテキスト (特定の非同期<xref:System.Net.Sockets.Socket>メソッド、 <xref:System.Net.Sockets.Socket>特定のインスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。  
  
   
  
## Examples  
 次のコード例では、受信接続を非同期的に受信しようとしています。  
  
 [!code-cpp[Socket_Async_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Async_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Async_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows NT が必要です。</exception>
        <exception cref="T:System.InvalidOperationException">受け入れ元のソケットが、接続をリッスンしていません。 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> の前に <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> および <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出す必要があります。  
  
または 
受け入れられたソケットがバインドされています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="receiveSize" /> が 0 未満です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同期クライアント ソケットの例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同期サーバー ソケットの例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="receiveSize" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="receiveSize">送信元から受け入れるバイト数。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求のステータス情報を格納するオブジェクト。</param>
        <summary>受信接続の試行を受け入れる非同期操作を開始し、クライアント アプリケーションによって送信されるデータの最初のブロックを受信します。</summary>
        <returns>非同期の <see cref="T:System.Net.Sockets.Socket" /> 作成を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向プロトコルでは、メソッド<xref:System.Net.Sockets.Socket.BeginAccept%2A>を使用して、着信接続の試行を非同期的に処理できます。 接続を非同期に受け入れると、別の実行スレッド内でデータを送受信できるようになります。 このオーバーロードでは、 `receiveSize`パラメーターの初期転送時に受け入れるバイト数を指定できます。  
  
 <xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドを呼び出す前に、 <xref:System.Net.Sockets.Socket.Listen%2A>メソッドを呼び出して受信接続要求をリッスンし、キューに挿入する必要があります。  
  
 <xref:System.AsyncCallback>デリゲートを実装するコールバックメソッドを作成し、その名前を<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドに渡す必要があります。 これを行うには、少なくとも、 <xref:System.Net.Sockets.Socket> `state`パラメーターを使用してリッスン<xref:System.Net.Sockets.Socket.BeginAccept%2A>しているオブジェクトをに渡す必要があります。 コールバックでより多くの情報が必要な場合は、 <xref:System.Net.Sockets.Socket>とその他の必要な情報を保持する小さいクラスを作成できます。 パラメーター`state`を使用して、このクラス<xref:System.Net.Sockets.Socket.BeginAccept%2A>のインスタンスをメソッドに渡します。  
  
 コールバックメソッドは、メソッド<xref:System.Net.Sockets.Socket.EndAccept%2A>を呼び出す必要があります。 アプリケーションがを呼び<xref:System.Net.Sockets.Socket.BeginAccept%2A>出すと、通常、システムは別のスレッドを使用して、指定さ<xref:System.Net.Sockets.Socket.EndAccept%2A>れたコールバックメソッドを実行し、保留中の接続が取得されるまでブロックします。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>リモートホストと<xref:System.Net.Sockets.Socket>の間でデータを送受信するために使用できる新しいを返します。 この返された値<xref:System.Net.Sockets.Socket>を使用して、接続キューからの追加の接続を受け入れることはできません。 <xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドを呼び出した後に元のスレッドがブロックされるように<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>するには、を使用します。 元のスレッドの実行を<xref:System.Threading.ManualResetEvent>継続する場合は、コールバックメソッドので Set メソッドを呼び出します。  
  
 また、呼び出し元のスレッドを使用してコールバックメソッドを呼び出すこともできます。 この場合、 <xref:System.IAsyncResult.CompletedSynchronously%2A>返さ<xref:System.IAsyncResult>れるのプロパティは、メソッドが<xref:System.Net.Sockets.Socket.BeginAccept%2A>同期的に完了したことを示すように設定されます。  
  
 コールバックメソッドの記述の詳細については[、「コールバックメソッドとしてのデリゲートのマーシャリング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)」を参照してください。  
  
 <xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドへの保留中の呼び出しを取り消すには<xref:System.Net.Sockets.Socket>、を閉じます。  非同期操作の実行中に<xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドが呼び出されると、メソッドに渡されたコールバックが呼び出されます。<xref:System.Net.Sockets.Socket.Close%2A>  後続のメソッドの<xref:System.Net.Sockets.Socket.EndAccept%2A>呼び出しでは、操作が取り消されたことを示すためにが<xref:System.ObjectDisposedException>スローされます。  
  
> [!NOTE]
>  を呼び出すと、 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>返され<xref:System.Net.Sockets.Socket>たオブジェクトのプロパティを使用して、リモートホストのネットワークアドレスとポート番号を識別できます。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
> [!NOTE]
>  非同期<xref:System.Net.Sockets.Socket>メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。 特定のコンテキスト (特定の非同期<xref:System.Net.Sockets.Socket>メソッド、 <xref:System.Net.Sockets.Socket>特定のインスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。  
  
   
  
## Examples  
 次のコード例では、ソケットを開き、非同期接続を受け入れます。 この例では、ソケットは最初の10バイトのデータを受け入れます。 受信したバイト数とデータは、コールバックデリゲートによってコンソールに表示されます。 残り<xref:System.Net.Sockets.Socket.BeginReceive%2A>のデータを受信する方法の詳細については、「」を参照してください。  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows NT が必要です。</exception>
        <exception cref="T:System.InvalidOperationException">受け入れ元のソケットが、接続をリッスンしていません。 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> の前に <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> および <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出す必要があります。  
  
- または - 
受け入れられたソケットがバインドされています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="receiveSize" /> が 0 未満です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同期クライアント ソケットの例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同期サーバー ソケットの例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (System.Net.Sockets.Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.Net.Sockets.Socket acceptSocket, int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (acceptSocket As Socket, receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(System::Net::Sockets::Socket ^ acceptSocket, int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : System.Net.Sockets.Socket * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (acceptSocket, receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptSocket" Type="System.Net.Sockets.Socket" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="receiveSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="acceptSocket">受け入れた <see cref="T:System.Net.Sockets.Socket" /> オブジェクト。 この値は <see langword="null" /> の場合もあります。</param>
        <param name="receiveSize">受信する最大バイト数。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求のステータス情報を格納するオブジェクト。</param>
        <summary>指定したソケットから受信接続の試行を受け入れる非同期操作を開始し、クライアント アプリケーションによって送信されるデータの最初のブロックを受信します。</summary>
        <returns>非同期の <see cref="T:System.Net.Sockets.Socket" /> オブジェクトの作成を参照する <see cref="T:System.IAsyncResult" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向プロトコルでは、メソッド<xref:System.Net.Sockets.Socket.BeginAccept%2A>を使用して、着信接続の試行を非同期的に処理できます。 接続を非同期に受け入れると、別の実行スレッド内でデータを送受信することができます。 このオーバーロードでは、 `acceptSocket`パラメーターで受け入れられたソケットを指定できます。 このパラメーターが`null`の場合、受け入れられたソケットは<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドによって作成されます。 `receiveSize`パラメーターでは、初期転送時に受け入れるバイト数を指定できます。  
  
 <xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドを呼び出す前に、 <xref:System.Net.Sockets.Socket.Listen%2A>メソッドを呼び出して受信接続要求をリッスンし、キューに挿入する必要があります。  
  
 <xref:System.AsyncCallback>デリゲートを実装するコールバックメソッドを作成し、その名前を<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドに渡す必要があります。 これを行うには、少なくとも、 <xref:System.Net.Sockets.Socket> `state`パラメーターを使用してリッスン<xref:System.Net.Sockets.Socket.BeginAccept%2A>しているオブジェクトをに渡す必要があります。 コールバックでより多くの情報が必要な場合は、 <xref:System.Net.Sockets.Socket>とその他の必要な情報を保持する小さいクラスを作成できます。 パラメーター`state`を使用して、このクラス<xref:System.Net.Sockets.Socket.BeginAccept%2A>のインスタンスをメソッドに渡します。  
  
 コールバックメソッドは、メソッド<xref:System.Net.Sockets.Socket.EndAccept%2A>を呼び出す必要があります。 アプリケーションがを呼び<xref:System.Net.Sockets.Socket.BeginAccept%2A>出すと、通常、システムは別のスレッドを使用して、指定さ<xref:System.Net.Sockets.Socket.EndAccept%2A>れたコールバックメソッドを実行し、保留中の接続が取得されるまでブロックします。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>リモートホストと<xref:System.Net.Sockets.Socket>の間でデータを送受信するために使用できる新しいオブジェクトを返します。 この返された値<xref:System.Net.Sockets.Socket>を使用して、接続キューからの追加の接続を受け入れることはできません。 <xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドを呼び出した後に元のスレッドがブロックされるように<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>するには、を使用します。 元のスレッドの実行を<xref:System.Threading.ManualResetEvent>継続する場合は、コールバックメソッドので Set メソッドを呼び出します。  
  
 また、呼び出し元のスレッドを使用してコールバックメソッドを呼び出すこともできます。 この場合、 <xref:System.IAsyncResult.CompletedSynchronously%2A>返さ<xref:System.IAsyncResult>れるのプロパティは、メソッドが<xref:System.Net.Sockets.Socket.BeginAccept%2A>同期的に完了したことを示すように設定されます。  
  
 コールバックメソッドの記述の詳細については、「[コールバックメソッドとしてのデリゲートのマーシャリング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)」を参照してください。  
  
 <xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドへの保留中の呼び出しを取り消すには<xref:System.Net.Sockets.Socket>、を閉じます。 非同期操作の実行中に<xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドが呼び出されると、メソッドに渡されたコールバックが呼び出されます。<xref:System.Net.Sockets.Socket.Close%2A>  後続のメソッドの<xref:System.Net.Sockets.Socket.EndAccept%2A>呼び出しでは、操作が取り消されたことを示すためにが<xref:System.ObjectDisposedException>スローされます。  
  
> [!NOTE]
>  返され<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> <xref:System.Net.Sockets.Socket>たオブジェクトのプロパティを使用して、リモートホストのネットワークアドレスとポート番号を識別できます。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
> [!NOTE]
>  非同期<xref:System.Net.Sockets.Socket>メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。 特定のコンテキスト (特定の非同期<xref:System.Net.Sockets.Socket>メソッド、 <xref:System.Net.Sockets.Socket>特定のインスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。  
  
   
  
## Examples  
 次のコード例では、ソケットを開き、非同期接続を受け入れます。 この例では、ソケットは最初の10バイトのデータ`acceptSocket`を受け入れ、パラメーターはです。これにより、 <xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドによって、受け入れられたソケットが強制的に作成さ`null`れます。 受信したバイト数とデータは、コールバックデリゲートによってコンソールに表示されます。 残り<xref:System.Net.Sockets.Socket.BeginReceive%2A>のデータを受信する方法の詳細については、「」を参照してください。  
  
 [!code-cpp[NCLSocketEnhancements#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#7)]
 [!code-csharp[NCLSocketEnhancements#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows NT が必要です。</exception>
        <exception cref="T:System.InvalidOperationException">受け入れ元のソケットが、接続をリッスンしていません。 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> の前に <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> および <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出す必要があります。  
  
または 
受け入れられたソケットがバインドされています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="receiveSize" /> が 0 未満です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同期クライアント ソケットの例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同期サーバー ソケットの例</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginConnect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>リモート ホスト接続への非同期要求を開始します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (remoteEP As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint end_point, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint end_point, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (end_point As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ end_point, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (end_point, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="remoteEP">リモート ホストを表す <see cref="T:System.Net.EndPoint" />。</param>
        <param name="end_point">リモート ホストを表す <see cref="T:System.Net.EndPoint" />。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求のステータス情報を格納するオブジェクト。</param>
        <summary>リモート ホスト接続への非同期要求を開始します。</summary>
        <returns>非同期接続を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向プロトコルを使用している場合、メソッド<xref:System.Net.Sockets.Socket.BeginConnect%2A>は、 `remoteEP`パラメーターへの接続に対する非同期要求を開始します。 コネクションレスプロトコルを使用している<xref:System.Net.Sockets.Socket.BeginConnect%2A>場合は、によって既定のリモートホストが確立されます。 既定のリモートホストを非同期的に接続または設定すると、別の実行スレッド内でデータを送受信することができます。  
  
 <xref:System.AsyncCallback>デリゲートを実装するコールバックメソッドを作成し、その名前<xref:System.Net.Sockets.Socket.BeginConnect%2A>をメソッドに渡すことができます。 少なくとも、 <xref:System.Net.Sockets.Socket> `state`パラメーターを使用してを<xref:System.Net.Sockets.Socket.BeginConnect%2A>に渡す必要があります。 コールバックでより多くの情報が必要な場合は、 <xref:System.Net.Sockets.Socket>を保持する小さいクラスと、その他の必要な情報を作成できます。 パラメーター`state`を使用して、このクラス<xref:System.Net.Sockets.Socket.BeginConnect%2A>のインスタンスをメソッドに渡します。  
  
 コールバックメソッドは、メソッド<xref:System.Net.Sockets.Socket.EndConnect%2A>を呼び出す必要があります。 アプリケーションがを呼び<xref:System.Net.Sockets.Socket.BeginConnect%2A>出すと、システムは別のスレッドを使用して指定されたコールバックメソッド<xref:System.Net.Sockets.Socket.EndConnect%2A>を実行<xref:System.Net.Sockets.Socket>し、が正常に接続するか例外をスローするまでブロックします。 <xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドを呼び出した後に元のスレッドがブロックされるように<xref:System.Threading.WaitHandle.WaitOne%2A>するには、を使用します。 元のスレッドの実行を<xref:System.Threading.ManualResetEvent>継続する場合は、コールバックメソッドので Set メソッドを呼び出します。 コールバックメソッドの記述の詳細については[、「コールバックメソッドとしてのデリゲートのマーシャリング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)」を参照してください。  
  
 UDP などのコネクションレスプロトコルを使用している場合は、データを送受信<xref:System.Net.Sockets.Socket.BeginConnect%2A>する前にを呼び出す必要はありません。 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> および<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>を使用して、リモートホストと通信することができます。 を呼び出す<xref:System.Net.Sockets.Socket.BeginConnect%2A>と、指定された既定以外のアドレスから到着したデータグラムはすべて破棄されます。 既定のリモートホストをブロードキャストアドレスに設定する場合は、まずを呼び出し<xref:System.Net.Sockets.Socket.SetSocketOption%2A> 、にブロードキャストを`true`設定する必要があります。 できない場合、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>はを<xref:System.Net.Sockets.SocketException>スローします。  
  
 接続指向プロトコルを使用していて、を呼び出す<xref:System.Net.Sockets.Socket.Bind%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A>前にを呼び出さない場合、基になるサービスプロバイダーによって、最も適切なローカルネットワークアドレスとポート番号が割り当てられます。 コネクションレスプロトコルを使用している場合、サービスプロバイダーは、メソッド<xref:System.Net.Sockets.Socket.BeginSend%2A>または<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドを呼び出すまで、ローカルネットワークアドレスとポート番号を割り当てません。 既定のリモートホストを変更する場合は、目的の<xref:System.Net.Sockets.Socket.BeginConnect%2A>エンドポイントを使用してメソッドを再度呼び出します。  
  
 <xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドへの保留中の呼び出しを取り消すには<xref:System.Net.Sockets.Socket>、を閉じます。 非同期操作の実行中に<xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドが呼び出されると、メソッドに渡されたコールバックが呼び出されます。<xref:System.Net.Sockets.Socket.Close%2A>  後続のメソッドの<xref:System.Net.Sockets.Socket.EndConnect%2A>呼び出しでは、操作が取り消されたことを示すためにが<xref:System.ObjectDisposedException>スローされます。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このソケットが以前に切断されて<xref:System.Net.Sockets.Socket.BeginConnect%2A>いた場合は、操作が完了するまで終了しないスレッドでを呼び出す必要があります。 これは、基になるプロバイダーの制限です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
> [!NOTE]
>  非同期<xref:System.Net.Sockets.Socket>メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。 特定のコンテキスト (特定の非同期<xref:System.Net.Sockets.Socket>メソッド、 <xref:System.Net.Sockets.Socket>特定のインスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。  
  
   
  
## Examples  
 次のコード例では、非同期接続の試行を開始します。  
  
 [!code-cpp[Socket_Async_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Async_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Async_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="remoteEP" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタックの上位にある呼び出し元が、要求された操作のアクセス許可を保持していません。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出すことでリッスン状態になっているか、非同期操作は既に実行されています。</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">コールバック メソッドとしてのデリゲートのマーシャ リング</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同期クライアント ソケットの例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同期サーバー ソケットの例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (address, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">リモート ホストの <see cref="T:System.Net.IPAddress" />。</param>
        <param name="port">リモート ホストのポート番号。</param>
        <param name="requestCallback">接続操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="callback">接続操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">接続操作に関する情報を格納するユーザー定義のオブジェクト。 このオブジェクトは、操作の完了時に <paramref name="requestCallback" /> デリゲートに渡されます。</param>
        <summary>リモート ホスト接続への非同期要求を開始します。 ホストは <see cref="T:System.Net.IPAddress" /> とポート番号で指定されます。</summary>
        <returns>非同期接続を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期<xref:System.Net.Sockets.Socket.BeginConnect%2A>操作は、メソッドを<xref:System.Net.Sockets.Socket.EndConnect%2A>呼び出すことによって完了する必要があります。 通常、メソッドは`requestCallback`デリゲートによって呼び出されます。  
  
 このメソッドは、操作が完了するまでブロックしません。 操作が完了するまでブロックするには、 <xref:System.Net.Sockets.Socket.Connect%2A>メソッドのオーバーロードのいずれかまたは<xref:System.Net.Sockets.Socket.EndConnect%2A>を使用します。  
  
 <xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドへの保留中の呼び出しを取り消すには<xref:System.Net.Sockets.Socket>、を閉じます。 非同期操作の実行中に<xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドが呼び出されると、メソッドに渡されたコールバックが呼び出されます。<xref:System.Net.Sockets.Socket.Close%2A>  後続のメソッドの<xref:System.Net.Sockets.Socket.EndConnect%2A>呼び出しでは、操作が取り消されたことを示すためにが<xref:System.ObjectDisposedException>スローされます。  
  
 非同期プログラミングモデルの使用方法の詳細については、「[同期メソッドの非同期呼び出し](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)」を参照してください。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このソケットが以前に切断されて<xref:System.Net.Sockets.Socket.BeginConnect%2A>いた場合は、操作が完了するまで終了しないスレッドでを呼び出す必要があります。 これは、基になるプロバイダーの制限です。 また、 <xref:System.Net.EndPoint>使用するは異なっている必要があります。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
> [!NOTE]
>  非同期<xref:System.Net.Sockets.Socket>メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。 特定のコンテキスト (特定の非同期<xref:System.Net.Sockets.Socket>メソッド、 <xref:System.Net.Sockets.Socket>特定のインスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。  
  
   
  
## Examples  
 次のコード例では、非同期接続の試行を開始します。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#7)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="address" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Net.Sockets.Socket" /> はソケット ファミリに含まれません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">ポート番号が無効です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="address" /> の長さが 0 です。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出すことでリッスン状態になっているか、非同期操作は既に実行されています。</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">コールバック メソッドとしてのデリゲートのマーシャ リング</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同期クライアント ソケットの例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同期サーバー ソケットの例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (addresses, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="addresses">リモート ホストを指定する、少なくとも 1 つの <see cref="T:System.Net.IPAddress" />。</param>
        <param name="port">リモート ホストのポート番号。</param>
        <param name="requestCallback">接続操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="callback">接続操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">接続操作に関する情報を格納するユーザー定義のオブジェクト。 このオブジェクトは、操作の完了時に <paramref name="requestCallback" /> デリゲートに渡されます。</param>
        <summary>リモート ホスト接続への非同期要求を開始します。 ホストは、<see cref="T:System.Net.IPAddress" /> 配列とポート番号で指定されます。</summary>
        <returns>非同期接続を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期<xref:System.Net.Sockets.Socket.BeginConnect%2A>操作は、メソッドを<xref:System.Net.Sockets.Socket.EndConnect%2A>呼び出すことによって完了する必要があります。 通常、メソッドは`requestCallback`デリゲートによって呼び出されます。  
  
 このメソッドは、操作が完了するまでブロックしません。 操作が完了するまでブロックするには、 <xref:System.Net.Sockets.Socket.Connect%2A>メソッドオーバーロードのいずれかを使用します。  
  
 <xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドへの保留中の呼び出しを取り消すには<xref:System.Net.Sockets.Socket>、を閉じます。 非同期操作の実行中に<xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドが呼び出されると、メソッドに渡されたコールバックが呼び出されます。<xref:System.Net.Sockets.Socket.Close%2A>  後続のメソッドの<xref:System.Net.Sockets.Socket.EndConnect%2A>呼び出しでは、操作が取り消されたことを示すためにが<xref:System.ObjectDisposedException>スローされます。  
  
 非同期プログラミングモデルの使用方法の詳細については、「[同期メソッドの非同期呼び出し](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)」を参照してください。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このソケットが以前に切断されて<xref:System.Net.Sockets.Socket.BeginConnect%2A>いた場合は、操作が完了するまで終了しないスレッドでを呼び出す必要があります。 これは、基になるプロバイダーの制限です。 また、 <xref:System.Net.EndPoint>使用するは異なっている必要があります。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
> [!NOTE]
>  非同期<xref:System.Net.Sockets.Socket>メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。 特定のコンテキスト (特定の非同期<xref:System.Net.Sockets.Socket>メソッド、 <xref:System.Net.Sockets.Socket>特定のインスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。  
  
   
  
## Examples  
 次のコード例では、非同期接続の試行を開始します。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="addresses" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドは <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> または <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> を使用するソケットで有効です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">ポート番号が無効です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="address" /> の長さが 0 です。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出すことでリッスン状態になっているか、非同期操作は既に実行されています。</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">コールバック メソッドとしてのデリゲートのマーシャ リング</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同期クライアント ソケットの例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同期サーバー ソケットの例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (host, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="host">リモート ホストの名前。</param>
        <param name="port">リモート ホストのポート番号。</param>
        <param name="requestCallback">接続操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="callback">接続操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">接続操作に関する情報を格納するユーザー定義のオブジェクト。 このオブジェクトは、操作の完了時に <paramref name="requestCallback" /> デリゲートに渡されます。</param>
        <summary>リモート ホスト接続への非同期要求を開始します。 ホストはホスト名とポート番号で指定されます。</summary>
        <returns>非同期接続を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期<xref:System.Net.Sockets.Socket.BeginConnect%2A>操作は、メソッドを<xref:System.Net.Sockets.Socket.EndConnect%2A>呼び出すことによって完了する必要があります。 通常、メソッドは`requestCallback`デリゲートによって呼び出されます。  
  
 このメソッドは、操作が完了するまでブロックしません。 操作が完了するまでブロックするには、 <xref:System.Net.Sockets.Socket.Connect%2A>メソッドオーバーロードのいずれかを使用します。  
  
 <xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドへの保留中の呼び出しを取り消すには<xref:System.Net.Sockets.Socket>、を閉じます。 非同期操作の実行中に<xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドが呼び出されると、メソッドに渡されたコールバックが呼び出されます。<xref:System.Net.Sockets.Socket.Close%2A>  後続のメソッドの<xref:System.Net.Sockets.Socket.EndConnect%2A>呼び出しでは、操作が取り消されたことを示すためにが<xref:System.ObjectDisposedException>スローされます。  
  
 非同期プログラミングモデルの使用方法の詳細については、「[同期メソッドの非同期呼び出し](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)」を参照してください。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このソケットが以前に切断されて<xref:System.Net.Sockets.Socket.BeginConnect%2A>いた場合は、操作が完了するまで終了しないスレッドでを呼び出す必要があります。 これは、基になるプロバイダーの制限です。 また、 <xref:System.Net.EndPoint>使用するは異なっている必要があります。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
> [!NOTE]
>  非同期<xref:System.Net.Sockets.Socket>メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。 特定のコンテキスト (特定の非同期<xref:System.Net.Sockets.Socket>メソッド、 <xref:System.Net.Sockets.Socket>特定のインスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。  
  
   
  
## Examples  
 次のコード例では、非同期接続の試行を開始します。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#3)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="host" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドは <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> または <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> ファミリ内のソケットに対して正しいものです。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">ポート番号が無効です。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出すことでリッスン状態になっているか、非同期操作は既に実行されています。</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">コールバック メソッドとしてのデリゲートのマーシャ リング</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同期クライアント ソケットの例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同期サーバー ソケットの例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginDisconnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginDisconnect (bool reuseSocket, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginDisconnect(bool reuseSocket, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginDisconnect (reuseSocket As Boolean, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginDisconnect(bool reuseSocket, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginDisconnect : bool * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginDisconnect (reuseSocket, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">接続の終了後、このソケットが再利用できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求のステータス情報を格納するオブジェクト。</param>
        <summary>リモート エンドポイントからの切断の非同期要求を開始します。</summary>
        <returns>非同期操作を参照する <see cref="T:System.IAsyncResult" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向プロトコルを使用している場合は、 <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>メソッドを呼び出して、リモートエンドポイントからの切断を要求できます。 `reuseSocket` が`true`の場合は、ソケットを再利用できます。  
  
 メソッド<xref:System.Net.Sockets.Socket.BeginDisconnect%2A>は、別のスレッドを使用して、指定されたコールバックメソッドを呼び出します。 メソッド<xref:System.Net.Sockets.Socket.EndDisconnect%2A>は、保留中の切断が完了するまでブロックします。 コールバックメソッドの記述の詳細については、「[コールバックメソッドとしてのデリゲートのマーシャリング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)」を参照してください。  
  
> [!NOTE]
>  例外が発生した場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 <xref:System.Net.Sockets.SocketException> このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、非同期通信用のソケットを作成し、いくつかのデータをリモートホストに送信します。 データが送信されると、 <xref:System.Net.Sockets.Socket.Shutdown%2A>が呼び出され、送信と受信のアクティビティを停止します。 次<xref:System.Net.Sockets.Socket.BeginDisconnect%2A>に、が呼び出され、切断要求が開始されます。 要求が完了すると、 <xref:System.Net.Sockets.Socket.Connected%2A>プロパティが照会され、ソケットが切断されているかどうかがテストされます。  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Windows 2000 以前のオペレーティング システムです。このメソッドを使用するには、Windows XP が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> からの非同期のデータ受信を開始します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="callback">操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">受信操作に関する情報を格納するユーザー定義のオブジェクト。 このオブジェクトは、操作の完了時に <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> デリゲートに渡されます。</param>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> からの非同期のデータ受信を開始します。</summary>
        <returns>非同期の読み取りを参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期<xref:System.Net.Sockets.Socket.BeginReceive%2A>操作は、メソッドを<xref:System.Net.Sockets.Socket.EndReceive%2A>呼び出すことによって完了する必要があります。 通常、メソッドは`callback`デリゲートによって呼び出されます。  
  
 このメソッドは、操作が完了するまでブロックしません。 操作が完了するまでブロックするには、 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドオーバーロードのいずれかを使用します。  
  
 保留中<xref:System.Net.Sockets.Socket.BeginReceive%2A>のを取り消すには<xref:System.Net.Sockets.Socket.Close%2A> 、メソッドを呼び出します。  
  
 非同期プログラミングモデルの使用方法の詳細については、「[同期メソッドの非同期呼び出し](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)」を参照してください。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  特定のスレッドによって開始されるすべての i/o は、そのスレッドが終了すると取り消されます。 保留中の非同期操作は、操作が完了する前にスレッドが終了した場合に失敗する可能性があります。  
  
> [!NOTE]
>  `state`は、ユーザー定義クラスのインスタンス化です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
> [!NOTE]
>  非同期<xref:System.Net.Sockets.Socket>メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。 特定のコンテキスト (特定の非同期<xref:System.Net.Sockets.Socket>メソッド、 <xref:System.Net.Sockets.Socket>特定のインスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">コールバック メソッドとしてのデリゲートのマーシャ リング</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同期クライアント ソケットの例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同期サーバー ソケットの例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="errorCode">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</param>
        <param name="callback">操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">受信操作に関する情報を格納するユーザー定義のオブジェクト。 このオブジェクトは、操作の完了時に <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> デリゲートに渡されます。</param>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> からの非同期のデータ受信を開始します。</summary>
        <returns>非同期の読み取りを参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期<xref:System.Net.Sockets.Socket.BeginReceive%2A>操作は、メソッドを<xref:System.Net.Sockets.Socket.EndReceive%2A>呼び出すことによって完了する必要があります。 通常、メソッドは`callback`デリゲートによって呼び出されます。  
  
 このメソッドは、操作が完了するまでブロックしません。 操作が完了するまでブロックするには、 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドオーバーロードのいずれかを使用します。  
  
 保留中<xref:System.Net.Sockets.Socket.BeginReceive%2A>のを取り消すには<xref:System.Net.Sockets.Socket.Close%2A> 、メソッドを呼び出します。  
  
 非同期プログラミングモデルの使用方法の詳細については、「[同期メソッドの非同期呼び出し](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)」を参照してください。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  特定のスレッドによって開始されるすべての i/o は、そのスレッドが終了すると取り消されます。 保留中の非同期操作は、操作が完了する前にスレッドが終了した場合に失敗する可能性があります。  
  
> [!NOTE]
>  `state`は、ユーザー定義クラスのインスタンス化です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
> [!NOTE]
>  非同期<xref:System.Net.Sockets.Socket>メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。 特定のコンテキスト (特定の非同期<xref:System.Net.Sockets.Socket>メソッド、 <xref:System.Net.Sockets.Socket>特定のインスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">コールバック メソッドとしてのデリゲートのマーシャ リング</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同期クライアント ソケットの例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同期サーバー ソケットの例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, socket_flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">受信データを格納する、<paramref name="buffer" />パラメーター内の、インデックス番号が 0 から始まる位置。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="socket_flags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="callback">操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">受信操作に関する情報を格納するユーザー定義のオブジェクト。 このオブジェクトは、操作の完了時に <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> デリゲートに渡されます。</param>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> からの非同期のデータ受信を開始します。</summary>
        <returns>非同期の読み取りを参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期<xref:System.Net.Sockets.Socket.BeginReceive%2A>操作は、メソッドを<xref:System.Net.Sockets.Socket.EndReceive%2A>呼び出すことによって完了する必要があります。 通常、メソッドは`callback`デリゲートによって呼び出されます。  
  
 このメソッドは、操作が完了するまでブロックしません。 操作が完了するまでブロックするには、 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドオーバーロードのいずれかを使用します。  
  
 保留中<xref:System.Net.Sockets.Socket.BeginReceive%2A>のを取り消すには<xref:System.Net.Sockets.Socket.Close%2A> 、メソッドを呼び出します。  
  
 非同期プログラミングモデルの使用方法の詳細については、「[同期メソッドの非同期呼び出し](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)」を参照してください。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  特定のスレッドによって開始されるすべての i/o は、そのスレッドが終了すると取り消されます。 保留中の非同期操作は、操作が完了する前にスレッドが終了した場合に失敗する可能性があります。  
  
> [!NOTE]
>  `state`は、ユーザー定義クラスのインスタンス化です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
> [!NOTE]
>  非同期<xref:System.Net.Sockets.Socket>メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。 特定のコンテキスト (特定の非同期<xref:System.Net.Sockets.Socket>メソッド、 <xref:System.Net.Sockets.Socket>特定のインスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。  
  
   
  
## Examples  
 次のコード例では、接続されている<xref:System.Net.Sockets.Socket>からデータの非同期受信を開始します。  
  
 [!code-cpp[Socket_Async_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Async_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Async_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#11)]  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> が 0 未満です。  
  
または 
 <paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  
  
または 
 <paramref name="size" /> が 0 未満です。  
  
または 
 <paramref name="size" /> が、<paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">コールバック メソッドとしてのデリゲートのマーシャ リング</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同期クライアント ソケットの例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同期サーバー ソケットの例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags flags, out System.Net.Sockets.SocketError error, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags flags, [out] valuetype System.Net.Sockets.SocketError&amp; error, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, flags As SocketFlags, ByRef error As SocketError, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags flags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % error, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, flags, error, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="error" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">受信データを格納する <paramref name="buffer" />内の場所。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="flags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="errorCode">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</param>
        <param name="error">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</param>
        <param name="callback">操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">受信操作に関する情報を格納するユーザー定義のオブジェクト。 このオブジェクトは、操作の完了時に <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> デリゲートに渡されます。</param>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> からの非同期のデータ受信を開始します。</summary>
        <returns>非同期の読み取りを参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期<xref:System.Net.Sockets.Socket.BeginReceive%2A>操作は、メソッドを<xref:System.Net.Sockets.Socket.EndReceive%2A>呼び出すことによって完了する必要があります。 通常、メソッドは`callback`デリゲートによって呼び出されます。  
  
 このメソッドは、操作が完了するまでブロックしません。 操作が完了するまでブロックするには、 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドオーバーロードのいずれかを使用します。  
  
 保留中<xref:System.Net.Sockets.Socket.BeginReceive%2A>のを取り消すには<xref:System.Net.Sockets.Socket.Close%2A> 、メソッドを呼び出します。  
  
 非同期プログラミングモデルの使用方法の詳細については、「[同期メソッドの非同期呼び出し](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)」を参照してください。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  特定のスレッドによって開始されるすべての i/o は、そのスレッドが終了すると取り消されます。 保留中の非同期操作は、操作が完了する前にスレッドが終了した場合に失敗する可能性があります。  
  
> [!NOTE]
>  `state`は、ユーザー定義クラスのインスタンス化です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
> [!NOTE]
>  非同期<xref:System.Net.Sockets.Socket>メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。 特定のコンテキスト (特定の非同期<xref:System.Net.Sockets.Socket>メソッド、 <xref:System.Net.Sockets.Socket>特定のインスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> が 0 未満です。  
  
- または - 
 <paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  
  
- または - 
 <paramref name="size" /> が 0 未満です。  
  
または 
 <paramref name="size" /> が、<paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">コールバック メソッドとしてのデリゲートのマーシャ リング</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同期クライアント ソケットの例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同期サーバー ソケットの例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, ref System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint&amp; remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveFrom (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, ByRef remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ % remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveFrom (buffer, offset, size, socket_flags, remote_end, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">データを格納する、<paramref name="buffer" />パラメーター内の、インデックス番号が 0 から始まる位置。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="socket_flags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP">データのソースを表す <see cref="T:System.Net.EndPoint" />。</param>
        <param name="remote_end">データのソースを表す <see cref="T:System.Net.EndPoint" />。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求のステータス情報を格納するオブジェクト。</param>
        <summary>指定したネットワーク デバイスから、データの非同期の受信を開始します。</summary>
        <returns>非同期の読み取りを参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>は、リモートホストからのコネクションレスデータグラムの非同期読み取りを開始します。 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッドを呼び出すと、別の実行スレッド内でデータを受け取ることができます。  
  
 <xref:System.AsyncCallback>デリゲートを実装するコールバックメソッドを作成し、その名前<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>をメソッドに渡すことができます。 これを行うには、少なくとも、 `state`通信に使用される接続さ<xref:System.Net.Sockets.Socket>れたまたは既定値がパラメーターに含まれている必要があります。 コールバックでより多くの情報が必要な場合は、 <xref:System.Net.Sockets.Socket>とその他の必要な情報を保持する小さいクラスを作成できます。 パラメーター`state`を使用して、このクラス<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>のインスタンスをメソッドに渡します。  
  
 コールバックメソッドは、メソッド<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>を呼び出す必要があります。 アプリケーションがを呼び<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>出すと、システムは別のスレッドを使用して指定されたコールバックメソッドを<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>実行し<xref:System.Net.Sockets.Socket> 、がデータを読み取るか例外をスローするまでブロックします。 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッドを呼び出した後に元のスレッドがブロックされるように<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>するには、を使用します。 元のスレッドの実行を継続する場合は、コールバックメソッドの T:System.Threading.ManualResetEvent に対して Set メソッドを呼び出します。 コールバックメソッドの記述の詳細については、「[コールバックメソッドとしてのデリゲートのマーシャリング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)」を参照してください。  
  
> [!NOTE]
>  を呼び出す<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>前に、 <xref:System.Net.Sockets.Socket.Bind%2A>メソッドを使用<xref:System.Net.Sockets.Socket>してをローカルエンドポイントに明示的<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>にバインドする<xref:System.Net.Sockets.SocketException>か、をスローする必要があります。  
  
 このメソッドは、データを`buffer`パラメーターに読み込み、データの送信元のリモートホストエンドポイントをキャプチャします。 このエンドポイントを取得する方法の詳細につい<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>ては、「」を参照してください。 このメソッドは、不明なホストまたは複数のホストからコネクションレスのデータグラムを非同期的に受信する場合に最も役立ちます。 このような場合<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 、は、ローカルネットワークバッファーに受信した最初のエンキューされたデータグラムを読み取ります。 受信したデータグラムがのサイズを超える場合、 `buffer`メソッドは<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>可能な限り`buffer`多くのメッセージを格納し、を<xref:System.Net.Sockets.SocketException>スローします。 信頼性の低いプロトコルを使用している場合は、余分なデータが失われます。 信頼できるプロトコルを使用している場合は、余分なデータがサービスプロバイダーによって保持され、十分な<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>大きさのバッファーを持つメソッドを呼び出すことによって取得できます。  
  
 リモートホストエンドポイントが常に返されることを保証するには、アプリケーション<xref:System.Net.Sockets.Socket>で<xref:System.Net.Sockets.Socket.Bind%2A> <xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドを使用してをローカルエンドポイントに明示的に`optionLevel`バインドし、パラメーターをに<xref:System.Net.Sockets.SocketOptionLevel.IP>設定してメソッドを呼び出します。また<xref:System.Net.Sockets.SocketOptionLevel.IPv6>は<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 、 <xref:System.Net.Sockets.SocketOptionName.PacketInformation> `optionValue`必要に応じて、パラメーターをに設定し、パラメーターを使用して、メソッドを呼び出す前にこのオプションを有効にします。`optionName` そうしないと、受信側がメソッドを<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>呼び出した後に、送信者が複数のデータグラムを送信した場合に、リモートホストエンドポイントが返されない可能性があります。  
  
 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>はコネクションレスプロトコルを対象としていますが、接続指向プロトコルを使用することもできます。 これを選択する場合は、最初に<xref:System.Net.Sockets.Socket.Connect%2A>メソッドを /  <xref:System.Net.Sockets.Socket.BeginConnect%2A>呼び出してリモートホスト接続を確立するか、 <xref:System.Net.Sockets.Socket.Accept%2A>または<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドを呼び出して受信接続要求を受け入れる必要があります。 接続を確立また<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>は受け入れる前にメソッドを呼び出すと、が<xref:System.Net.Sockets.SocketException>取得されます。 また、 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッドを呼び出す前に、コネクションレスプロトコルの既定のリモートホストを確立することもできます。 どちらの場合<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>も、メソッドは`remoteEP`パラメーターを無視し、接続されたまたは既定のリモートホストからのデータのみを受信します。  
  
 接続指向のソケットでは<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 、は`size`パラメーターで指定されたバイト数まで、使用可能な量のデータを読み取ります。  
  
 保留中<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>のを取り消すには<xref:System.Net.Sockets.Socket.Close%2A> 、メソッドを呼び出します。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
> [!NOTE]
>  非同期<xref:System.Net.Sockets.Socket>メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。 特定のコンテキスト (特定の非同期<xref:System.Net.Sockets.Socket>メソッド、 <xref:System.Net.Sockets.Socket>特定のインスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。  
  
   
  
## Examples  
 次のコード例では、リモートホストからコネクションレスのデータグラムを非同期的に受信します。  
  
 [!code-cpp[Socket_Async_Send_Receive#41](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#41)]
 [!code-csharp[Socket_Async_Send_Receive#41](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#41)]
 [!code-vb[Socket_Async_Send_Receive#41](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> が <see langword="null" /> です。  
  
- または - 
 <paramref name="remoteEP" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> が 0 未満です。  
  
または 
 <paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  
  
または 
 <paramref name="size" /> が 0 未満です。  
  
または 
 <paramref name="size" /> が、 <paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタックの上位にある呼び出し元が、要求された操作のアクセス許可を保持していません。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">コールバック メソッドとしてのデリゲートのマーシャ リング</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveMessageFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveMessageFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">データを格納する、<paramref name="buffer" />パラメーター内の、インデックス番号が 0 から始まる位置。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP">データのソースを表す <see cref="T:System.Net.EndPoint" />。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求のステータス情報を格納するオブジェクト。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、指定したバイト数のデータの非同期受信を開始して、データ バッファー内の指定した位置に格納します。さらに、エンドポイントとパケット情報を格納します。</summary>
        <returns>非同期の読み取りを参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期の受信操作は、メソッドを<xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A>呼び出すことによって完了する必要があります。 通常、メソッドは`asyncCallback`デリゲートによって呼び出されます。  
  
 このメソッドは、操作が完了するまでブロックしません。 操作が完了するまでブロックするには<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> 、メソッドを使用します。  
  
 保留中<xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>のを取り消すには<xref:System.Net.Sockets.Socket.Close%2A> 、メソッドを呼び出します。  
  
 非同期プログラミングモデルの使用方法の詳細については、「[同期メソッドの非同期呼び出し](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)」を参照してください。  
  
 このメソッドは、データを`buffer`パラメーターに読み込み、データの送信元のリモートホストエンドポイント、および受信パケットに関する情報をキャプチャします。 このエンドポイントを取得する方法の詳細につい<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>ては、「」を参照してください。 このメソッドは、不明なホストまたは複数のホストからコネクションレスのデータグラムを非同期的に受信する場合に最も役立ちます。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
> [!NOTE]
>  非同期<xref:System.Net.Sockets.Socket>メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。 特定のコンテキスト (特定の非同期<xref:System.Net.Sockets.Socket>メソッド、 <xref:System.Net.Sockets.Socket>特定のインスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> が <see langword="null" /> です。  
  
- または - 
 <paramref name="remoteEP" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> が 0 未満です。  
  
- または - 
 <paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  
  
- または - 
 <paramref name="size" /> が 0 未満です。  
  
- または - 
 <paramref name="size" /> が、 <paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">Windows 2000 以前のオペレーティング システムです。このメソッドを使用するには、Windows XP が必要です。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> にデータを非同期的に送信します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">送信するデータを格納する <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求のステータス情報を格納するオブジェクト。</param>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> にデータを非同期的に送信します。</summary>
        <returns>非同期の送信を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Net.Sockets.Socket.BeginSend%2A> <xref:System.Net.Sockets.Socket.Connect%2A>は、、、 <xref:System.Net.Sockets.Socket.Accept%2A>、のいずれか<xref:System.Net.Sockets.Socket.BeginAccept%2A>のメソッドで確立され<xref:System.Net.Sockets.Socket.BeginConnect%2A>たリモートホストに対して、非同期の送信操作を開始します。 <xref:System.Net.Sockets.Socket.BeginSend%2A>最初<xref:System.Net.Sockets.Socket.Accept%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A>に、 、、またはを呼び出さない場合、は例外をスローします。<xref:System.Net.Sockets.Socket.Connect%2A> メソッドを<xref:System.Net.Sockets.Socket.BeginSend%2A>呼び出すと、別の実行スレッド内でデータを送信できるようになります。  
  
 <xref:System.AsyncCallback>デリゲートを実装するコールバックメソッドを作成し、その名前<xref:System.Net.Sockets.Socket.BeginSend%2A>をメソッドに渡すことができます。 これを行うには、少なくとも、 `state`通信に使用される接続さ<xref:System.Net.Sockets.Socket>れたまたは既定値がパラメーターに含まれている必要があります。 コールバックでより多くの情報が必要な場合は、 <xref:System.Net.Sockets.Socket>とその他の必要な情報を格納するための小さなクラスまたは構造体を作成できます。 パラメーター`state`を使用して、このクラス<xref:System.Net.Sockets.Socket.BeginSend%2A>のインスタンスをメソッドに渡します。  
  
 コールバックメソッドは、メソッド<xref:System.Net.Sockets.Socket.EndSend%2A>を呼び出す必要があります。 アプリケーションがを呼び<xref:System.Net.Sockets.Socket.BeginSend%2A>出すと、システムは別のスレッドを使用して指定されたコールバックメソッド<xref:System.Net.Sockets.Socket.EndSend%2A>を実行<xref:System.Net.Sockets.Socket>し、が要求したバイト数を送信するか、例外をスローするまでブロックします。 <xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドを呼び出した後に元のスレッドがブロックされるようにする<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>には、メソッドを使用します。 元のスレッドの実行を継続する場合は、コールバックメソッドの T:System.Threading.ManualResetEvent に対して Set メソッドを呼び出します。 コールバックメソッドの記述の詳細については[、「コールバックメソッドとしてのデリゲートのマーシャリング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)」を参照してください。  
  
 接続指向プロトコルを想定してい<xref:System.Net.Sockets.Socket.BeginSend%2A>ますが、最初にメソッド<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドを呼び出して既定のリモートホストを確立した場合、コネクションレスプロトコルでも機能します。 コネクションレスプロトコルを使用していて、複数の異なるホストにデータを送信すること<xref:System.Net.Sockets.Socket.BeginSendTo%2A>を計画している場合は、を使用する必要があります。 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> で<xref:System.Net.Sockets.Socket.Connect%2A>既定のリモートホストを確立した後でも、を使用できます。 または<xref:System.Net.Sockets.Socket.BeginSend%2A> を<xref:System.Net.Sockets.Socket.BeginConnect%2A>呼び出してからを呼び出す前に、既定のリモートホストを変更することもできます。 <xref:System.Net.Sockets.Socket.Connect%2A> コネクションレスプロトコルを使用する場合は、バッファーのサイズが基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要もあります。 この場合、データグラムは送信<xref:System.Net.Sockets.Socket.BeginSend%2A>されず、が<xref:System.Net.Sockets.SocketException>スローされます。  
  
 パラメーターとして<xref:System.Net.Sockets.SocketFlags.DontRoute>フラグを指定した場合、送信するデータはルーティングされません。 `socketflags`  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  特定のスレッドによって開始されるすべての i/o は、そのスレッドが終了すると取り消されます。 保留中の非同期操作は、操作が完了する前にスレッドが終了した場合に失敗する可能性があります。  
  
> [!NOTE]
>  `state`は、ユーザー定義クラスのインスタンス化です。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されたことは示されません。 転送されるデータを保持するためにトランスポートシステム内で使用できるバッファー領域がない場合、ソケットが非ブロッキングモードに設定されていない限り、send はブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
> [!NOTE]
>  非同期<xref:System.Net.Sockets.Socket>メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。 特定のコンテキスト (特定の非同期<xref:System.Net.Sockets.Socket>メソッド、 <xref:System.Net.Sockets.Socket>特定のインスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> が空です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 以下の解説を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">コールバック メソッドとしてのデリゲートのマーシャ リング</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同期クライアント ソケットの例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同期サーバー ソケットの例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">送信するデータを格納する <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="errorCode">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求のステータス情報を格納するオブジェクト。</param>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> にデータを非同期的に送信します。</summary>
        <returns>非同期の送信を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Net.Sockets.Socket.BeginSend%2A> <xref:System.Net.Sockets.Socket.Connect%2A>は、、、 <xref:System.Net.Sockets.Socket.Accept%2A>、のいずれか<xref:System.Net.Sockets.Socket.BeginAccept%2A>のメソッドで確立され<xref:System.Net.Sockets.Socket.BeginConnect%2A>たリモートホストに対して、非同期の送信操作を開始します。 <xref:System.Net.Sockets.Socket.BeginSend%2A>最初<xref:System.Net.Sockets.Socket.Accept%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A>に、 、、またはを呼び出さない場合、は例外をスローします。<xref:System.Net.Sockets.Socket.Connect%2A> メソッドを<xref:System.Net.Sockets.Socket.BeginSend%2A>呼び出すと、別の実行スレッド内でデータを送信できるようになります。  
  
 <xref:System.AsyncCallback>デリゲートを実装するコールバックメソッドを作成し、その名前<xref:System.Net.Sockets.Socket.BeginSend%2A>をメソッドに渡すことができます。 これを行うには、少なくとも、 `state`通信に使用される接続さ<xref:System.Net.Sockets.Socket>れたまたは既定値がパラメーターに含まれている必要があります。 コールバックでより多くの情報が必要な場合は、 <xref:System.Net.Sockets.Socket>とその他の必要な情報を格納するための小さなクラスまたは構造体を作成できます。 パラメーター`state`を使用して、このクラス<xref:System.Net.Sockets.Socket.BeginSend%2A>のインスタンスをメソッドに渡します。  
  
 コールバックメソッドは、メソッド<xref:System.Net.Sockets.Socket.EndSend%2A>を呼び出す必要があります。 アプリケーションがを呼び<xref:System.Net.Sockets.Socket.BeginSend%2A>出すと、システムは別のスレッドを使用して指定されたコールバックメソッド<xref:System.Net.Sockets.Socket.EndSend%2A>を実行<xref:System.Net.Sockets.Socket>し、が要求したバイト数を送信するか、例外をスローするまでブロックします。 <xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドを呼び出した後に元のスレッドがブロックされるようにする<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>には、メソッドを使用します。 元のスレッドの実行を<xref:System.Threading.ManualResetEvent>継続する場合は、コールバックメソッドので Set メソッドを呼び出します。 コールバックメソッドの記述の詳細については[、「コールバックメソッドとしてのデリゲートのマーシャリング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)」を参照してください。  
  
 接続指向プロトコルを想定してい<xref:System.Net.Sockets.Socket.BeginSend%2A>ますが、最初にメソッド<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドを呼び出して既定のリモートホストを確立した場合、コネクションレスプロトコルでも機能します。 コネクションレスプロトコルを使用していて、複数の異なるホストにデータを送信すること<xref:System.Net.Sockets.Socket.BeginSendTo%2A>を計画している場合は、を使用する必要があります。 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> で<xref:System.Net.Sockets.Socket.Connect%2A>既定のリモートホストを確立した後でも、を使用できます。 または<xref:System.Net.Sockets.Socket.BeginSend%2A> を<xref:System.Net.Sockets.Socket.BeginConnect%2A>呼び出してからを呼び出す前に、既定のリモートホストを変更することもできます。 <xref:System.Net.Sockets.Socket.Connect%2A> コネクションレスプロトコルを使用する場合は、バッファーのサイズが基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要もあります。 この場合、データグラムは送信<xref:System.Net.Sockets.Socket.BeginSend%2A>されず、が<xref:System.Net.Sockets.SocketException>スローされます。  
  
 パラメーターとして<xref:System.Net.Sockets.SocketFlags.DontRoute>フラグを指定した場合、送信するデータはルーティングされません。 `socketflags`  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  特定のスレッドによって開始されるすべての i/o は、そのスレッドが終了すると取り消されます。 保留中の非同期操作は、操作が完了する前にスレッドが終了した場合に失敗する可能性があります。  
  
> [!NOTE]
>  `state`は、ユーザー定義クラスのインスタンス化です。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されたことは示されません。 転送されるデータを保持するためにトランスポートシステム内で使用できるバッファー領域がない場合、ソケットが非ブロッキングモードに設定されていない限り、send はブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
> [!NOTE]
>  非同期<xref:System.Net.Sockets.Socket>メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。 特定のコンテキスト (特定の非同期<xref:System.Net.Sockets.Socket>メソッド、 <xref:System.Net.Sockets.Socket>特定のインスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> が空です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 以下の解説を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">コールバック メソッドとしてのデリゲートのマーシャ リング</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同期クライアント ソケットの例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同期サーバー ソケットの例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">送信するデータを格納する <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">送信を開始する、<paramref name="buffer" /> パラメーター内の、インデックス番号が 0 から始まる位置。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="errorCode">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求のステータス情報を格納するオブジェクト。</param>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> にデータを非同期的に送信します。</summary>
        <returns>非同期の送信を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Net.Sockets.Socket.BeginSend%2A> <xref:System.Net.Sockets.Socket.Connect%2A>は、、、 <xref:System.Net.Sockets.Socket.Accept%2A>、のいずれか<xref:System.Net.Sockets.Socket.BeginAccept%2A>のメソッドで確立され<xref:System.Net.Sockets.Socket.BeginConnect%2A>たリモートホストに対して、非同期の送信操作を開始します。 <xref:System.Net.Sockets.Socket.BeginSend%2A>最初<xref:System.Net.Sockets.Socket.Accept%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A>に、 、、またはを呼び出さない場合、は例外をスローします。<xref:System.Net.Sockets.Socket.Connect%2A> メソッドを<xref:System.Net.Sockets.Socket.BeginSend%2A>呼び出すと、別の実行スレッド内でデータを送信できるようになります。  
  
 <xref:System.AsyncCallback>デリゲートを実装するコールバックメソッドを作成し、その名前<xref:System.Net.Sockets.Socket.BeginSend%2A>をメソッドに渡すことができます。 これを行うには、少なくとも、 `state`通信に使用される接続さ<xref:System.Net.Sockets.Socket>れたまたは既定値がパラメーターに含まれている必要があります。 コールバックでより多くの情報が必要な場合は、 <xref:System.Net.Sockets.Socket>とその他の必要な情報を格納するための小さなクラスまたは構造体を作成できます。 パラメーター`state`を使用して、このクラス<xref:System.Net.Sockets.Socket.BeginSend%2A>のインスタンスをメソッドに渡します。  
  
 コールバックメソッドは、メソッド<xref:System.Net.Sockets.Socket.EndSend%2A>を呼び出す必要があります。 アプリケーションがを呼び<xref:System.Net.Sockets.Socket.BeginSend%2A>出すと、システムは別のスレッドを使用して指定されたコールバックメソッド<xref:System.Net.Sockets.Socket.EndSend%2A>を実行<xref:System.Net.Sockets.Socket>し、が要求したバイト数を送信するか、例外をスローするまでブロックします。 <xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドを呼び出した後に元のスレッドがブロックされるようにする<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>には、メソッドを使用します。 元のスレッドの実行を継続する場合は、コールバックメソッドの T:System.Threading.ManualResetEvent に対して Set メソッドを呼び出します。 コールバックメソッドの記述の詳細については[、「コールバックメソッドとしてのデリゲートのマーシャリング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)」を参照してください。  
  
 接続指向プロトコルを想定してい<xref:System.Net.Sockets.Socket.BeginSend%2A>ますが、最初にメソッド<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドを呼び出して既定のリモートホストを確立した場合、コネクションレスプロトコルでも機能します。 コネクションレスプロトコルを使用していて、複数の異なるホストにデータを送信すること<xref:System.Net.Sockets.Socket.BeginSendTo%2A>を計画している場合は、を使用する必要があります。 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> で<xref:System.Net.Sockets.Socket.Connect%2A>既定のリモートホストを確立した後でも、を使用できます。 または<xref:System.Net.Sockets.Socket.BeginSend%2A> を<xref:System.Net.Sockets.Socket.BeginConnect%2A>呼び出してからを呼び出す前に、既定のリモートホストを変更することもできます。 <xref:System.Net.Sockets.Socket.Connect%2A> コネクションレスプロトコルを使用する場合は、バッファーのサイズが基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要もあります。 この場合、データグラムは送信<xref:System.Net.Sockets.Socket.BeginSend%2A>されず、が<xref:System.Net.Sockets.SocketException>スローされます。  
  
 パラメーターとして<xref:System.Net.Sockets.SocketFlags.DontRoute>フラグを指定した場合、送信するデータはルーティングされません。 `socketflags`  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  特定のスレッドによって開始されるすべての i/o は、そのスレッドが終了すると取り消されます。 保留中の非同期操作は、操作が完了する前にスレッドが終了した場合に失敗する可能性があります。  
  
> [!NOTE]
>  `state`は、ユーザー定義クラスのインスタンス化です。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されたことは示されません。 転送されるデータを保持するためにトランスポートシステム内で使用できるバッファー領域がない場合、ソケットが非ブロッキングモードに設定されていない限り、send はブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
> [!NOTE]
>  非同期<xref:System.Net.Sockets.Socket>メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。 特定のコンテキスト (特定の非同期<xref:System.Net.Sockets.Socket>メソッド、 <xref:System.Net.Sockets.Socket>特定のインスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 以下の解説を参照してください。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> が 0 未満です。  
  
- または - 
 <paramref name="offset" /> が <paramref name="buffer" /> の長さより小さい値です。  
  
- または - 
 <paramref name="size" /> が 0 未満です。  
  
- または - 
 <paramref name="size" /> が、 <paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">コールバック メソッドとしてのデリゲートのマーシャ リング</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同期クライアント ソケットの例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同期サーバー ソケットの例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socket_flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">送信するデータを格納する <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">送信を開始する、<paramref name="buffer" /> パラメーター内の、インデックス番号が 0 から始まる位置。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="socket_flags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求のステータス情報を格納するオブジェクト。</param>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> にデータを非同期的に送信します。</summary>
        <returns>非同期の送信を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Net.Sockets.Socket.BeginSend%2A> <xref:System.Net.Sockets.Socket.Connect%2A>は、、、 <xref:System.Net.Sockets.Socket.Accept%2A>、のいずれか<xref:System.Net.Sockets.Socket.BeginAccept%2A>のメソッドで確立され<xref:System.Net.Sockets.Socket.BeginConnect%2A>たリモートホストに対して、非同期の送信操作を開始します。 <xref:System.Net.Sockets.Socket.BeginSend%2A>最初<xref:System.Net.Sockets.Socket.Accept%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A>に、 、、またはを呼び出さない場合、は例外をスローします。<xref:System.Net.Sockets.Socket.Connect%2A> メソッドを<xref:System.Net.Sockets.Socket.BeginSend%2A>呼び出すと、別の実行スレッド内でデータを送信できるようになります。  
  
 <xref:System.AsyncCallback>デリゲートを実装するコールバックメソッドを作成し、その名前<xref:System.Net.Sockets.Socket.BeginSend%2A>をメソッドに渡すことができます。 これを行うには、少なくとも、 `state`通信に使用される接続さ<xref:System.Net.Sockets.Socket>れたまたは既定値がパラメーターに含まれている必要があります。 コールバックでより多くの情報が必要な場合は、 <xref:System.Net.Sockets.Socket>とその他の必要な情報を格納するための小さなクラスまたは構造体を作成できます。 パラメーター`state`を使用して、このクラス<xref:System.Net.Sockets.Socket.BeginSend%2A>のインスタンスをメソッドに渡します。  
  
 コールバックメソッドは、メソッド<xref:System.Net.Sockets.Socket.EndSend%2A>を呼び出す必要があります。 アプリケーションがを呼び<xref:System.Net.Sockets.Socket.BeginSend%2A>出すと、システムは別のスレッドを使用して指定されたコールバックメソッド<xref:System.Net.Sockets.Socket.EndSend%2A>を実行<xref:System.Net.Sockets.Socket>し、が要求したバイト数を送信するか、例外をスローするまでブロックします。 <xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドを呼び出した後に元のスレッドがブロックされるようにする<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>には、メソッドを使用します。 元のスレッドの実行を継続する場合は、コールバックメソッドの T:System.Threading.ManualResetEvent に対して Set メソッドを呼び出します。 コールバックメソッドの記述の詳細については[、「コールバックメソッドとしてのデリゲートのマーシャリング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)」を参照してください。  
  
 接続指向プロトコルを想定してい<xref:System.Net.Sockets.Socket.BeginSend%2A>ますが、最初にメソッド<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドを呼び出して既定のリモートホストを確立した場合、コネクションレスプロトコルでも機能します。 コネクションレスプロトコルを使用していて、複数の異なるホストにデータを送信すること<xref:System.Net.Sockets.Socket.BeginSendTo%2A>を計画している場合は、を使用する必要があります。 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> で<xref:System.Net.Sockets.Socket.Connect%2A>既定のリモートホストを確立した後でも、を使用できます。 または<xref:System.Net.Sockets.Socket.BeginSend%2A> を<xref:System.Net.Sockets.Socket.BeginConnect%2A>呼び出してからを呼び出す前に、既定のリモートホストを変更することもできます。 <xref:System.Net.Sockets.Socket.Connect%2A> コネクションレスプロトコルを使用する場合は、バッファーのサイズが基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要もあります。 この場合、データグラムは送信<xref:System.Net.Sockets.Socket.BeginSend%2A>されず、が<xref:System.Net.Sockets.SocketException>スローされます。  
  
 パラメーターとして<xref:System.Net.Sockets.SocketFlags.DontRoute>フラグを指定した場合、送信するデータはルーティングされません。 `socketflags`  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  特定のスレッドによって開始されるすべての i/o は、そのスレッドが終了すると取り消されます。 保留中の非同期操作は、操作が完了する前にスレッドが終了した場合に失敗する可能性があります。  
  
> [!NOTE]
>  `state`は、ユーザー定義クラスのインスタンス化です。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されたことは示されません。 転送されるデータを保持するためにトランスポートシステム内で使用できるバッファー領域がない場合、ソケットが非ブロッキングモードに設定されていない限り、send はブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
> [!NOTE]
>  非同期<xref:System.Net.Sockets.Socket>メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。 特定のコンテキスト (特定の非同期<xref:System.Net.Sockets.Socket>メソッド、 <xref:System.Net.Sockets.Socket>特定のインスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。  
  
   
  
## Examples  
 次のコード例では、リモートホストへのデータの非同期送信を開始します。  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 以下の解説を参照してください。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> が 0 未満です。  
  
- または - 
 <paramref name="offset" /> が <paramref name="buffer" /> の長さより小さい値です。  
  
または 
 <paramref name="size" /> が 0 未満です。  
  
または 
 <paramref name="size" /> が、 <paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">コールバック メソッドとしてのデリゲートのマーシャ リング</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同期クライアント ソケットの例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同期サーバー ソケットの例</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>接続された <see cref="T:System.Net.Sockets.Socket" /> オブジェクトに、ファイルを非同期的に送信します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">送信するファイルのパスと名前を格納する文字列。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求のステータス情報を格納するオブジェクト。</param>
        <summary><see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> フラグを使用して、接続されている <see cref="T:System.Net.Sockets.Socket" /> オブジェクトにファイル <paramref name="fileName" /> を送信します。</summary>
        <returns>非同期送信を表す <see cref="T:System.IAsyncResult" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードは、接続`fileName`されているソケットにファイルを送信します。 が`fileName`ローカルディレクトリにある場合は、ファイル名だけで識別されます。それ以外の場合は、ファイルの完全なパスと名前を指定する必要があります。 ワイルドカード ("..\\\\\\\\\myfile.txt ") と UNC 共有名 (" \ shared directory \myfile.txt ") がサポートされています。 \\ ファイルが見つからない場合は、例外<xref:System.IO.FileNotFoundException>がスローされます。  
  
 このメソッドは、 `TransmitFile` Windows Sockets 2 API で検出された関数を使用します。 関数とそのフラグの`TransmitFile`詳細については、 [Windows ソケット](/windows/desktop/WinSock/)のドキュメントを参照してください。  
  
 メソッド<xref:System.Net.Sockets.Socket.BeginSendFile%2A> <xref:System.Net.Sockets.Socket.Connect%2A>は、、、 <xref:System.Net.Sockets.Socket.Accept%2A>、のいずれか<xref:System.Net.Sockets.Socket.BeginAccept%2A>のメソッドで確立され<xref:System.Net.Sockets.Socket.BeginConnect%2A>たリモートホストに対して、非同期の送信操作を開始します。 <xref:System.Net.Sockets.Socket.BeginSendFile%2A>最初<xref:System.Net.Sockets.Socket.Accept%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A>に、 、、またはを呼び出さない場合、例外がスローされます。<xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.BeginSendFile%2A>メソッドを呼び出すと、別の実行スレッド内でファイルを送信できます。  
  
 操作を完了するには、 <xref:System.AsyncCallback>デリゲートパラメーターによって呼び出されるコールバックメソッドを作成します。 これを行うには、少なくとも、 `state`パラメーターには通信<xref:System.Net.Sockets.Socket>に使用されるオブジェクトが含まれている必要があります。 コールバックでより多くの情報が必要な場合は、 <xref:System.Net.Sockets.Socket>とその他の必要な情報を保持するクラスまたは構造体を作成できます。 パラメーター`state`を使用して、このカスタムオブジェクト<xref:System.Net.Sockets.Socket.BeginSendFile%2A>のインスタンスをメソッドに渡します。  
  
 コールバックメソッドは、メソッド<xref:System.Net.Sockets.Socket.EndSendFile%2A>を呼び出す必要があります。 アプリケーションがを呼び<xref:System.Net.Sockets.Socket.BeginSendFile%2A>出すと、システムは別のスレッドを使用して指定されたコール<xref:System.Net.Sockets.Socket.EndSendFile%2A>バックメソッド<xref:System.Net.Sockets.Socket>を実行し、がファイル全体を送信するか、例外をスローするまでブロックします。 コールバックメソッドの記述の詳細については[、「コールバックメソッドとしてのデリゲートのマーシャリング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)」を参照してください。  
  
 接続指向プロトコルを想定してい<xref:System.Net.Sockets.Socket.BeginSendFile%2A>ますが、最初にメソッド<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドを呼び出して既定のリモートホストを確立した場合、コネクションレスプロトコルでも機能します。 コネクションレスプロトコルを使用する場合は、ファイルのサイズが基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要があります。 この場合、データグラムは送信<xref:System.Net.Sockets.Socket.BeginSendFile%2A>されず、 <xref:System.Net.Sockets.SocketException>例外がスローされます。  
  
> [!NOTE]
>  例外が発生した場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 <xref:System.Net.Sockets.SocketException> このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
> [!NOTE]
>  非同期<xref:System.Net.Sockets.Socket>メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。 特定のコンテキスト (特定の非同期<xref:System.Net.Sockets.Socket>メソッド、 <xref:System.Net.Sockets.Socket>特定のインスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。  
  
   
  
## Examples  
 次のコード例では、非同期通信用のソケットを作成して接続します。 まず、ファイル ".txt" をリモートホストに非同期的に送信します。 コールバックデリゲートは<xref:System.Net.Sockets.Socket.EndSendFile%2A> 、転送を完了するためにを呼び出します。  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.NotSupportedException">ソケットがリモート ホストに接続されていません。</exception>
        <exception cref="T:System.IO.FileNotFoundException">ファイル <paramref name="fileName" /> が見つかりませんでした。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 以下の解説を参照してください。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, preBuffer, postBuffer, flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="preBuffer" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="postBuffer" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">送信されるファイルのパスと名前を格納する文字列。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="preBuffer">ファイルが送信される前に送信されるデータを格納する <see cref="T:System.Byte" /> 配列。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="postBuffer">ファイルが送信された後で送信されるデータを格納する <see cref="T:System.Byte" /> 配列。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="flags"><see cref="T:System.Net.Sockets.TransmitFileOptions" /> 値のビットごとの組み合わせ。</param>
        <param name="callback">このオプションの完了時に呼び出される <see cref="T:System.AsyncCallback" /> デリゲート。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="state">この要求の状態情報を格納するユーザー定義のオブジェクト。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <summary>接続された <see cref="T:System.Net.Sockets.Socket" /> オブジェクトに、ファイルとデータのバッファーを非同期的に送信します。</summary>
        <returns>非同期操作を表す <see cref="T:System.IAsyncResult" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードには、送信するファイルの名前と値の<xref:System.Net.Sockets.TransmitFileOptions>ビットごとの組み合わせが必要です。 パラメーター `preBuffer`には、ファイルの前に配置するデータが含まれています。 `postBuffer`ファイルに従う必要があるデータが含まれています。 が`fileName`ローカルディレクトリにある場合は、ファイル名だけで識別されます。それ以外の場合は、ファイルの完全なパスと名前を指定する必要があります。 ワイルドカード ("..\\\\\\\\\myfile.txt ") と UNC 共有名 (" \ shared directory \myfile.txt ") がサポートされています。 \\ ファイルが見つからない場合は、例外<xref:System.IO.FileNotFoundException>がスローされます。  
  
 パラメーター `flags`は、ファイル転送に関する追加情報を Window Sockets service プロバイダーに提供します。 このパラメーターの使用方法の詳細については<xref:System.Net.Sockets.TransmitFileOptions>、「」を参照してください。  
  
 このメソッドは、 `TransmitFile` Windows Sockets 2 API で検出された関数を使用します。 関数とそのフラグの`TransmitFile`詳細については、 [Windows ソケット](/windows/desktop/WinSock/)のドキュメントを参照してください。  
  
 メソッド<xref:System.Net.Sockets.Socket.BeginSendFile%2A> <xref:System.Net.Sockets.Socket.Connect%2A>は、、、 <xref:System.Net.Sockets.Socket.Accept%2A>、のいずれか<xref:System.Net.Sockets.Socket.BeginAccept%2A>のメソッドで確立され<xref:System.Net.Sockets.Socket.BeginConnect%2A>たリモートホストに対して、非同期の送信操作を開始します。 <xref:System.Net.Sockets.Socket.BeginSendFile%2A>最初<xref:System.Net.Sockets.Socket.Accept%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A>に、 、、またはを呼び出さない場合、例外がスローされます。<xref:System.Net.Sockets.Socket.Connect%2A> メソッドを<xref:System.Net.Sockets.Socket.BeginSendFile%2A>呼び出すと、別の実行スレッド内でファイルを送信できるようになります。  
  
 操作を完了するには、 <xref:System.AsyncCallback>デリゲートパラメーターによって呼び出されるコールバックメソッドを作成します。 これを行うには、少なくとも、 `state`パラメーターには通信<xref:System.Net.Sockets.Socket>に使用されるオブジェクトが含まれている必要があります。 コールバックでより多くの情報が必要な場合は、 <xref:System.Net.Sockets.Socket>とその他の必要な情報を保持するクラスまたは構造体を作成できます。 パラメーター`state`を使用して、このカスタムオブジェクト<xref:System.Net.Sockets.Socket.BeginSendFile%2A>のインスタンスをメソッドに渡します。  
  
 コールバックメソッドは、メソッド<xref:System.Net.Sockets.Socket.EndSendFile%2A>を呼び出す必要があります。 アプリケーションがを呼び<xref:System.Net.Sockets.Socket.BeginSendFile%2A>出すと、システムは別のスレッドを使用して指定されたコール<xref:System.Net.Sockets.Socket.EndSendFile%2A>バックメソッド<xref:System.Net.Sockets.Socket>を実行し、がファイル全体を送信するか、例外をスローするまでブロックします。 コールバックメソッドの記述の詳細については[、「コールバックメソッドとしてのデリゲートのマーシャリング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)」を参照してください。  
  
 接続指向プロトコルを想定してい<xref:System.Net.Sockets.Socket.BeginSendFile%2A>ますが、最初にメソッド<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドを呼び出して既定のリモートホストを確立した場合、コネクションレスプロトコルでも機能します。 コネクションレスプロトコルを使用する場合は、ファイルのサイズが基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要もあります。 この場合、データグラムは送信<xref:System.Net.Sockets.Socket.BeginSendFile%2A>されず、 <xref:System.Net.Sockets.SocketException>例外がスローされます。  
  
> [!NOTE]
>  例外が発生した場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 <xref:System.Net.Sockets.SocketException> このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
> [!NOTE]
>  非同期<xref:System.Net.Sockets.Socket>メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。 特定のコンテキスト (特定の非同期<xref:System.Net.Sockets.Socket>メソッド、 <xref:System.Net.Sockets.Socket>特定のインスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。  
  
   
  
## Examples  
 次のコード例では、非同期通信用のソケットを作成して接続し、リモートホストへのファイル "test.txt" の非同期送信を開始します。 この例`preBuffer`では、ファイルと`postBuffer`共に送信するデータのとが作成され、 <xref:System.Net.Sockets.TransmitFileOptions>既定値が使用されます。 コールバックデリゲートは<xref:System.Net.Sockets.Socket.EndSendFile%2A> 、転送を完了するためにを呼び出します。  
  
 [!code-cpp[NCLSocketEnhancements#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#10)]
 [!code-csharp[NCLSocketEnhancements#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 以下の解説を参照してください。</exception>
        <exception cref="T:System.NotSupportedException">オペレーティング システムは Windows NT 以降ではありません。  
  
または
  
 ソケットがリモート ホストに接続されていません。</exception>
        <exception cref="T:System.IO.FileNotFoundException">ファイル <paramref name="fileName" /> が見つかりませんでした。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendTo">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendTo (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendTo (buffer, offset, size, socket_flags, remote_end, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">送信するデータを格納する <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">データ送信を開始する、<paramref name="buffer" /> 内の、インデックス番号が 0 から始まる位置。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="socket_flags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP">リモート デバイスを表す <see cref="T:System.Net.EndPoint" />。</param>
        <param name="remote_end">リモート デバイスを表す <see cref="T:System.Net.EndPoint" />。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求のステータス情報を格納するオブジェクト。</param>
        <summary>特定のリモート ホストにデータを非同期的に送信します。</summary>
        <returns>非同期の送信を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Net.Sockets.Socket.BeginSendTo%2A>は、 `remoteEP`パラメーターで指定されたリモートホストに対して非同期の送信操作を開始します。 メソッドを<xref:System.Net.Sockets.Socket.BeginSendTo%2A>呼び出すと、別の実行スレッド内でデータを送信できるようになります。 コネクションレスプロトコルを想定し<xref:System.Net.Sockets.Socket.BeginSendTo%2A>ていますが、コネクションレスプロトコルと接続指向プロトコルの両方で動作します。  
  
 <xref:System.AsyncCallback>デリゲートを実装するコールバックメソッドを作成し、その名前<xref:System.Net.Sockets.Socket.BeginSendTo%2A>をメソッドに渡すことができます。 これを行うには、少なくとも、 `state`通信に使用される接続さ<xref:System.Net.Sockets.Socket>れたまたは既定値がパラメーターに含まれている必要があります。 コールバックでより多くの情報が必要な場合は、 <xref:System.Net.Sockets.Socket>を保持する小さいクラスと、その他の必要な情報を作成できます。 パラメーター`state`を使用して、このクラス<xref:System.Net.Sockets.Socket.BeginSendTo%2A>のインスタンスをメソッドに渡します。  
  
 コールバックメソッドは、メソッド<xref:System.Net.Sockets.Socket.EndSendTo%2A>を呼び出す必要があります。 アプリケーションがを呼び<xref:System.Net.Sockets.Socket.BeginSendTo%2A>出すと、システムは別のスレッドを使用して指定されたコールバックメソッド<xref:System.Net.Sockets.Socket.EndSendTo%2A>を実行<xref:System.Net.Sockets.Socket>し、が要求したバイト数を送信するか、例外をスローするまでブロックします。 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>メソッドを呼び出した後に元のスレッドがブロックされるようにする<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>には、メソッドを使用します。 元のスレッドの実行を継続する場合は、コールバックメソッドの T:System.Threading.ManualResetEvent に対して Set メソッドを呼び出します。 コールバックメソッドの記述の詳細については[、「コールバックメソッドとしてのデリゲートのマーシャリング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)」を参照してください。  
  
 接続指向プロトコルを使用している場合は<xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Accept%2A>、最初に、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、、 <xref:System.Net.Sockets.SocketException>のいずれか<xref:System.Net.Sockets.Socket.BeginAccept%2A>のメソッドを<xref:System.Net.Sockets.Socket.BeginSendTo%2A>呼び出す必要があります。それ以外の場合は、がスローされます。 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>は`remoteEP` <xref:System.Net.Sockets.Socket.Connect%2A>、パラメーターを無視し、、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、 <xref:System.Net.EndPoint> <xref:System.Net.Sockets.Socket.Accept%2A>、または<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドで確立されたにデータを送信します。  
  
 コネクションレスプロトコルを使用している場合は、を呼び出す<xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.SendTo%2A>前に、メソッドまたは<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドを使用して既定のリモートホストを確立する必要はありません。 この操作は、 <xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドを呼び出す場合にのみ必要です。 <xref:System.Net.Sockets.Socket.Connect%2A>を呼び出す<xref:System.Net.Sockets.Socket.BeginConnect%2A> 前にまたはメソッドを呼び出した場合、パラメーターは、その送信操作に対してのみ、指定された既定のリモートホストをオーバーライドします。<xref:System.Net.Sockets.Socket.SendTo%2A> `remoteEP` また、 <xref:System.Net.Sockets.Socket.Bind%2A>メソッドを呼び出す必要はありません。 この場合、基になるサービスプロバイダーによって、最も適切なローカルネットワークアドレスとポート番号が割り当てられます。 基になるサービスプロバイダーで空きポートを選択する場合は、ポート番号を0にします。 割り当てられたローカルネットワークアドレスとポート番号を識別する必要がある場合は<xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 、 <xref:System.Net.Sockets.Socket.EndSendTo%2A>メソッドが正常に完了した後でプロパティを使用できます。  
  
 ブロードキャストアドレスにデータを送信する場合は、最初に<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドを呼び出し、ソケットオプションをに<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>設定する必要があります。 -バッファーのサイズが、基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要もあります。 この場合、データグラムは送信<xref:System.Net.Sockets.Socket.EndSendTo%2A>されず、が<xref:System.Net.Sockets.SocketException>スローされます。  
  
 パラメーターとして<xref:System.Net.Sockets.SocketFlags.DontRoute>フラグを指定した場合、送信するデータはルーティングされません。 `socketflags`  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
> [!NOTE]
>  非同期<xref:System.Net.Sockets.Socket>メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。 特定のコンテキスト (特定の非同期<xref:System.Net.Sockets.Socket>メソッド、 <xref:System.Net.Sockets.Socket>特定のインスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。  
  
   
  
## Examples  
 次のコード例では、指定したリモートホストにデータを非同期的に送信します。  
  
 [!code-cpp[Socket_Async_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Async_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Async_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> が <see langword="null" /> です。  
  
- または - 
 <paramref name="remoteEP" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> が 0 未満です。  
  
- または - 
 <paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  
  
- または - 
 <paramref name="size" /> が 0 未満です。  
  
- または - 
 <paramref name="size" /> が、 <paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタックの上位にある呼び出し元が、要求された操作のアクセス許可を保持していません。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">コールバック メソッドとしてのデリゲートのマーシャ リング</related>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public void Bind (System.Net.EndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Bind(class System.Net.EndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Bind (localEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Bind(System::Net::EndPoint ^ localEP);" />
      <MemberSignature Language="F#" Value="member this.Bind : System.Net.EndPoint -&gt; unit" Usage="socket.Bind localEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP"><see cref="T:System.Net.Sockets.Socket" /> に関連付けるローカル <see cref="T:System.Net.EndPoint" />。</param>
        <summary><see cref="T:System.Net.Sockets.Socket" /> をローカル エンドポイントと関連付けます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 特定の<xref:System.Net.Sockets.Socket.Bind%2A>ローカルエンドポイントを使用する必要がある場合は、メソッドを使用します。 メソッド<xref:System.Net.Sockets.Socket.Listen%2A>を呼び出す<xref:System.Net.Sockets.Socket.Bind%2A>前に、を呼び出す必要があります。 特定のローカルエンドポイントを<xref:System.Net.Sockets.Socket.Bind%2A>使用する必要<xref:System.Net.Sockets.Socket.Connect%2A>がない限り、メソッドを使用する前にを呼び出す必要はありません。 このメソッドは、 <xref:System.Net.Sockets.Socket.Bind%2A>コネクションレスプロトコルと接続指向プロトコルの両方で使用できます。  
  
 を呼び出す<xref:System.Net.Sockets.Socket.Bind%2A>前に、まず、データを<xref:System.Net.IPEndPoint>通信するローカルのを作成する必要があります。 どのローカルアドレスが割り当てられてもかまわない場合は、アドレス<xref:System.Net.IPEndPoint>パラメーター <xref:System.Net.IPAddress.Any?displayProperty=nameWithType>としてを使用してを作成すると、基になるサービスプロバイダーによって最も適切なネットワークアドレスが割り当てられます。 これは、複数のネットワークインターフェイスがある場合に、アプリケーションの簡素化に役立つ可能性があります。 使用されるローカルポートを気にしない場合は、ポート番号<xref:System.Net.IPEndPoint>として0を使用してを作成できます。 この場合、サービスプロバイダーは1024と5000の間の使用可能なポート番号を割り当てます。  
  
 上記の方法を使用する場合は、 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>を呼び出すことによって、どのローカルネットワークアドレスとポート番号が割り当てられているかを調べることができます。 接続指向プロトコルを使用している場合、 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> <xref:System.Net.Sockets.Socket.Connect%2A>は、メソッドまたは<xref:System.Net.Sockets.Socket.EndConnect%2A>メソッドを呼び出した後に、ローカルに割り当てられたネットワークアドレスを返しません。 コネクションレスプロトコルを使用している場合は、送信または受信が完了するまで、この情報にアクセスすることはできません。  
  
 UDP ソケットが受信パケット<xref:System.Net.Sockets.Socket.SetSocketOption%2A>のインターフェイス情報を受け取る場合は、メソッドを呼び出し<xref:System.Net.Sockets.Socket.Bind%2A>た直後に socket オプションをに<xref:System.Net.Sockets.SocketOptionName.PacketInformation>設定して、メソッドを明示的に呼び出す必要があります。  
  
> [!NOTE]
>  マルチキャストデータグラムを受信する場合は、マルチキャストポート<xref:System.Net.Sockets.Socket.Bind%2A>番号を指定してメソッドを呼び出す必要があります。  
  
> [!NOTE]
>  メソッドを使用し<xref:System.Net.Sockets.Socket.Bind%2A>て、コネクションレスのデータグラムを受信する場合は、メソッドを呼び出す必要があります。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>  
  
> [!NOTE]
>  メソッドの<xref:System.Net.Sockets.SocketException> <xref:System.Net.Sockets.Socket.Bind%2A>呼び出し時にを受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では<xref:System.Net.Sockets.Socket> 、指定したローカルエンドポイントを使用してをバインドします。  
  
 [!code-cpp[Classic Socket.Bind Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Bind Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Bind Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Bind Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Bind Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Bind Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="localEP" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタックの上位にある呼び出し元が、要求された操作のアクセス許可を保持していません。</exception>
        <permission cref="T:System.Net.SocketPermission">によっ<paramref name="localEP" />て定義されたホストからの接続を受け入れる場合。 関連付けられた列挙型:<see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.Net.IPAddress" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Blocking">
      <MemberSignature Language="C#" Value="public bool Blocking { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Blocking" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Blocking" />
      <MemberSignature Language="VB.NET" Value="Public Property Blocking As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Blocking { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Blocking : bool with get, set" Usage="System.Net.Sockets.Socket.Blocking" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> がブロッキング モードかどうかを示す値を取得または設定します。</summary>
        <value><see cref="T:System.Net.Sockets.Socket" /> がブロックする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティ<xref:System.Net.Sockets.Socket.Blocking%2A>は、 <xref:System.Net.Sockets.Socket>がブロッキングモードであるかどうかを示します。  
  
 ブロックモードで、すぐには完了しないメソッド呼び出しを行う場合、要求された操作が完了するまで、アプリケーションは実行をブロックします。 要求された操作が完了していなくても実行を続行する<xref:System.Net.Sockets.Socket.Blocking%2A>場合は`false`、プロパティをに変更します。 プロパティ<xref:System.Net.Sockets.Socket.Blocking%2A>は、非同期メソッドには影響しません。 非同期的にデータを送受信し、実行をブロックする場合は、 <xref:System.Threading.ManualResetEvent>クラスを使用します。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="CancelConnectAsync">
      <MemberSignature Language="C#" Value="public static void CancelConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelConnectAsync (e As SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member CancelConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; unit" Usage="System.Net.Sockets.Socket.CancelConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" /> メソッドの 1 つを呼び出してリモート ホストへの接続を要求するために使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</param>
        <summary>リモート ホスト接続への非同期要求を取り消します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Net.Sockets.Socket.CancelConnectAsync%2A>は、リモートホスト接続の非同期要求をキャンセルします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="e" /> パラメーターおよび <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> を null 値にすることはできません。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタックの上位にある呼び出し元が、要求された操作のアクセス許可を保持していません。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Close">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> 接続を閉じ、関連付けられたすべてのリソースを解放します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="socket.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> 接続を閉じ、関連付けられたすべてのリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Net.Sockets.Socket.Close%2A>は、リモートホスト接続を閉じ、に関連付けられているすべて<xref:System.Net.Sockets.Socket>のマネージリソースとアンマネージリソースを解放します。 終了時に、 <xref:System.Net.Sockets.Socket.Connected%2A>プロパティがに`false`設定されます。  
  
 接続指向プロトコルの場合は、 <xref:System.Net.Sockets.Socket.Shutdown%2A> <xref:System.Net.Sockets.Socket.Close%2A>メソッドを呼び出す前にを呼び出すことをお勧めします。 これにより、接続されたソケットが閉じられる前に、すべてのデータが送信され、受信されます。  
  
 を呼び<xref:System.Net.Sockets.Socket.Close%2A>出さず<xref:System.Net.Sockets.Socket.Shutdown%2A>にを呼び出す必要がある場合は、 <xref:System.Net.Sockets.Socket>オプションをに`false`設定<xref:System.Net.Sockets.SocketOptionName.DontLinger>し、タイムアウト間隔をゼロ以外に指定することにより、送信転送用のキューに置かれたデータが送信されるようにすることができます。 <xref:System.Net.Sockets.Socket.Close%2A>は、このデータが送信されるか、指定されたタイムアウトが経過するまでブロックします。 をに<xref:System.Net.Sockets.SocketOptionName.DontLinger> `false`設定し、タイムアウト間隔をゼロに指定すると<xref:System.Net.Sockets.Socket.Close%2A> 、によって接続が解放され、キューに置かれた送信データが自動的に破棄されます。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketOptionName.DontLinger>ソケットオプションをに`false`設定するには<xref:System.Net.Sockets.LingerOption>、を作成し、enabled プロパティ`true`をに設定し<xref:System.Net.Sockets.LingerOption.LingerTime%2A> 、プロパティを目的のタイムアウト期間に設定します。 これ<xref:System.Net.Sockets.LingerOption>を<xref:System.Net.Sockets.SocketOptionName.DontLinger> socket オプションと共に使用して<xref:System.Net.Sockets.Socket.SetSocketOption%2A> 、メソッドを呼び出します。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 を<xref:System.Net.Sockets.Socket>閉じるコード例を次に示します。  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close (timeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close(int timeout);" />
      <MemberSignature Language="F#" Value="member this.Close : int -&gt; unit" Usage="socket.Close timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="timeout">最大 <paramref name="timeout" /> 秒まで待ってから残りのデータを送信し、ソケットを閉じます。</param>
        <summary><see cref="T:System.Net.Sockets.Socket" /> 接続を閉じ、すべての関連付けられているリソースを指定したタイムアウトで解放して、キューに置かれたデータの送信を許可します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Net.Sockets.Socket.Close%2A>は、リモートホスト接続を閉じ、に関連付けられているすべて<xref:System.Net.Sockets.Socket>のマネージリソースとアンマネージリソースを解放します。 終了時に、 <xref:System.Net.Sockets.Socket.Connected%2A>プロパティがに`false`設定されます。  
  
 接続指向プロトコルの場合は、を呼び出す<xref:System.Net.Sockets.Socket.Shutdown%2A> <xref:System.Net.Sockets.Socket.Close%2A>前にを呼び出すことをお勧めします。 これにより、接続されたソケットが閉じられる前に、すべてのデータが送信され、受信されます。  
  
 <xref:System.Net.Sockets.Socket.Close%2A>を呼び出さず<xref:System.Net.Sockets.Socket.Shutdown%2A>にを呼び出す必要がある場合は、 <xref:System.Net.Sockets.SocketOptionName.DontLinger>オプションをに`false`設定し、タイムアウト間隔をゼロ以外に指定することにより、送信転送用のキューに置かれたデータが送信されるようにすることができます。 <xref:System.Net.Sockets.Socket.Close%2A>は、このデータが送信されるか、指定されたタイムアウトが経過するまでブロックします。 をに<xref:System.Net.Sockets.SocketOptionName.DontLinger> `false`設定し、タイムアウト間隔をゼロに指定すると<xref:System.Net.Sockets.Socket.Close%2A> 、によって接続が解放され、キューに置かれた送信データが自動的に破棄されます。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketOptionName.DontLinger>ソケットオプションをに`false`設定するには<xref:System.Net.Sockets.LingerOption>、を作成し、enabled プロパティ`true`をに設定し<xref:System.Net.Sockets.LingerOption.LingerTime%2A> 、プロパティを目的のタイムアウト期間に設定します。 これ<xref:System.Net.Sockets.LingerOption>を<xref:System.Net.Sockets.SocketOptionName.DontLinger> socket オプションと共に使用して<xref:System.Net.Sockets.Socket.SetSocketOption%2A> 、メソッドを呼び出します。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 を<xref:System.Net.Sockets.Socket>閉じる方法を次のコード例に示します。  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>リモート ホストへの接続を確立します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (remoteEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.EndPoint -&gt; unit" Usage="socket.Connect remoteEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="remoteEP">リモート デバイスを表す <see cref="T:System.Net.EndPoint" />。</param>
        <summary>リモート ホストへの接続を確立します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 TCP などの接続指向プロトコルを使用している場合、メソッド<xref:System.Net.Sockets.Socket.Connect%2A>は、と指定された<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>リモートエンドポイントとの間のネットワーク接続を同期的に確立します。 コネクションレスプロトコルを使用している<xref:System.Net.Sockets.Socket.Connect%2A>場合は、によって既定のリモートホストが確立されます。 を呼び出し<xref:System.Net.Sockets.Socket.Connect%2A>た後、 <xref:System.Net.Sockets.Socket.Send%2A>メソッドを使用してリモートデバイスにデータを送信したり、 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドを使用してリモートデバイスからデータを受信したりすることができます。  
  
 UDP などのコネクションレスプロトコルを使用している場合は、データを送受信<xref:System.Net.Sockets.Socket.Connect%2A>する前にを呼び出す必要はありません。 <xref:System.Net.Sockets.Socket.SendTo%2A> および<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>を使用して、リモートホストと同期的に通信することができます。 を呼び出す<xref:System.Net.Sockets.Socket.Connect%2A>と、指定された既定以外のアドレスから到着したデータグラムはすべて破棄されます。 既定のリモートホストをブロードキャストアドレスに設定する<xref:System.Net.Sockets.Socket.SetSocketOption%2A>場合は<xref:System.Net.Sockets.Socket.Connect%2A> 、最初にメソッドを呼び出し、ソケットオプションをに<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>設定する必要があり<xref:System.Net.Sockets.SocketException>ます。これを行わないと、がスローされます。 を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
 を呼び出す<xref:System.Net.Sockets.Socket.Blocking%2A> <xref:System.Net.Sockets.Socket.Connect%2A> 前にプロパティ`false`をに明示的に設定しない限り、メソッドはブロックされます。 <xref:System.Net.Sockets.Socket.Connect%2A> TCP のような接続指向プロトコルを使用していて、ブロックを無効<xref:System.Net.Sockets.Socket.Connect%2A>にした<xref:System.Net.Sockets.SocketException>場合、は接続に時間がかかるため、をスローします。 コネクションレスプロトコルは、既定のリモートホストを確立するだけなので、例外をスローしません。 を使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>すると、特定のエラーコードを取得できます。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。 エラーによって WSAEWOULDBLOCK が返された場合、リモートホスト接続は接続指向<xref:System.Net.Sockets.Socket>で開始されていますが、まだ正常に完了していません。 メソッドを使用して、 <xref:System.Net.Sockets.Socket>が接続を終了したことを確認します。 <xref:System.Net.Sockets.Socket.Poll%2A>  
  
> [!NOTE]
>  接続指向プロトコルを使用していて、を呼び出す<xref:System.Net.Sockets.Socket.Bind%2A> <xref:System.Net.Sockets.Socket.Connect%2A>前にを呼び出さなかった場合は、基になるサービスプロバイダーによってローカルネットワークアドレスとポート番号が割り当てられます。 コネクションレスプロトコルを使用している場合、送信または受信操作が完了するまで、サービスプロバイダーはローカルネットワークアドレスとポート番号を割り当てません。 既定のリモートホストを変更する場合は、目的<xref:System.Net.Sockets.Socket.Connect%2A>のエンドポイントでもう一度を呼び出します。  
  
> [!NOTE]
>  ソケットが既に切断されている場合は、この方法を使用して接続を復元することはできません。 いずれかの非同期<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドを使用して再接続します。 これは、基になるプロバイダーの制限です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、リモートエンドポイントに接続し、接続を確認します。  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="remoteEP" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタックの上位にある呼び出し元が、要求された操作のアクセス許可を保持していません。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出すことでリッスン状態になっています。</exception>
        <permission cref="T:System.Net.SocketPermission">リモートホストに接続するために使用します。 関連付けられた列挙型:<see cref="F:System.Net.NetworkAccess.Connect" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.Blocking" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (address As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPAddress ^ address, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress * int -&gt; unit" Usage="socket.Connect (address, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">リモート ホストの IP アドレス。</param>
        <param name="port">リモート ホストのポート番号。</param>
        <summary>リモート ホストへの接続を確立します。 ホストは、IP アドレスとポート番号で指定されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 TCP などの接続指向プロトコルを使用している場合、メソッド<xref:System.Net.Sockets.Socket.Connect%2A>は、と指定された<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>リモートエンドポイントとの間のネットワーク接続を同期的に確立します。 コネクションレスプロトコルを使用している<xref:System.Net.Sockets.Socket.Connect%2A>場合は、によって既定のリモートホストが確立されます。 を呼び出す<xref:System.Net.Sockets.Socket.Connect%2A>と、 <xref:System.Net.Sockets.Socket.Send%2A>メソッドを使用してリモートデバイスにデータを送信したり、リモートデバイスから<xref:System.Net.Sockets.Socket.Receive%2A>メソッドを使用してデータを受信したりすることができます。  
  
 UDP などのコネクションレスプロトコルを使用している場合は、データを送受信<xref:System.Net.Sockets.Socket.Connect%2A>する前にを呼び出す必要はありません。 <xref:System.Net.Sockets.Socket.SendTo%2A> および<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>を使用して、リモートホストと同期的に通信することができます。 指定した以外<xref:System.Net.Sockets.Socket.Connect%2A>のアドレスから受信したデータグラムを呼び出すと、指定した既定値は破棄されます。 既定のリモートホストをブロードキャストアドレスに設定する<xref:System.Net.Sockets.Socket.SetSocketOption%2A>場合は<xref:System.Net.Sockets.Socket.Connect%2A> 、最初にメソッドを呼び出し、ソケットオプションをに<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>設定する必要があり<xref:System.Net.Sockets.SocketException>ます。これを行わないと、がスローされます。 を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A>を呼び出す<xref:System.Net.Sockets.Socket.Blocking%2A> `false` 前にプロパティをに明示的に設定しない限り、メソッドは<xref:System.Net.Sockets.Socket.Connect%2A>ブロックします。 TCP のような接続指向プロトコルを使用していて、ブロックを無効<xref:System.Net.Sockets.Socket.Connect%2A>にした<xref:System.Net.Sockets.SocketException>場合、は接続に時間がかかるため、をスローします。 コネクションレスプロトコルは、既定のリモートホストを確立するだけなので、例外をスローしません。 を使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>すると、特定のエラーコードを取得できます。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。 エラーによって WSAEWOULDBLOCK が返された場合、リモートホスト接続は接続指向<xref:System.Net.Sockets.Socket>で開始されていますが、まだ正常に完了していません。 メソッドを使用して、 <xref:System.Net.Sockets.Socket>が接続を終了したことを確認します。 <xref:System.Net.Sockets.Socket.Poll%2A>  
  
> [!NOTE]
>  接続指向プロトコルを使用していて、を呼び出す<xref:System.Net.Sockets.Socket.Bind%2A> <xref:System.Net.Sockets.Socket.Connect%2A>前にを呼び出さなかった場合は、基になるサービスプロバイダーによってローカルネットワークアドレスとポート番号が割り当てられます。 コネクションレスプロトコルを使用している場合、送信または受信操作が完了するまで、サービスプロバイダーはローカルネットワークアドレスとポート番号を割り当てません。 既定のリモートホストを変更する場合は、目的<xref:System.Net.Sockets.Socket.Connect%2A>のエンドポイントでもう一度を呼び出します。  
  
> [!NOTE]
>  ソケットが既に切断されている場合は、この方法を使用して接続を復元することはできません。 いずれかの非同期<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドを使用して再接続します。 これは、基になるプロバイダーの制限です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、リモートエンドポイントに接続し、接続を確認します。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#4)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="address" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">ポート番号が無効です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドは、<see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> または <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> ファミリのソケットで有効です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="address" /> の長さが 0 です。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出すことでリッスン状態になっています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress[] addresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress[] addresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (addresses As IPAddress(), port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress[] * int -&gt; unit" Usage="socket.Connect (addresses, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="addresses">リモート ホストの IP アドレス。</param>
        <param name="port">リモート ホストのポート番号。</param>
        <summary>リモート ホストへの接続を確立します。 ホストは、IP アドレスの配列とポート番号で指定されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、通常、1つのホスト<xref:System.Net.Dns.GetHostAddresses%2A>に対して複数の IP アドレスを返すことができるの呼び出しの直後に使用されます。 TCP などの接続指向プロトコルを使用している場合、メソッド<xref:System.Net.Sockets.Socket.Connect%2A>は、と指定された<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>リモートエンドポイントとの間のネットワーク接続を同期的に確立します。 コネクションレスプロトコルを使用している<xref:System.Net.Sockets.Socket.Connect%2A>場合は、によって既定のリモートホストが確立されます。 を呼び出す<xref:System.Net.Sockets.Socket.Connect%2A>と、 <xref:System.Net.Sockets.Socket.Send%2A>メソッドを使用してリモートデバイスにデータを送信したり、リモートデバイスから<xref:System.Net.Sockets.Socket.Receive%2A>メソッドを使用してデータを受信したりすることができます。  
  
 UDP などのコネクションレスプロトコルを使用している場合は、データを送受信<xref:System.Net.Sockets.Socket.Connect%2A>する前にを呼び出す必要はありません。 <xref:System.Net.Sockets.Socket.SendTo%2A> および<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>を使用して、リモートホストと同期的に通信することができます。 指定した以外<xref:System.Net.Sockets.Socket.Connect%2A>のアドレスから受信したデータグラムを呼び出すと、指定した既定値は破棄されます。 既定のリモートホストをブロードキャストアドレスに設定する<xref:System.Net.Sockets.Socket.SetSocketOption%2A>場合は<xref:System.Net.Sockets.Socket.Connect%2A> 、最初にメソッドを呼び出し、ソケットオプションをに<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>設定する必要があり<xref:System.Net.Sockets.SocketException>ます。これを行わないと、がスローされます。 を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A>を呼び出す<xref:System.Net.Sockets.Socket.Blocking%2A> `false` 前にプロパティをに明示的に設定しない限り、メソッドは<xref:System.Net.Sockets.Socket.Connect%2A>ブロックします。 TCP のような接続指向プロトコルを使用していて、ブロックを無効<xref:System.Net.Sockets.Socket.Connect%2A>にした<xref:System.Net.Sockets.SocketException>場合、は接続に時間がかかるため、をスローします。 コネクションレスプロトコルは、既定のリモートホストを確立するだけなので、例外をスローしません。 を使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>すると、特定のエラーコードを取得できます。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。 エラーによって WSAEWOULDBLOCK が返された場合、リモートホスト接続は接続指向<xref:System.Net.Sockets.Socket>で開始されていますが、まだ正常に完了していません。 メソッドを使用して、 <xref:System.Net.Sockets.Socket>が接続を終了したことを確認します。 <xref:System.Net.Sockets.Socket.Poll%2A>  
  
> [!NOTE]
>  接続指向プロトコルを使用していて、を呼び出す<xref:System.Net.Sockets.Socket.Bind%2A> <xref:System.Net.Sockets.Socket.Connect%2A>前にを呼び出さなかった場合は、基になるサービスプロバイダーによってローカルネットワークアドレスとポート番号が割り当てられます。 コネクションレスプロトコルを使用している場合、送信または受信操作が完了するまで、サービスプロバイダーはローカルネットワークアドレスとポート番号を割り当てません。 既定のリモートホストを変更する場合は、目的<xref:System.Net.Sockets.Socket.Connect%2A>のエンドポイントでもう一度を呼び出します。  
  
> [!NOTE]
>  ソケットが既に切断されている場合は、この方法を使用して接続を復元することはできません。 いずれかの非同期<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドを使用して再接続します。 これは、基になるプロバイダーの制限です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、リモートエンドポイントに接続し、接続を確認します。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#5)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="addresses" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">ポート番号が無効です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドは、<see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> または <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> ファミリのソケットで有効です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="address" /> の長さが 0 です。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出すことでリッスン状態になっています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string host, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string host, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (host As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::String ^ host, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : string * int -&gt; unit" Usage="socket.Connect (host, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="host">リモート ホストの名前。</param>
        <param name="port">リモート ホストのポート番号。</param>
        <summary>リモート ホストへの接続を確立します。 ホストはホスト名とポート番号で指定されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 TCP などの接続指向プロトコルを使用している場合、メソッド<xref:System.Net.Sockets.Socket.Connect%2A>は、と指定された<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>リモートホストの間のネットワーク接続を同期的に確立します。 コネクションレスプロトコルを使用している<xref:System.Net.Sockets.Socket.Connect%2A>場合は、によって既定のリモートホストが確立されます。 を呼び出す<xref:System.Net.Sockets.Socket.Connect%2A>と、 <xref:System.Net.Sockets.Socket.Send%2A>メソッドを使用してリモートデバイスにデータを送信したり、リモートデバイスから<xref:System.Net.Sockets.Socket.Receive%2A>メソッドを使用してデータを受信したりすることができます。  
  
 UDP などのコネクションレスプロトコルを使用している場合は、データを送受信<xref:System.Net.Sockets.Socket.Connect%2A>する前にを呼び出す必要はありません。 <xref:System.Net.Sockets.Socket.SendTo%2A> および<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>を使用して、リモートホストと同期的に通信することができます。 指定した以外<xref:System.Net.Sockets.Socket.Connect%2A>のアドレスから受信したデータグラムを呼び出すと、指定した既定値は破棄されます。 既定のリモートホストをブロードキャストアドレスに設定する<xref:System.Net.Sockets.Socket.SetSocketOption%2A>場合は<xref:System.Net.Sockets.Socket.Connect%2A> 、最初にメソッドを呼び出し、ソケットオプションをに<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>設定する必要があり<xref:System.Net.Sockets.SocketException>ます。これを行わないと、がスローされます。 を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A>を呼び出す<xref:System.Net.Sockets.Socket.Blocking%2A> `false` 前にプロパティをに明示的に設定しない限り、メソッドは<xref:System.Net.Sockets.Socket.Connect%2A>ブロックします。 TCP のような接続指向プロトコルを使用していて、ブロックを無効<xref:System.Net.Sockets.Socket.Connect%2A>にした<xref:System.Net.Sockets.SocketException>場合、は接続に時間がかかるため、をスローします。 コネクションレスプロトコルは、既定のリモートホストを確立するだけなので、例外をスローしません。 を使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>すると、特定のエラーコードを取得できます。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。 エラーによって WSAEWOULDBLOCK が返された場合、リモートホスト接続は接続指向<xref:System.Net.Sockets.Socket>で開始されていますが、まだ正常に完了していません。 メソッドを使用して、 <xref:System.Net.Sockets.Socket>が接続を終了したことを確認します。 <xref:System.Net.Sockets.Socket.Poll%2A>  
  
 Ipv6 を有効にし<xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29> 、メソッドを呼び出して、ipv6 と ipv4 の両方のアドレスに解決されるホストに接続する場合は、ipv4 アドレスの前に ipv6 アドレスへの接続が最初に試行されます。 ホストが IPv6 アドレスでリッスンしていない場合、接続の確立に時間がかかることがあります。  
  
> [!NOTE]
>  接続指向プロトコルを使用していて、を呼び出す<xref:System.Net.Sockets.Socket.Bind%2A> <xref:System.Net.Sockets.Socket.Connect%2A>前にを呼び出さなかった場合は、基になるサービスプロバイダーによってローカルネットワークアドレスとポート番号が割り当てられます。 コネクションレスプロトコルを使用している場合、送信または受信操作が完了するまで、サービスプロバイダーはローカルネットワークアドレスとポート番号を割り当てません。 既定のリモートホストを変更する場合は、目的<xref:System.Net.Sockets.Socket.Connect%2A>のエンドポイントでもう一度を呼び出します。  
  
> [!NOTE]
>  ソケットが既に切断されている場合は、この方法を使用して接続を復元することはできません。 いずれかの非同期<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドを使用して再接続します。 これは、基になるプロバイダーの制限です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、リモートエンドポイントに接続し、接続を確認します。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#6)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="host" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">ポート番号が無効です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドは、<see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> または <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> ファミリのソケットで有効です。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出すことでリッスン状態になっています。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>リモート ホストに接続する非同期要求を開始します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public bool ConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</param>
        <summary>リモート ホストに接続する非同期要求を開始します。</summary>
        <returns>I/O 操作が保留中の場合は <see langword="true" />。 操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。  
  
 I/O 操作が同期的に完了した場合は <see langword="false" />。 この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向プロトコルを使用している場合、メソッド<xref:System.Net.Sockets.Socket.ConnectAsync%2A>は、リモートホストへの接続に対する非同期要求を開始します。 コネクションレスプロトコルを使用している<xref:System.Net.Sockets.Socket.ConnectAsync%2A>場合は、によって既定のリモートホストが確立されます。  
  
 完了が通知されるようにするには、EventHandler\<SocketAsyncEventArgs > delegate を実装するコールバックメソッドを作成し、そのコールバックを<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>イベントにアタッチする必要があります。  
  
 呼び出し元は、接続<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>先のリモート<xref:System.Net.IPEndPoint>ホストのにプロパティを設定する必要があります。  
  
 呼び出し元は、 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> <xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッドを呼び出す前に、プロパティを任意のユーザー状態オブジェクトに設定できます。これにより、コールバックメソッドで情報を取得できるようになります。 コールバックが1つのオブジェクトよりも多くの情報を必要とする場合は、他の必要な状態情報をメンバーとして保持するために、小さなクラスを作成できます。  
  
 UDP などのコネクションレスプロトコルを使用している場合は、データを送受信<xref:System.Net.Sockets.Socket.ConnectAsync%2A>する前にを呼び出す必要はありません。 <xref:System.Net.Sockets.Socket.SendToAsync%2A> および<xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A>を使用して、リモートホストと通信することができます。 を呼び出す<xref:System.Net.Sockets.Socket.ConnectAsync%2A>と、指定された既定以外のアドレスから到着したデータグラムはすべて破棄されます。 既定のリモートホストを変更する場合は、目的の<xref:System.Net.Sockets.Socket.ConnectAsync%2A>エンドポイントを使用してメソッドを再度呼び出します。  
  
 既定のリモートホストをブロードキャストアドレスに設定する場合は、まずを呼び出し<xref:System.Net.Sockets.Socket.SetSocketOption%2A> 、にブロードキャストを`true`設定する必要があります。 この処理が行わ<xref:System.Net.Sockets.Socket.ConnectAsync%2A>れない場合、メソッドはを<xref:System.Net.Sockets.SocketException>スローします。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>オブジェクトの次のプロパティとイベントが必要です。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 必要に応じて、 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッドが成功した後に、ソケットでアトミックに送信されるバッファーを指定することもできます。 この場合、 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>プロパティは、送信するデータを格納するバッファーに設定する必要があります<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 。また、プロパティは、バッファーから送信するデータのバイト数に設定する必要があります。 接続が確立されると、このバッファーのデータが送信されます。  
  
 接続指向プロトコルを使用していて、を呼び出す<xref:System.Net.Sockets.Socket.Bind%2A> <xref:System.Net.Sockets.Socket.ConnectAsync%2A>前にを呼び出さない場合、基になるサービスプロバイダーによって、最も適切なローカルネットワークアドレスとポート番号が割り当てられます。  
  
 コネクションレスプロトコルを使用している場合、サービスプロバイダーは、メソッド<xref:System.Net.Sockets.Socket.SendAsync%2A>または<xref:System.Net.Sockets.Socket.ReceiveAsync%2A>メソッドを呼び出すまで、ローカルネットワークの IP アドレスとポート番号を割り当てません。  
  
 との<xref:System.Net.Sockets.Socket.ConnectAsync%2A>アドレス<xref:System.NotSupportedException> ファミリ<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>が同じアドレスファミリでない場合、メソッドはをスローします。 <xref:System.Net.Sockets.Socket>  
  
> [!NOTE]
>  このメソッドの呼び出し<xref:System.Net.Sockets.SocketException>時にを受け取った場合は<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 、プロパティを使用して特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">引数が有効ではありません。 この例外は、複数のバッファーが指定されているときに、<see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> プロパティが null 値ではない場合に発生します。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="e" /> パラメーターおよび <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> を null 値にすることはできません。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> がリッスンしているか、<paramref name="e" /> パラメーターで指定されている <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクトを使用してソケット操作が既に進行していました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows XP 以降が必要です。 この例外は、ローカル エンドポイントと <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> が同じアドレス ファミリではない場合にも発生します。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタックの上位にある呼び出し元が、要求された操作のアクセス許可を保持していません。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public static bool ConnectAsync (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType, System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ConnectAsync(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType, class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ConnectAsync(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType, System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member ConnectAsync : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType * System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="System.Net.Sockets.Socket.ConnectAsync (socketType, protocolType, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="socketType"><see cref="T:System.Net.Sockets.SocketType" /> 値のいずれか 1 つ。</param>
        <param name="protocolType"><see cref="T:System.Net.Sockets.ProtocolType" /> 値のいずれか 1 つ。</param>
        <param name="e">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</param>
        <summary>リモート ホストに接続する非同期要求を開始します。</summary>
        <returns>I/O 操作が保留中の場合は <see langword="true" />。 操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。  
  
 I/O 操作が同期的に完了した場合は <see langword="false" />。 この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向プロトコルを使用している場合は、M:System.Net.Sockets.Socket.ConnectAsync (SocketAsyncEventArgs) メソッドによって、の非同期要求が開始されます。このメソッドは、の非同期要求を開始します。リモートホストへの接続。 コネクションレスプロトコルを使用している<xref:System.Net.Sockets.Socket.ConnectAsync%2A>場合、は、パラメーター `socketType`と`protocolType`パラメーターで指定された既定のリモートホストを確立します。  
  
 完了が通知されるようにするには、EventHandler\<SocketAsyncEventArgs > delegate を実装するコールバックメソッドを作成し、そのコールバックを<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>イベントにアタッチする必要があります。  
  
 呼び出し元は、接続<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>先のリモート<xref:System.Net.IPEndPoint>ホストのにプロパティを設定する必要があります。  
  
 呼び出し元は、 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> <xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッドを呼び出す前に、プロパティを任意のユーザー状態オブジェクトに設定できます。これにより、コールバックメソッドで情報を取得できるようになります。 コールバックが1つのオブジェクトよりも多くの情報を必要とする場合は、他の必要な状態情報をメンバーとして保持するために、小さなクラスを作成できます。  
  
 UDP などのコネクションレスプロトコルを使用している場合は、データを送受信<xref:System.Net.Sockets.Socket.ConnectAsync%2A>する前にを呼び出す必要はありません。 <xref:System.Net.Sockets.Socket.SendToAsync%2A> および<xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A>を使用して、リモートホストと通信することができます。 を呼び出す<xref:System.Net.Sockets.Socket.ConnectAsync%2A>と、指定された既定以外のアドレスから到着したデータグラムはすべて破棄されます。 既定のリモートホストを変更する場合は、目的の<xref:System.Net.Sockets.Socket.ConnectAsync%2A>エンドポイントを使用してメソッドを再度呼び出します。  
  
 既定のリモートホストをブロードキャストアドレスに設定する場合は、まずを呼び出し<xref:System.Net.Sockets.Socket.SetSocketOption%2A> 、にブロードキャストを`true`設定する必要があります。 この処理が行わ<xref:System.Net.Sockets.Socket.ConnectAsync%2A>れない場合、メソッドはを<xref:System.Net.Sockets.SocketException>スローします。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>オブジェクトの次のプロパティとイベントが必要です。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 必要に応じて、 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッドが成功した後に、ソケットでアトミックに送信されるバッファーを指定することもできます。 この場合、 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>プロパティは、送信するデータを格納するバッファーに設定する必要があります<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 。また、プロパティは、バッファーから送信するデータのバイト数に設定する必要があります。 接続が確立されると、このバッファーのデータが送信されます。  
  
 接続指向プロトコルを使用していて、を呼び出す<xref:System.Net.Sockets.Socket.Bind%2A> <xref:System.Net.Sockets.Socket.ConnectAsync%2A>前にを呼び出さない場合、基になるサービスプロバイダーによって、最も適切なローカルネットワークアドレスとポート番号が割り当てられます。  
  
 コネクションレスプロトコルを使用している場合、サービスプロバイダーは、メソッド<xref:System.Net.Sockets.Socket.SendAsync%2A>または<xref:System.Net.Sockets.Socket.ReceiveAsync%2A>メソッドを呼び出すまで、ローカルネットワークの IP アドレスとポート番号を割り当てません。  
  
 との<xref:System.Net.Sockets.Socket.ConnectAsync%2A>アドレス<xref:System.NotSupportedException> ファミリ<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>が同じアドレスファミリでない場合、メソッドはをスローします。 <xref:System.Net.Sockets.Socket>  
  
> [!NOTE]
>  このメソッドの呼び出し<xref:System.Net.Sockets.SocketException>時にを受け取った場合は<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 、プロパティを使用して特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">引数が有効ではありません。 この例外は、複数のバッファーが指定されているときに、<see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> プロパティが null 値ではない場合に発生します。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="e" /> パラメーターおよび <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> を null 値にすることはできません。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> がリッスンしているか、<paramref name="e" /> パラメーターで指定されている <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクトを使用してソケット操作が既に進行していました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows XP 以降が必要です。 この例外は、ローカル エンドポイントと <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> が同じアドレス ファミリではない場合にも発生します。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタックの上位にある呼び出し元が、要求された操作のアクセス許可を保持していません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Connected">
      <MemberSignature Language="C#" Value="public bool Connected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Connected" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Connected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Connected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Connected : bool" Usage="System.Net.Sockets.Socket.Connected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最後に実行された <see cref="Overload:System.Net.Sockets.Socket.Send" /> 操作または <see cref="Overload:System.Net.Sockets.Socket.Receive" /> 操作の時点で、<see cref="T:System.Net.Sockets.Socket" /> がリモート ホストに接続されていたかどうかを示す値を取得します。</summary>
        <value>最後に実行された操作の時点で、<see cref="T:System.Net.Sockets.Socket" /> がリモート リソースに接続されていた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティ`Connected`は、 <xref:System.Net.Sockets.Socket>最後の i/o 操作時のの接続状態を取得します。 が返さ`false`れた場合<xref:System.Net.Sockets.Socket> 、が接続されていないか、接続されていません。  
  
 <xref:System.Net.Sockets.Socket.Connected%2A>プロパティの値は、最新の操作での接続の状態を反映します。 接続の現在の状態を確認する必要がある場合は、非ブロッキングのゼロバイトの送信呼び出しを行います。 呼び出しが正常に返された場合、または WAEWOULDBLOCK エラーコード (10035) をスローした場合、ソケットはまだ接続されています。それ以外の場合、ソケットは接続されなくなります。  
  
 ユーザーデータグラムプロトコル<xref:System.Net.Sockets.Socket.Connect%2A> (udp) ソケットでを呼び出すと、プロパティ<xref:System.Net.Sockets.Socket.Connected%2A>は常に`true`を返します。ただし、この操作では、udp の固有のコネクションレス特性は変更されません。  
  
   
  
## Examples  
 次のコード例では、リモートエンドポイントに接続<xref:System.Net.Sockets.Socket.Connected%2A>し、プロパティをチェックして、接続の現在の状態を確認します。  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public void Disconnect (bool reuseSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Disconnect(bool reuseSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Disconnect (reuseSocket As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Disconnect(bool reuseSocket);" />
      <MemberSignature Language="F#" Value="member this.Disconnect : bool -&gt; unit" Usage="socket.Disconnect reuseSocket" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">現在の接続の終了後、このソケットが再利用できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>ソケット接続を閉じ、ソケットを再利用できるようにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向プロトコルを使用している場合は、このメソッドを使用してソケットを閉じることができます。 このメソッドは接続を終了し、 <xref:System.Net.Sockets.Socket.Connected%2A>プロパティを`false`に設定します。 ただし、が`reuseSocket` `true`の場合は、ソケットを再利用できます。  
  
 ソケットが閉じられる前にすべてのデータが送受信されるようにするに<xref:System.Net.Sockets.Socket.Shutdown%2A>は、 <xref:System.Net.Sockets.Socket.Disconnect%2A>メソッドを呼び出す前にを呼び出す必要があります。  
  
 を呼び<xref:System.Net.Sockets.Socket.Disconnect%2A>出さず<xref:System.Net.Sockets.Socket.Shutdown%2A>にを呼び出す必要がある場合は<xref:System.Net.Sockets.SocketOptionName.DontLinger> 、 <xref:System.Net.Sockets.Socket>オプション`false`をに設定し、ゼロ以外のタイムアウト間隔を指定して、送信用のキューに格納されたデータが送信されるようにすることができます。 <xref:System.Net.Sockets.Socket.Disconnect%2A>は、データが送信されるか、指定されたタイムアウトが経過するまでブロックします。 をに<xref:System.Net.Sockets.SocketOptionName.DontLinger> `false`設定し、タイムアウト間隔をゼロに指定すると<xref:System.Net.Sockets.Socket.Close%2A> 、によって接続が解放され、キューに置かれた送信データが自動的に破棄されます。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、同期通信用のソケットを作成し、いくつかのデータをリモートホストに送信します。 次に、 <xref:System.Net.Sockets.Socket.Shutdown%2A>を呼び出して、送信および受信アクティビティを停止<xref:System.Net.Sockets.Socket.Disconnect%2A>し、を呼び出してソケット接続を閉じます。  
  
 [!code-cpp[Nclsocketenhancements#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#12)]
 [!code-csharp[Nclsocketenhancements#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">このメソッドは、Windows 2000 以前でのみサポートされます。それ以外の場合は、例外がスローされます。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="DisconnectAsync">
      <MemberSignature Language="C#" Value="public bool DisconnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DisconnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisconnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DisconnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.DisconnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.DisconnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="e">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</param>
        <summary>リモート エンドポイントからの切断の非同期要求を開始します。</summary>
        <returns>I/O 操作が保留中の場合は <see langword="true" />。 操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。  
  
 I/O 操作が同期的に完了した場合は <see langword="false" />。 この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向プロトコルを使用する場合、 <xref:System.Net.Sockets.Socket.DisconnectAsync%2A>メソッドを呼び出すと、リモートエンドポイントからの切断が要求されます。 パラメーターで`true` <xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType> をに設定した場合は、ソケットを再利用できます`e` 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="e" /> パラメーターを null 値にすることはできません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="e" /> パラメーターに指定された <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクトを使用してソケット操作が既に進行していました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows XP 以降が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> クラスの現在のインスタンスによって使用されているすべてのリソースを解放します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="socket.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> クラスの現在のインスタンスによって使用されているすべてのリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> を使い終わったら、`Dispose`を呼び出します。 `Dispose`メソッドによって、<xref:System.Net.Sockets.Socket> は使用不可の状態になります。 `Dispose`呼び出し後は、<xref:System.Net.Sockets.Socket>によって占有されていたメモリをガベージ コレクターがクリアできるよう、<xref:System.Net.Sockets.Socket> へのすべての参照を解放する必要があります。  
  
 詳細については、[アンマネージ リソースのクリーンアップ](~/docs/standard/garbage-collection/unmanaged.md)および[Dispose メソッドの実装](~/docs/standard/garbage-collection/implementing-dispose.md)を参照してください。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.Socket>への最後の参照を解放する前に、必ず`Dispose`を呼び出してください。 そうしないと、ガベージ コレクターが <xref:System.Net.Sockets.Socket> オブジェクトの `Finalize` メソッドを呼び出すまで、使用されているリソースは解放されません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="socket.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">マネージド リソースとアンマネージド リソースの両方を解放する場合は <see langword="true" />。アンマネージド リソースだけを解放する場合は <see langword="false" />。</param>
        <summary><see cref="T:System.Net.Sockets.Socket" /> が使用しているアンマネージド リソースを解放します。オプションでマネージド リソースも破棄します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、パブリック`Dispose()`メソッド<xref:System.Object.Finalize%2A>とメソッドによって呼び出されます。 `Dispose()``disposing`パラメーターをに`Dispose(Boolean)` 設定して、保護されたメソッド`true`を呼び出します。 <xref:System.Object.Finalize%2A>をに`disposing` `Dispose` 設定してを呼び出します`false`。  
  
 `disposing` パラメーターが `true` の場合、このメソッドは、この <xref:System.Net.Sockets.Socket> が参照しているすべてのマネージド オブジェクトによって保持されているリソースをすべて解放します。 このメソッドは、参照される各オブジェクトの `Dispose()` メソッドを呼び出します。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" /> は、他のオブジェクトから複数回呼び出すことができます。 <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" /> をオーバーライドする場合は、以前に <see langword="Dispose" /> を呼び出したときに破棄されたオブジェクトを参照しないように注意する必要があります。 を実装<see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />する方法の詳細については、「 [Dispose メソッドの実装](~/docs/standard/garbage-collection/implementing-dispose.md)」を参照してください。  
  
<see langword="Dispose" /> および<see cref="M:System.Object.Finalize" />の詳細については、「[アンマネージリソースのクリーンアップ](~/docs/standard/garbage-collection/unmanaged.md)」と「 [Finalize メソッドのオーバーライド](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100))」を参照してください。</para></block>
      </Docs>
    </Member>
    <Member MemberName="DontFragment">
      <MemberSignature Language="C#" Value="public bool DontFragment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DontFragment" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DontFragment" />
      <MemberSignature Language="VB.NET" Value="Public Property DontFragment As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DontFragment { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DontFragment : bool with get, set" Usage="System.Net.Sockets.Socket.DontFragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> でインターネット プロトコル (IP) データグラムの断片化を許可するかどうかを指定する <see cref="T:System.Boolean" /> 値を、取得または設定します。</summary>
        <value><see cref="T:System.Net.Sockets.Socket" /> でデータグラムの断片化を許可する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 データグラムのサイズが、転送メディアの最大転送単位 (MTU) を超えると、断片化が必要になります。 送信ホスト (すべてのインターネットプロトコルバージョン) または中間ルーター (インターネットプロトコルバージョン4のみ) によって、データグラムが断片化される場合があります。 データグラムをフラグメント<xref:System.Net.Sockets.Socket.DontFragment%2A>化する必要があり、オプションが設定されている場合、データグラムは破棄され、インターネット制御メッセージプロトコル (ICMP) のエラーメッセージがデータグラムの送信者に送り返されます。  
  
 伝送制御プロトコル (TCP) ソケットでこのプロパティを設定しても効果はありません。  
  
   
  
## Examples  
 次のコード例は、 <xref:System.Net.Sockets.Socket.DontFragment%2A>プロパティの使用方法を示しています。  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">このプロパティは、<see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> ファミリまたは <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> ファミリのソケットに対してだけ設定できます。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="DualMode">
      <MemberSignature Language="C#" Value="public bool DualMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DualMode" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DualMode" />
      <MemberSignature Language="VB.NET" Value="Public Property DualMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DualMode { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DualMode : bool with get, set" Usage="System.Net.Sockets.Socket.DualMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Boolean" /> が IPv4 と IPv6 の両方に使用されるデュアル モード ソケットであるかどうか指定する <see cref="T:System.Net.Sockets.Socket" /> 値を取得または設定します。</summary>
        <value><see cref="T:System.Net.Sockets.Socket" /> がデュアルモードのソケットの場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DuplicateAndClose">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketInformation DuplicateAndClose (int targetProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Net.Sockets.SocketInformation DuplicateAndClose(int32 targetProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DuplicateAndClose (targetProcessId As Integer) As SocketInformation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::SocketInformation DuplicateAndClose(int targetProcessId);" />
      <MemberSignature Language="F#" Value="member this.DuplicateAndClose : int -&gt; System.Net.Sockets.SocketInformation" Usage="socket.DuplicateAndClose targetProcessId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoLimitation("We do not support passing sockets across processes, we merely allow this API to pass the socket across AppDomains")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketInformation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetProcessId" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="targetProcessId">ソケット参照の複製が作成されるターゲット プロセスの ID。</param>
        <summary>ターゲット プロセスのソケット参照を複製してこのプロセスのソケットを閉じます。</summary>
        <returns>ターゲット プロセスに渡されるソケット参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ターゲットプロセスでは、 <xref:System.Net.Sockets.Socket.%23ctor%2A>を使用して、重複するソケットインスタンスを作成する必要があります。  
  
 各呼び出しの引数<xref:System.Net.Sockets.Socket.%23ctor%2A>と同じバイト配列を使用してコンストラクターを複数回呼び出す場合は、基になる同じ<xref:System.Net.Sockets.Socket>ソケットを使用して複数のマネージインスタンスを作成します。 この方法は推奨されません。  
  
 ソケットを作成するプロセスで非同期メソッド (<xref:System.Net.Sockets.Socket.BeginReceive%2A>または<xref:System.Net.Sockets.Socket.BeginSend%2A>) が使用されている場合は、まず、この<xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A>プロパティを true に設定する必要があります。そうしないと、ソケットは作成プロセスの完了ポートにバインドされるため、<xref:System.ArgumentNullException>ターゲットプロセスでスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="targetProcessID" /> が有効なプロセス ID ではありません。 
または 
ソケット参照の複製に失敗しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="EnableBroadcast">
      <MemberSignature Language="C#" Value="public bool EnableBroadcast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableBroadcast" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableBroadcast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableBroadcast { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableBroadcast : bool with get, set" Usage="System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> でブロードキャスト パケットの送受信を許可するかどうかを指定する <see cref="T:System.Boolean" /> 値を取得または設定します。</summary>
        <value><see cref="T:System.Net.Sockets.Socket" /> でブロードキャスト パケットを許可する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ブロードキャストは特定のサブネットに限定され、ユーザーデータグラムプロトコル (UDP) を使用する必要があります。インターネットプロトコルバージョン4では、パケットを255.255.255.255 に送信してローカルサブネットにブロードキャストできます。または、宛先ブロードキャストアドレスを使用することもできます。これは、ホスト部分ですべてのビットが設定されたインターネットプロトコル (IP) アドレスのネットワーク部分です。 たとえば、IP アドレスが 192.168.1.40 (クラス C のアドレスで、ネットマスクが255.255.255.0 の場合) の場合、ネットワークの部分が最初の3つのオクテットで、ホストの部分が最後のオクテットである場合、転送先のブロードキャストアドレスは192.168.1.255 になります。  
  
 伝送制御プロトコル (TCP) ソケットでこのプロパティを設定しても効果はありません。  
  
   
  
## Examples  
 次のコード例は、 <xref:System.Net.Sockets.Socket.EnableBroadcast%2A>プロパティの使用方法を示しています。  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">このオプションは、データグラム ソケットに対してだけ有効です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>受信接続の試行を非同期的に受け入れます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept :  * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">転送されたバイト数を格納する <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="asyncResult">この非同期操作のステータス情報だけではなく、任意のユーザー定義のデータも格納する <see cref="T:System.IAsyncResult" /> オブジェクト。</param>
        <summary>受信接続の試行を非同期的に受け入れ、新しい <see cref="T:System.Net.Sockets.Socket" /> オブジェクトを作成してリモート ホスト通信を処理します。 このメソッドは、転送される初期データを格納するバッファーを返します。</summary>
        <returns>リモート ホストとの通信を処理する <see cref="T:System.Net.Sockets.Socket" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>へ<xref:System.Net.Sockets.Socket.BeginAccept%2A>の呼び出しを完了します。 を呼び出す<xref:System.Net.Sockets.Socket.BeginAccept%2A>前に、 <xref:System.AsyncCallback>デリゲートによって呼び出されるコールバックメソッドを作成する必要があります。 このコールバックメソッドは、別のスレッドで実行され、メソッドから<xref:System.Net.Sockets.Socket.BeginAccept%2A>制御が戻った後、システムによって呼び出されます。  
  
 コールバックメソッド内で、 <xref:System.IAsyncResult.AsyncState%2A> `asyncResult`パラメーターのメソッドを呼び出して、接続<xref:System.Net.Sockets.Socket>試行が行われているを取得します。 を取得<xref:System.Net.Sockets.Socket>した後、 <xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドを呼び出して、接続の試行を正常に完了することができます。 このオーバーロードの<xref:System.Net.Sockets.Socket.BeginAccept%2A> `bytesTransferred`パラメーターには、の呼び出しで受信したデータが格納されます。このパラメーターには、呼び出しで転送されたバイト数が格納されます。 `buffer`  
  
 メソッド<xref:System.Net.Sockets.Socket.EndAccept%2A>は、接続が受信接続キューで保留状態になるまでブロックします。 メソッド<xref:System.Net.Sockets.Socket.EndAccept%2A>は、受信接続を受け入れ、リモートホスト<xref:System.Net.Sockets.Socket>との間でデータを送受信するために使用できる新しいを返します。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例で<xref:System.Net.Sockets.Socket.BeginAccept%2A>は、を使用してソケットを作成および接続し、最初の10バイトのデータを受け入れます。 コールバックデリゲートは<xref:System.Net.Sockets.Socket.EndAccept%2A> 、非同期要求を終了するためにを呼び出します。 転送されたバイト数とデータは、このメソッド`buffer`の`bytesTransferred`パラメーターとパラメーターで返され、コンソールに表示されます。  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows NT が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> が空です。</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> への呼び出しで <paramref name="asyncResult" /> が作成されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> メソッドは既に呼び出されました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><see cref="T:System.Net.Sockets.Socket" /> へのアクセスを試みているときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (asyncResult As IAsyncResult) As Socket" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (result As IAsyncResult) As Socket" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndAccept : IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">この非同期操作のステータス情報だけではなく、任意のユーザー定義のデータも格納する <see cref="T:System.IAsyncResult" />。</param>
        <param name="result">この非同期操作のステータス情報だけではなく、任意のユーザー定義のデータも格納する <see cref="T:System.IAsyncResult" />。</param>
        <summary>受信接続の試行を非同期的に受け入れ、新しい <see cref="T:System.Net.Sockets.Socket" /> を作成してリモート ホスト通信を処理します。</summary>
        <returns>リモート ホストとの通信を処理する <see cref="T:System.Net.Sockets.Socket" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>へ<xref:System.Net.Sockets.Socket.BeginAccept%2A>の呼び出しを完了します。 を呼び出す<xref:System.Net.Sockets.Socket.BeginAccept%2A>前に、 <xref:System.AsyncCallback>デリゲートを実装するコールバックメソッドを作成する必要があります。 このコールバックメソッドは、別のスレッドで実行され、メソッドから<xref:System.Net.Sockets.Socket.BeginAccept%2A>制御が戻った後、システムによって呼び出されます。 メソッドから返され`asyncResult`たパラメーターを受け入れる必要があります。 <xref:System.Net.Sockets.Socket.BeginAccept%2A>  
  
 コールバックメソッド内で、 <xref:System.IAsyncResult.AsyncState%2A> `asyncResult`パラメーターのメソッドを呼び出して、接続<xref:System.Net.Sockets.Socket>試行が行われているを取得します。 を取得<xref:System.Net.Sockets.Socket>した後、 <xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドを呼び出して、接続の試行を正常に完了することができます。  
  
 メソッド<xref:System.Net.Sockets.Socket.EndAccept%2A>は、接続が受信接続キューで保留状態になるまでブロックします。 メソッド<xref:System.Net.Sockets.Socket.EndAccept%2A>は、受信接続を受け入れ、リモートホスト<xref:System.Net.Sockets.Socket>との間でデータを送受信するために使用できる新しいを返します。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、非同期要求を終了し<xref:System.Net.Sockets.Socket> 、受信接続要求を受け入れる新しいを作成します。 ソケットを使用した非同期通信を示す完全な例については、[ソケットのコード例](~/docs/framework/network-programming/socket-code-examples.md)を参照してください。  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> への呼び出しで <paramref name="asyncResult" /> が作成されませんでした。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 詳細については、次の「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> メソッドは既に呼び出されました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows NT が必要です。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, out int bytesTransferred, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, [out] int32&amp; bytesTransferred, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), ByRef bytesTransferred As Integer, asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, [Runtime::InteropServices::Out] int % bytesTransferred, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept :  *  * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, bytesTransferred, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bytesTransferred" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">転送されたバイト数を格納する <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="bytesTransferred">転送されたバイト数。</param>
        <param name="asyncResult">この非同期操作のステータス情報だけではなく、任意のユーザー定義のデータも格納する <see cref="T:System.IAsyncResult" /> オブジェクト。</param>
        <summary>受信接続の試行を非同期的に受け入れ、新しい <see cref="T:System.Net.Sockets.Socket" /> オブジェクトを作成してリモート ホスト通信を処理します。 このメソッドは、初期データと、転送されたバイト数を格納するバッファーを返します。</summary>
        <returns>リモート ホストとの通信を処理する <see cref="T:System.Net.Sockets.Socket" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>へ<xref:System.Net.Sockets.Socket.BeginAccept%2A>の呼び出しを完了します。 を呼び出す<xref:System.Net.Sockets.Socket.BeginAccept%2A>前に、 <xref:System.AsyncCallback>デリゲートによって呼び出されるコールバックメソッドを作成する必要があります。 このコールバックメソッドは、別のスレッドで実行され、メソッドから<xref:System.Net.Sockets.Socket.BeginAccept%2A>制御が戻った後、システムによって呼び出されます。 メソッドから返され`asyncResult`たパラメーターを受け入れる必要があります。 <xref:System.Net.Sockets.Socket.BeginAccept%2A>  
  
 コールバックメソッド内で、 <xref:System.IAsyncResult.AsyncState%2A> `asyncResult`パラメーターのメソッドを呼び出して、接続<xref:System.Net.Sockets.Socket>試行が行われているを取得します。 を取得<xref:System.Net.Sockets.Socket>した後、 <xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドを呼び出して、接続の試行を正常に完了することができます。 このオーバーロードの<xref:System.Net.Sockets.Socket.BeginAccept%2A> `bytesTransferred`パラメーターには、の呼び出しで受信したデータが格納されます。このパラメーターには、呼び出しで転送されたバイト数が格納されます。 `buffer`  
  
 メソッド<xref:System.Net.Sockets.Socket.EndAccept%2A>は、接続が受信接続キューで保留状態になるまでブロックします。 メソッド<xref:System.Net.Sockets.Socket.EndAccept%2A>は、受信接続を受け入れ、リモートホスト<xref:System.Net.Sockets.Socket>との間でデータを送受信するために使用できる新しいを返します。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例で<xref:System.Net.Sockets.Socket.BeginAccept%2A>は、を使用してソケットを作成および接続し、最初の10バイトのデータを受け入れます。 コールバックデリゲートは<xref:System.Net.Sockets.Socket.EndAccept%2A> 、非同期要求を終了するためにを呼び出します。 転送されたバイト数とデータは、このメソッド`buffer`の`bytesTransferred`パラメーターとパラメーターで返され、コンソールに表示されます。  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows NT が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> が空です。</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> への呼び出しで <paramref name="asyncResult" /> が作成されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> メソッドは既に呼び出されました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><see cref="T:System.Net.Sockets.Socket" /> へのアクセスを試みているときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndConnect">
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (asyncResult As IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (result As IAsyncResult)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndConnect : IAsyncResult -&gt; unit" Usage="socket.EndConnect result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">この非同期操作の状態情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" />。</param>
        <param name="result">この非同期操作の状態情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" />。</param>
        <summary>保留中の非同期接続要求を終了します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndConnect%2A>は、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドで開始された非同期リモートホスト接続要求を完了するブロッキングメソッドです。  
  
 を呼び出す<xref:System.Net.Sockets.Socket.BeginConnect%2A>前に、 <xref:System.AsyncCallback>デリゲートを実装するコールバックメソッドを作成する必要があります。 このコールバックメソッドは、別のスレッドで実行され、が<xref:System.Net.Sockets.Socket.BeginConnect%2A>返された後にシステムによって呼び出されます。 コールバックメソッドは、パラメーター <xref:System.IAsyncResult>として<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドによって返されたを受け入れる必要があります。  
  
 コールバックメソッド内で、 <xref:System.IAsyncResult.AsyncState%2A> <xref:System.IAsyncResult>パラメーターのメソッドを呼び出して、接続<xref:System.Net.Sockets.Socket>試行が行われているを取得します。 を取得<xref:System.Net.Sockets.Socket>した後、 <xref:System.Net.Sockets.Socket.EndConnect%2A>メソッドを呼び出して、接続の試行を正常に完了することができます。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、非同期接続の試行を終了します。 ソケットを使用した非同期通信を示す完全な例については、[ソケットのコード例](~/docs/framework/network-programming/socket-code-examples.md)を参照してください。  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> は、非同期接続のために以前に呼び出されています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndDisconnect">
      <MemberSignature Language="C#" Value="public void EndDisconnect (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndDisconnect(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndDisconnect (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndDisconnect(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndDisconnect : IAsyncResult -&gt; unit" Usage="socket.EndDisconnect asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">この非同期操作のステータス情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" /> オブジェクト。</param>
        <summary>保留中の非同期切断要求を終了します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndDisconnect%2A>へ<xref:System.Net.Sockets.Socket.BeginDisconnect%2A>の呼び出しを完了します。 メソッド<xref:System.Net.Sockets.Socket.EndDisconnect%2A>は、切断が完了するまでブロックします。 非同期操作の詳細については、MSDN ライブラリの「非同期プログラミングの概要」を参照してください。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、非同期通信用のソケットを作成し、いくつかのデータをリモートホストに送信します。 データが送信されると、 <xref:System.Net.Sockets.Socket.Shutdown%2A>が呼び出され、送信と受信のアクティビティを停止します。 次<xref:System.Net.Sockets.Socket.BeginDisconnect%2A>に、が呼び出され、切断要求が開始されます。 コールバックデリゲートは<xref:System.Net.Sockets.Socket.EndDisconnect%2A> 、非同期要求を終了するためにを呼び出します。 要求が完了すると、 <xref:System.Net.Sockets.Socket.Connected%2A>プロパティが照会され、ソケットが切断されているかどうかがテストされます。  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Windows 2000 以前のオペレーティング システムです。このメソッドを使用するには、Windows XP が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /> は、非同期接続のために以前に呼び出されています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.Net.WebException">切断要求がタイムアウトしました。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>保留中の非同期読み取りを終了します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; int" Usage="socket.EndReceive result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">この非同期操作の状態情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" />。</param>
        <param name="result">この非同期操作の状態情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" />。</param>
        <summary>保留中の非同期読み取りを終了します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドは、 <xref:System.Net.Sockets.Socket.BeginReceive%2A>メソッドで開始された非同期の読み取り操作を完了します。 <xref:System.Net.Sockets.Socket.EndReceive%2A>  
  
 を呼び出す<xref:System.Net.Sockets.Socket.BeginReceive%2A>前に、 <xref:System.AsyncCallback>デリゲートを実装するコールバックメソッドを作成する必要があります。 このコールバックメソッドは、別のスレッドで実行され、が<xref:System.Net.Sockets.Socket.BeginReceive%2A>返された後にシステムによって呼び出されます。 コールバックメソッドは、パラメーター <xref:System.IAsyncResult>として<xref:System.Net.Sockets.Socket.BeginReceive%2A>メソッドによって返されたを受け入れる必要があります。  
  
 コールバックメソッド内で、 <xref:System.IAsyncResult.AsyncState%2A> <xref:System.IAsyncResult>のメソッドを呼び出して、 <xref:System.Net.Sockets.Socket.BeginReceive%2A>メソッドに渡される状態オブジェクトを取得します。 この状態オブジェクト<xref:System.Net.Sockets.Socket>から受信を抽出します。 を取得<xref:System.Net.Sockets.Socket>した後、 <xref:System.Net.Sockets.Socket.EndReceive%2A>メソッドを呼び出して、読み取り操作を正常に完了し、読み取ったバイト数を返すことができます。  
  
 メソッド<xref:System.Net.Sockets.Socket.EndReceive%2A>は、データが使用可能になるまでブロックします。 コネクションレスプロトコルを使用している<xref:System.Net.Sockets.Socket.EndReceive%2A>場合、は、受信ネットワークバッファーで使用可能な最初のエンキューされたデータグラムを読み取ります。 接続指向プロトコルを使用している場合、 <xref:System.Net.Sockets.Socket.EndReceive%2A>メソッドは、 <xref:System.Net.Sockets.Socket.BeginReceive%2A>メソッドの`size`パラメーターで指定したバイト数まで、使用可能な量のデータを読み取ります。 リモートホストが<xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.Socket.Shutdown%2A>メソッドとの接続を切断し、使用可能なすべてのデータを受信した<xref:System.Net.Sockets.Socket.EndReceive%2A>場合、メソッドは直ちに完了し、0バイトを返します。  
  
 受信したデータを取得するに<xref:System.IAsyncResult.AsyncState%2A>は<xref:System.IAsyncResult>、のメソッドを呼び出し、結果の状態オブジェクトに格納されているバッファーを抽出します。  
  
 保留中<xref:System.Net.Sockets.Socket.BeginReceive%2A>のを取り消すには<xref:System.Net.Sockets.Socket.Close%2A> 、メソッドを呼び出します。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  特定のスレッドによって開始されるすべての i/o は、そのスレッドが終了すると取り消されます。 保留中の非同期操作は、操作が完了する前にスレッドが終了した場合に失敗する可能性があります。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、保留中の非同期読み取りを終了します。 ソケットを使用した非同期通信を示す完全な例については、[ソケットのコード例](~/docs/framework/network-programming/socket-code-examples.md)を参照してください。  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> が、非同期の読み取りのために以前に呼び出されています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult *  -&gt; int" Usage="socket.EndReceive (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">この非同期操作の状態情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" />。</param>
        <param name="errorCode">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</param>
        <summary>保留中の非同期読み取りを終了します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドは、 <xref:System.Net.Sockets.Socket.BeginReceive%2A>メソッドで開始された非同期の読み取り操作を完了します。 <xref:System.Net.Sockets.Socket.EndReceive%2A>  
  
 を呼び出す<xref:System.Net.Sockets.Socket.BeginReceive%2A>前に、 <xref:System.AsyncCallback>デリゲートを実装するコールバックメソッドを作成する必要があります。 このコールバックメソッドは、別のスレッドで実行され、が<xref:System.Net.Sockets.Socket.BeginReceive%2A>返された後にシステムによって呼び出されます。 コールバックメソッドは、パラメーター <xref:System.IAsyncResult>として<xref:System.Net.Sockets.Socket.BeginReceive%2A>メソッドによって返されたを受け入れる必要があります。  
  
 コールバックメソッド内で、 <xref:System.IAsyncResult.AsyncState%2A> <xref:System.IAsyncResult>のメソッドを呼び出して、 <xref:System.Net.Sockets.Socket.BeginReceive%2A>メソッドに渡される状態オブジェクトを取得します。 この状態オブジェクト<xref:System.Net.Sockets.Socket>から受信を抽出します。 を取得<xref:System.Net.Sockets.Socket>した後、 <xref:System.Net.Sockets.Socket.EndReceive%2A>メソッドを呼び出して、読み取り操作を正常に完了し、読み取ったバイト数を返すことができます。  
  
 メソッド<xref:System.Net.Sockets.Socket.EndReceive%2A>は、データが使用可能になるまでブロックします。 コネクションレスプロトコルを使用している<xref:System.Net.Sockets.Socket.EndReceive%2A>場合、は、受信ネットワークバッファーで使用可能な最初のエンキューされたデータグラムを読み取ります。 接続指向プロトコルを使用している場合、 <xref:System.Net.Sockets.Socket.EndReceive%2A>メソッドは、 <xref:System.Net.Sockets.Socket.BeginReceive%2A>メソッドの`size`パラメーターで指定したバイト数まで、使用可能な量のデータを読み取ります。 リモートホストが<xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.Socket.Shutdown%2A>メソッドとの接続を切断し、使用可能なすべてのデータを受信した<xref:System.Net.Sockets.Socket.EndReceive%2A>場合、メソッドは直ちに完了し、0バイトを返します。  
  
 受信したデータを取得するに<xref:System.IAsyncResult.AsyncState%2A>は<xref:System.IAsyncResult>、のメソッドを呼び出し、結果の状態オブジェクトに格納されているバッファーを抽出します。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  特定のスレッドによって開始されるすべての i/o は、そのスレッドが終了すると取り消されます。 保留中の非同期操作は、操作が完了する前にスレッドが終了した場合に失敗する可能性があります。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> が、非同期の読み取りのために以前に呼び出されています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceiveFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult asyncResult, ref System.Net.EndPoint endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult asyncResult, class System.Net.EndPoint&amp; endPoint) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (asyncResult As IAsyncResult, ByRef endPoint As EndPoint) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ asyncResult, System::Net::EndPoint ^ % endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult result, ref System.Net.EndPoint end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult result, class System.Net.EndPoint&amp; end_point) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (result As IAsyncResult, ByRef end_point As EndPoint) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ result, System::Net::EndPoint ^ % end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceiveFrom : IAsyncResult *  -&gt; int" Usage="socket.EndReceiveFrom (result, end_point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">この非同期操作の状態情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" />。</param>
        <param name="result">この非同期操作の状態情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" />。</param>
        <param name="endPoint">コピー元 <see cref="T:System.Net.EndPoint" />。</param>
        <param name="end_point">コピー元 <see cref="T:System.Net.EndPoint" />。</param>
        <summary>特定のエンドポイントからの、保留中の非同期読み込みを終了します。</summary>
        <returns>正常に完了した場合は、受信したバイト数。 失敗した場合は、0 を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドは、 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッドで開始された非同期の読み取り操作を完了します。 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>  
  
 を呼び出す<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>前に、 <xref:System.AsyncCallback>デリゲートを実装するコールバックメソッドを作成する必要があります。 このコールバックメソッドは、別のスレッドで実行され、が<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>返された後にシステムによって呼び出されます。 コールバックメソッドは、パラメーター <xref:System.IAsyncResult>として<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッドによって返されたを受け入れる必要があります。  
  
 コールバックメソッド内で、 <xref:System.IAsyncResult.AsyncState%2A> <xref:System.IAsyncResult>のメソッドを呼び出して、 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッドに渡される状態オブジェクトを取得します。 この状態オブジェクト<xref:System.Net.Sockets.Socket>から受信を抽出します。 を取得<xref:System.Net.Sockets.Socket>した後、 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>メソッドを呼び出して、読み取り操作を正常に完了し、読み取ったバイト数を返すことができます。  
  
 メソッド<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>は、データが使用可能になるまでブロックします。 コネクションレスプロトコルを使用している<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>場合、は、受信ネットワークバッファーで使用可能な最初のエンキューされたデータグラムを読み取ります。 接続指向プロトコルを使用している場合、 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>メソッドは、 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッドの`size`パラメーターで指定したバイト数まで、使用可能な量のデータを読み取ります。 リモートホストが<xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.Socket.Shutdown%2A>メソッドとの接続を切断し、使用可能なすべてのデータを受信した<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>場合、メソッドは直ちに完了し、0バイトを返します。 受信したデータを取得するに<xref:System.IAsyncResult.AsyncState%2A>は、 <xref:System.IAsyncResult>オブジェクトのメソッドを呼び出し、結果の状態オブジェクトに格納されているバッファーを抽出します。 元のホストを特定するには<xref:System.Net.EndPoint> 、を抽出し、 <xref:System.Net.IPEndPoint>にキャストします。 メソッドを使用して、IP アドレス<xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType>を取得し、メソッドを使用してポート番号を取得します。 <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType>  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、特定<xref:System.Net.EndPoint>のからの保留中の非同期読み取りを終了します。  
  
 [!code-cpp[Socket_Async_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Async_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Async_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> が、非同期の読み取りのために以前に呼び出されています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveMessageFrom (IAsyncResult asyncResult, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint endPoint, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveMessageFrom(class System.IAsyncResult asyncResult, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; endPoint, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveMessageFrom (asyncResult As IAsyncResult, ByRef socketFlags As SocketFlags, ByRef endPoint As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveMessageFrom(IAsyncResult ^ asyncResult, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % endPoint, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.EndReceiveMessageFrom : IAsyncResult *  *  *  -&gt; int" Usage="socket.EndReceiveMessageFrom (asyncResult, socketFlags, endPoint, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" RefType="ref" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint" RefType="ref" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation" RefType="out" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">この非同期操作の状態情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" />。</param>
        <param name="socketFlags">受信パケットの <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="endPoint">コピー元 <see cref="T:System.Net.EndPoint" />。</param>
        <param name="ipPacketInformation">受信パケットの <see cref="T:System.Net.IPAddress" /> とインターフェイス。</param>
        <summary>特定のエンドポイントからの、保留中の非同期読み込みを終了します。 また、このメソッドは、<see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> よりもパケットに関するより多くの情報を示します。</summary>
        <returns>正常に完了した場合は、受信したバイト数。 失敗した場合は、0 を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 操作が完了していない場合、このメソッドは、処理が完了するまでブロックします。  
  
 この操作を同期的に実行する<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>には、メソッドを使用します。  
  
 データグラム`ipPacketInformation`がユニキャスト、マルチキャスト、またはブロードキャストアドレスを使用して送信されたかどうかを確認する必要があるかどうかを調べます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> は <see langword="null" /> です  
  
- または - 
 <paramref name="endPoint" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" /> が、非同期の読み取りのために以前に呼び出されています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>保留中の非同期送信を終了します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult -&gt; int" Usage="socket.EndSend result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">この非同期操作の状態情報を格納する <see cref="T:System.IAsyncResult" />。</param>
        <param name="result">この非同期操作の状態情報を格納する <see cref="T:System.IAsyncResult" />。</param>
        <summary>保留中の非同期送信を終了します。</summary>
        <returns>正常に終了した場合は <see cref="T:System.Net.Sockets.Socket" /> に送信したバイト数。それ以外の場合は無効な <see cref="T:System.Net.Sockets.Socket" /> エラー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A>で<xref:System.Net.Sockets.Socket.BeginSend%2A>開始された非同期の送信操作を完了します。  
  
 を呼び出す<xref:System.Net.Sockets.Socket.BeginSend%2A>前に、 <xref:System.AsyncCallback>デリゲートを実装するコールバックメソッドを作成する必要があります。 このコールバックメソッドは、別のスレッドで実行され、が<xref:System.Net.Sockets.Socket.BeginSend%2A>返された後にシステムによって呼び出されます。 コールバックメソッドは、パラメーター <xref:System.IAsyncResult>として<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドによって返されたを受け入れる必要があります。  
  
 コールバックメソッド内で、 <xref:System.IAsyncResult.AsyncState%2A> <xref:System.IAsyncResult>パラメーターのメソッドを呼び出して、送信元<xref:System.Net.Sockets.Socket>を取得します。 を取得<xref:System.Net.Sockets.Socket>した後、 <xref:System.Net.Sockets.Socket.EndSend%2A>メソッドを呼び出して送信操作を正常に完了し、送信されたバイト数を返すことができます。  
  
 コネクションレスプロトコルを使用している<xref:System.Net.Sockets.Socket.EndSend%2A>場合、はデータグラムが送信されるまでブロックします。 接続指向プロトコルを使用している場合、 <xref:System.Net.Sockets.Socket.EndSend%2A>は一部のバッファーが送信されるまでブロックします。 からの<xref:System.Net.Sockets.Socket.EndSend%2A>戻り値が、バッファーが完全には送信されてい<xref:System.Net.Sockets.Socket.BeginSend%2A>ないことを示している場合は、メソッドを再度呼び出して、未送信データを保持するようにバッファーを変更します。  
  
 送信したデータがネットワークに直ちに表示される保証はありません。 ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。 <xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドが正常に終了するということは、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  特定のスレッドによって開始されるすべての i/o は、そのスレッドが終了すると取り消されます。 保留中の非同期操作は、操作が完了する前にスレッドが終了した場合に失敗する可能性があります。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されたことは示されません。 転送されるデータを保持するためにトランスポートシステム内で使用できるバッファー領域がない場合、ソケットが非ブロッキングモードに設定されていない限り、send はブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、保留中の非同期送信を終了します。  
  
 [!code-cpp[Socket_Async_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Async_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Async_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> が、非同期送信のために以前に呼び出されています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult *  -&gt; int" Usage="socket.EndSend (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">この非同期操作の状態情報を格納する <see cref="T:System.IAsyncResult" />。</param>
        <param name="errorCode">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</param>
        <summary>保留中の非同期送信を終了します。</summary>
        <returns>正常に終了した場合は <see cref="T:System.Net.Sockets.Socket" /> に送信したバイト数。それ以外の場合は無効な <see cref="T:System.Net.Sockets.Socket" /> エラー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A>で<xref:System.Net.Sockets.Socket.BeginSend%2A>開始された非同期の送信操作を完了します。  
  
 を呼び出す<xref:System.Net.Sockets.Socket.BeginSend%2A>前に、 <xref:System.AsyncCallback>デリゲートを実装するコールバックメソッドを作成する必要があります。 このコールバックメソッドは、別のスレッドで実行され、が<xref:System.Net.Sockets.Socket.BeginSend%2A>返された後にシステムによって呼び出されます。 コールバックメソッドは、パラメーター <xref:System.IAsyncResult>として<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドによって返されたを受け入れる必要があります。  
  
 コールバックメソッド内で、 <xref:System.IAsyncResult.AsyncState%2A> <xref:System.IAsyncResult>パラメーターのメソッドを呼び出して、送信元<xref:System.Net.Sockets.Socket>を取得します。 を取得<xref:System.Net.Sockets.Socket>した後、 <xref:System.Net.Sockets.Socket.EndSend%2A>メソッドを呼び出して送信操作を正常に完了し、送信されたバイト数を返すことができます。  
  
 コネクションレスプロトコルを使用している<xref:System.Net.Sockets.Socket.EndSend%2A>場合、はデータグラムが送信されるまでブロックします。 接続指向プロトコルを使用している場合、 <xref:System.Net.Sockets.Socket.EndSend%2A>は一部のバッファーが送信されるまでブロックします。 からの<xref:System.Net.Sockets.Socket.EndSend%2A>戻り値が、バッファーが完全には送信されてい<xref:System.Net.Sockets.Socket.BeginSend%2A>ないことを示している場合は、メソッドを再度呼び出して、未送信データを保持するようにバッファーを変更します。  
  
 送信したデータがネットワークに直ちに表示される保証はありません。 ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。 <xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドが正常に終了するということは、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  特定のスレッドによって開始されるすべての i/o は、そのスレッドが終了すると取り消されます。 保留中の非同期操作は、操作が完了する前にスレッドが終了した場合に失敗する可能性があります。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されたことは示されません。 転送されるデータを保持するためにトランスポートシステム内で使用できるバッファー領域がない場合、ソケットが非ブロッキングモードに設定されていない限り、send はブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> が、非同期送信のために以前に呼び出されています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSendFile">
      <MemberSignature Language="C#" Value="public void EndSendFile (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndSendFile(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndSendFile (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndSendFile(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndSendFile : IAsyncResult -&gt; unit" Usage="socket.EndSendFile asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">この非同期操作の状態情報を格納する <see cref="T:System.IAsyncResult" /> オブジェクト。</param>
        <summary>ファイルの保留中の非同期送信を終了します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendFile%2A>で<xref:System.Net.Sockets.Socket.BeginSendFile%2A>開始された非同期の送信操作を完了します。  
  
 を呼び出す<xref:System.Net.Sockets.Socket.BeginSendFile%2A>前に、 <xref:System.AsyncCallback>デリゲートを実装するコールバックメソッドを作成する必要があります。 このコールバックメソッドは、別のスレッドで実行され、が<xref:System.Net.Sockets.Socket.BeginSendFile%2A>返された後にシステムによって呼び出されます。 コールバックメソッドは、パラメーター <xref:System.IAsyncResult>として<xref:System.Net.Sockets.Socket.BeginSendFile%2A>メソッドによって返されたオブジェクトを受け入れる必要があります。  
  
 コールバックメソッド内で、 <xref:System.IAsyncResult.AsyncState%2A> <xref:System.IAsyncResult>パラメーターのメソッドを呼び出して、送信元<xref:System.Net.Sockets.Socket>を取得します。 を取得<xref:System.Net.Sockets.Socket>した後、 <xref:System.Net.Sockets.Socket.EndSendFile%2A>メソッドを呼び出して、送信操作を正常に完了できます。  
  
 コネクションレスプロトコルを使用している<xref:System.Net.Sockets.Socket.EndSendFile%2A>場合、はデータグラムが送信されるまでブロックします。 接続指向プロトコルを使用している場合は<xref:System.Net.Sockets.Socket.EndSendFile%2A> 、ファイル全体が送信されるまでブロックされます。 送信したデータがネットワークに直ちに表示される保証はありません。 ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。 <xref:System.Net.Sockets.Socket.BeginSendFile%2A>メソッドが正常に終了するということは、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、非同期通信用のソケットを作成して接続し、リモートホストへのファイル "test.txt" の非同期送信を開始します。 コールバックデリゲートは<xref:System.Net.Sockets.Socket.EndSendFile%2A> 、転送を完了するためにを呼び出します。  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows NT が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> が空です。</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> が、非同期の <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> のために以前に呼び出されています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 以下の解説を参照してください。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndSendTo">
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSendTo : IAsyncResult -&gt; int" Usage="socket.EndSendTo result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">この非同期操作の状態情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" />。</param>
        <param name="result">この非同期操作の状態情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" />。</param>
        <summary>特定の場所への、保留中の非同期送信を終了します。</summary>
        <returns>正常に完了した場合は送信したバイト数。それ以外の場合は無効な <see cref="T:System.Net.Sockets.Socket" /> エラー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendTo%2A>で<xref:System.Net.Sockets.Socket.BeginSendTo%2A>開始された非同期の送信操作を完了します。  
  
 を呼び出す<xref:System.Net.Sockets.Socket.BeginSendTo%2A>前に、 <xref:System.AsyncCallback>デリゲートを実装するコールバックメソッドを作成する必要があります。 このコールバックメソッドは、別のスレッドで実行され、が<xref:System.Net.Sockets.Socket.BeginReceive%2A>返された後にシステムによって呼び出されます。 コールバックメソッドは、パラメーター <xref:System.IAsyncResult>として<xref:System.Net.Sockets.Socket.BeginSendTo%2A>メソッドによって返されたを受け入れる必要があります。  
  
 コールバックメソッド内で、 <xref:System.IAsyncResult.AsyncState%2A> <xref:System.IAsyncResult>パラメーターのメソッドを呼び出して、送信元<xref:System.Net.Sockets.Socket>を取得します。 を取得<xref:System.Net.Sockets.Socket>した後、 <xref:System.Net.Sockets.Socket.EndSendTo%2A>メソッドを呼び出して送信操作を正常に完了し、送信されたバイト数を返すことができます。  
  
 コネクションレスプロトコルを使用している<xref:System.Net.Sockets.Socket.EndSendTo%2A>場合、はデータグラムが送信されるまでブロックします。 接続指向プロトコルを使用している場合、 <xref:System.Net.Sockets.Socket.EndSendTo%2A>は、要求されたバイト数が送信されるまでブロックします。 送信したデータがネットワークに直ちに表示される保証はありません。 ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>メソッドが正常に終了するということは、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、特定の場所への非同期送信を終了します。  
  
 [!code-cpp[Socket_Async_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Async_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Async_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /> が、非同期送信のために以前に呼び出されています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExclusiveAddressUse : bool with get, set" Usage="System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> で 1 つのプロセスだけにポートのバインドを許可するかどうかを指定する <see cref="T:System.Boolean" /> 値を取得または設定します。</summary>
        <value><see cref="T:System.Net.Sockets.Socket" /> で 1 つのソケットだけに特定のポートのバインドを許可する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は<see langword="true" /> 、windows Server 2003 と windows XP Service Pack 2 <see langword="false" />の場合は、それ以外のすべてのバージョンの場合はです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 が<xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> <xref:System.Net.Sockets.Socket.Bind%2A>の場合、複数のソケットがメソッドを使用して特定のポートにバインドできます。ただし、ポートに送信されたネットワークトラフィックに対して操作を実行できるのは、ソケットの1つだけです。 `false` 複数のソケットが特定のポートにバインド<xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29>するためにメソッドを使用しようとすると、そのポートに送信されたネットワークトラフィックが、特定の IP アドレスを持つ1つのソケットによって処理されます。  
  
 が<xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> <xref:System.Net.Sockets.Socket.Bind%2A> <xref:System.Net.Sockets.Socket.Bind%2A>の場合、インターネットプロトコル (IP) アドレスに関係なく、特定のポートへのバインドを試行するためにメソッドが最初に使用されます。その後、メソッドを使用してそのポートにバインドしようとすると、 `true`元のバインドされたソケットが破棄されるまで失敗します。  
  
 を呼び出す前に<xref:System.Net.Sockets.Socket.Bind%2A> 、このプロパティを設定する必要があります。それ以外の場合は、 <xref:System.InvalidOperationException>がスローされます。  
  
   
  
## Examples  
 次のコード例は、 <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A>プロパティの使用方法を示しています。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.InvalidOperationException">この <see cref="T:System.Net.Sockets.Socket" /> に対して <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> が呼び出されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Socket ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Socket ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="socket.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> クラスによって使用されていたリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 クラス<xref:System.Net.Sockets.Socket>ファイナライザーは、 <xref:System.Net.Sockets.Socket.Close%2A>メソッドを呼び出して、 <xref:System.Net.Sockets.Socket>に関連付けられて<xref:System.Net.Sockets.Socket>いるリソースと解放されたリソースを閉じます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="socket.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> インスタンスのハッシュ値を返します。</summary>
        <returns>整数ハッシュ値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
GetHashCode メソッドは、このインスタンスのハッシュコードを返します。 この値は、ハッシュテーブルのキーとして使用できます。

]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> オプションの値を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public object GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName -&gt; obj" Usage="socket.GetSocketOption (optionLevel, optionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか 1 つ。</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか 1 つ。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.Socket" /> オプションの値をオブジェクトとして返します。</summary>
        <returns>オプションの値を表すオブジェクト。 <paramref name="optionName" /> パラメーターを <see cref="F:System.Net.Sockets.SocketOptionName.Linger" /> に設定した場合、戻り値は <see cref="T:System.Net.Sockets.LingerOption" /> クラスのインスタンスです。 <paramref name="optionName" /> を <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> または <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" /> に設定した場合、戻り値は <see cref="T:System.Net.Sockets.MulticastOption" /> クラスのインスタンスです。 <paramref name="optionName" /> が他の値の場合、戻り値は整数です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>オプションは、現在<xref:System.Net.Sockets.Socket>のの動作を決定します。 、 <xref:System.Net.Sockets.SocketOptionName.Linger> 、<xref:System.Net.Sockets.SocketOptionName.AddMembership>およびの各オプション<xref:System.Net.Sockets.Socket>を取得するには、このオーバーロードを使用します。 <xref:System.Net.Sockets.SocketOptionName.DropMembership> オプションには、 `optionLevel`パラメーター <xref:System.Net.Sockets.Socket>にを使用します。 <xref:System.Net.Sockets.SocketOptionName.Linger> とでは、 <xref:System.Net.Sockets.SocketOptionLevel.IP>を使用します。 <xref:System.Net.Sockets.SocketOptionName.DropMembership> <xref:System.Net.Sockets.SocketOptionName.AddMembership> 上記のオプションのいずれかの値を設定する場合は、 <xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドを使用します。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では<xref:System.Net.Sockets.LingerOption> 、 <xref:System.Net.Sockets.Socket.Send%2A>とのタイムアウト値を取得し、コンソールに表示します。  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。  
  
- または - 
 <paramref name="optionName" /> が、サポートされていない値 <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" /> に設定されました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public void GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.GetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか 1 つ。</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか 1 つ。</param>
        <param name="optionValue">オプション設定を受信する <see cref="T:System.Byte" /> 型の配列。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.Socket" /> オプション設定をバイト配列として返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>オプションは、現在<xref:System.Net.Sockets.Socket>のの動作を決定します。 このメソッドが正常に完了すると、 `optionValue`パラメーターで指定された配列に、指定した<xref:System.Net.Sockets.Socket>オプションの値が含まれます。  
  
 `optionValue`配列の長さが、指定された<xref:System.Net.Sockets.Socket>オプションの値を格納するために必要なバイト数よりも<xref:System.Net.Sockets.Socket.GetSocketOption%2A>小さい場合、 <xref:System.Net.Sockets.SocketException>はをスローします。 を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。 このオーバーロードは、ブール値または整数で表されるソケットに対して使用します。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では<xref:System.Net.Sockets.LingerOption> 、 <xref:System.Net.Sockets.Socket.Send%2A>とのタイムアウト値を取得し、コンソールに表示します。  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。  
  
- または - 
.NET Compact Framework アプリケーションでは、Windows CE の既定のバッファー領域は 32768 バイトに設定されます。 ソケットごとのバッファー領域は、<see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" /> を呼び出して変更できます。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public byte[] GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionLength As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; byte[]" Usage="socket.GetSocketOption (optionLevel, optionName, optionLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionLength" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか 1 つ。</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか 1 つ。</param>
        <param name="optionLength">予期される戻り値のバイト単位の長さ。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.Socket" /> オプションの値を配列で返します。</summary>
        <returns>ソケット オプションの値を格納している <see cref="T:System.Byte" /> 型の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 パラメーター `optionLength`は、返されるバイト配列の最大サイズを設定します。 オプションの値が必要なバイト数が少なくなる場合、配列にはその数のバイトだけが格納されます。 オプションの値により多くのバイト<xref:System.Net.Sockets.Socket.GetSocketOption%2A>が必要な<xref:System.Net.Sockets.SocketException>場合、はをスローします。 このオーバーロードは、ブール値または整数で表されるソケットに対して使用します。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では<xref:System.Net.Sockets.LingerOption> 、 <xref:System.Net.Sockets.Socket.Send%2A>とのタイムアウト値を取得し、コンソールに表示します。  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。  
  
または 
.NET Compact Framework アプリケーションでは、Windows CE の既定のバッファー領域は 32768 バイトに設定されます。 ソケットごとのバッファー領域は、<see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" /> を呼び出して変更できます。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Net.Sockets.Socket.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> のオペレーティング システム ハンドルを取得します。</summary>
        <value><see cref="T:System.IntPtr" /> のオペレーティング システム ハンドルを表す <see cref="T:System.Net.Sockets.Socket" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IOControl">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> の下位操作モードを設定します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (int ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(int32 ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IOControl (ioControlCode As Integer, optionInValue As Byte(), optionOutValue As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(int ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : int * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionInValue" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">実行する操作の制御コードを指定する <see cref="T:System.Int32" /> 値。</param>
        <param name="optionInValue">操作に必要な入力データを格納する <see cref="T:System.Byte" /> 配列。</param>
        <param name="optionOutValue">操作によって返された出力データを格納する <see cref="T:System.Byte" /> 配列。</param>
        <summary>数値制御コードを使用して、<see cref="T:System.Net.Sockets.Socket" /> の下位操作モードを設定します。</summary>
        <returns><paramref name="optionOutValue" /> パラメーターのバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Net.Sockets.Socket.IOControl%2A>は、 <xref:System.Net.Sockets.Socket>クラスの現在のインスタンスの基に<xref:System.Net.Sockets.Socket>なるオペレーティングシステムへの低レベルのアクセスを提供します。 詳細については、 [Wsaioctl](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl)のドキュメントを参照してください。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、FIONREAD と使用可能なプロパティの結果を比較します。  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Net.Sockets.Socket.Blocking" /> プロパティを使用せずに、ブロッキング モードを変更しようとしました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージコードを実行する場合は。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> (関連する列挙体)</permission>
      </Docs>
    </Member>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (System.Net.Sockets.IOControlCode ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(valuetype System.Net.Sockets.IOControlCode ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(System::Net::Sockets::IOControlCode ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : System.Net.Sockets.IOControlCode * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Net.Sockets.IOControlCode" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionInValue" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">実行する操作の制御コードを指定する <see cref="T:System.Net.Sockets.IOControlCode" /> 値。</param>
        <param name="optionInValue">操作に必要な入力データを格納する <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="optionOutValue">操作によって返された出力データを格納する <see cref="T:System.Byte" /> 型の配列。</param>
        <summary><see cref="T:System.Net.Sockets.IOControlCode" /> 列挙型を使用して制御コードを指定し、<see cref="T:System.Net.Sockets.Socket" /> の下位操作モードを設定します。</summary>
        <returns><paramref name="optionOutValue" /> パラメーターのバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、 <xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.Socket>クラスの現在のインスタンスの基になるオペレーティングシステムへの低レベルのアクセスを提供します。 詳細については、 [Wsaioctl](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl)のドキュメントを参照してください。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、 <xref:System.Net.Sockets.Socket.IOControl%2A> <xref:System.Net.Sockets.IOControlCode.DataToRead>と<xref:System.Net.Sockets.Socket.Available%2A>プロパティを呼び出した結果を比較しています。  
  
 [!code-cpp[NCLSocketIoControl1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl1/CPP/iocontrolcode.cpp#1)]
 [!code-csharp[NCLSocketIoControl1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl1/CS/iocontrolcode.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Net.Sockets.Socket.Blocking" /> プロパティを使用せずに、ブロッキング モードを変更しようとしました。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージコードを実行する場合は。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> (関連する列挙体)</permission>
      </Docs>
    </Member>
    <Member MemberName="IsBound">
      <MemberSignature Language="C#" Value="public bool IsBound { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBound" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.IsBound" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBound As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBound { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBound : bool" Usage="System.Net.Sockets.Socket.IsBound" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> が特定のローカル ポートにバインドされているかどうかを示す値を取得します。</summary>
        <value><see cref="T:System.Net.Sockets.Socket" /> がローカル ポートにバインドされている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ソケット<xref:System.Net.Sockets.Socket.Bind%2A>は、メソッドを呼び出すことによって明示的にバインドされている場合、または一時ローカルポートを使用する<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>、 <xref:System.Net.Sockets.Socket.SendTo%2A>、またはのような<xref:System.Net.Sockets.Socket.Connect%2A>メンバーを呼び出すことによって暗黙的にバインドされている場合は、ローカルポートにバインドされていると見なされます (無料のポートは、1024。オペレーティングシステムによって選択されます。)サーバーは、 <xref:System.Net.Sockets.Socket.Bind%2A>メソッドを使用して、クライアントが接続できるように、既知のポートにバインドします。  
  
   
  
## Examples  
 次のコード例は、 <xref:System.Net.Sockets.Socket.IsBound%2A>プロパティの使用方法を示しています。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LingerState">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.LingerOption LingerState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.LingerOption LingerState" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LingerState" />
      <MemberSignature Language="VB.NET" Value="Public Property LingerState As LingerOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::LingerOption ^ LingerState { System::Net::Sockets::LingerOption ^ get(); void set(System::Net::Sockets::LingerOption ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LingerState : System.Net.Sockets.LingerOption with get, set" Usage="System.Net.Sockets.Socket.LingerState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.LingerOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> で、すべての保留中のデータを送信しようとするときにソケットを遅延して閉じるかどうかを指定する値を取得または設定します。</summary>
        <value>ソケットを閉じているときの待機方法を指定する <see cref="T:System.Net.Sockets.LingerOption" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティ<xref:System.Net.Sockets.Socket.LingerState%2A>は、メソッドの<xref:System.Net.Sockets.Socket.Close%2A>動作方法を変更します。 このプロパティを設定すると、Winsock によって接続をリセットできる条件が変更されます。 接続のリセットは、IP プロトコルの動作によっても発生する可能性があります。  
  
 このプロパティは、データが送信されたままになっている場合に、接続指向<xref:System.Net.Sockets.Socket.Close%2A>接続が開いたままになる時間を制御します。  
  
 ピアにデータを送信するためにメソッドを呼び出すと、このデータは送信ネットワークバッファーに配置されます。 このプロパティを使用すると、メソッドが<xref:System.Net.Sockets.TcpClient.Close%2A>接続を切断する前に、このデータが確実にリモートホストに送信されるようにすることができます。  
  
 残留を有効にするに<xref:System.Net.Sockets.LingerOption>は、目的の値を含むインスタンスを<xref:System.Net.Sockets.Socket.LingerState%2A>作成し、このインスタンスにプロパティを設定します。  
  
 次の表<xref:System.Net.Sockets.Socket.Close%2A>では、プロパティ<xref:System.Net.Sockets.LingerOption.Enabled%2A>の使用可能な値に対するメソッドの動作と<xref:System.Net.Sockets.LingerOption.LingerTime%2A> 、 <xref:System.Net.Sockets.Socket.LingerState%2A>プロパティに格納されているプロパティについて説明します。  
  
|LingerState.Enabled|LingerState.LingerTime|動作|  
|-------------------------|----------------------------|--------------|  
|`false`(無効)、既定値|タイムアウトは適用されません (既定)。|既定の IP プロトコルのタイムアウトが経過するまで、保留中のデータの送信を試みます。|  
|`true`enabled|0以外のタイムアウト|指定したタイムアウトが経過するまで保留中のデータを送信しようとします。失敗した場合は、Winsock によって接続がリセットされます。|  
|`true`enabled|ゼロタイムアウト。|保留中のデータを破棄します。 接続指向のソケット (TCP など) の場合、Winsock によって接続がリセットされます。|  
  
 IP スタックは、接続のラウンドトリップ時間に基づいて、使用する既定の IP プロトコルタイムアウト期間を計算します。 ほとんどの場合、スタックによって計算されるタイムアウトは、アプリケーションで定義されているものよりも関連性が高くなります。 これは、 <xref:System.Net.Sockets.Socket.LingerState%2A>プロパティが設定されていない場合のソケットの既定の動作です。  
  
 プロパティに格納されているプロパティが既定のipプロトコルタイムアウトよりも大きい値に設定されている場合でも、既定のipプロトコルタイムアウトが適用され、上書きされます。<xref:System.Net.Sockets.LingerOption.LingerTime%2A> <xref:System.Net.Sockets.Socket.LingerState%2A>  
  
   
  
## Examples  
 次のコード例は、 <xref:System.Net.Sockets.Socket.LingerState%2A>プロパティの使用方法を示しています。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Listen">
      <MemberSignature Language="C#" Value="public void Listen (int backlog);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Listen(int32 backlog) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Listen (backlog As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Listen(int backlog);" />
      <MemberSignature Language="F#" Value="member this.Listen : int -&gt; unit" Usage="socket.Listen backlog" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backlog" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="backlog">保留中の接続のキューの最大長。</param>
        <summary><see cref="T:System.Net.Sockets.Socket" /> をリッスン状態にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Listen%2A>接続方向<xref:System.Net.Sockets.Socket>の接続の試行をリッスンします。 パラメーター `backlog`は、受け入れのためにキューに登録できる着信接続の数を指定します。 指定できる接続の最大数を決定するには、 <xref:System.Net.Sockets.SocketOptionName.MaxConnections>値を取得します。 <xref:System.Net.Sockets.Socket.Listen%2A>はブロックしません。  
  
 を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。 また<xref:System.Net.Sockets.Socket.Accept%2A> は<xref:System.Net.Sockets.Socket.BeginAccept%2A>を使用して、キューからの接続を受け入れます。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.Socket.Bind%2A>を呼び出す<xref:System.Net.Sockets.Socket.Listen%2A>前にメソッドを呼び出す必要があります<xref:System.Net.Sockets.SocketException>。または<xref:System.Net.Sockets.Socket.Listen%2A> 、をスローします。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
> [!NOTE]
>  バックログパラメーターは、オペレーティングシステムによって異なる値に制限されます。 より高い値を指定することもできますが、バックログはオペレーティングシステムに基づいて制限されます。  
  
   
  
## Examples  
 次のコード例で<xref:System.Net.Sockets.Socket>は、を使用して着信接続をリッスンします。  
  
 [!code-cpp[Classic Socket.Listen Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Listen Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Listen Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Listen Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Listen Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Listen Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="LocalEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint LocalEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint LocalEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ LocalEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ローカル エンドポイントを取得します。</summary>
        <value><see cref="T:System.Net.EndPoint" /> が通信に使用している <see cref="T:System.Net.Sockets.Socket" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティ<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>は、 <xref:System.Net.Sockets.Socket>が<xref:System.Net.EndPoint>バインドされているローカル IP アドレスとポート番号を含むを取得します。 情報を取得する<xref:System.Net.EndPoint>前に<xref:System.Net.IPEndPoint> 、これをにキャストする必要があります。 次に、 <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType>メソッドを呼び出してローカル<xref:System.Net.IPAddress> <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType>のを取得し、メソッドを呼び出してローカルポート番号を取得します。  
  
 <xref:System.Net.Sockets.Socket.Bind%2A>通常、 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>プロパティは、メソッドを呼び出した後に設定されます。 ソケットのローカル IP アドレスとポート番号をシステムに割り当てられるようにすると<xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 、最初の i/o 操作の後にプロパティが設定されます。 接続指向プロトコルの場合、最初の i/o 操作はメソッド<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドの呼び出しになります。 コネクションレスプロトコルの場合、最初の i/o 操作は、送信または受信呼び出しのいずれかになります。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、ローカルとリモートのエンドポイントを取得して表示します。  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="MulticastLoopback">
      <MemberSignature Language="C#" Value="public bool MulticastLoopback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MulticastLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MulticastLoopback { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastLoopback : bool with get, set" Usage="System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発信マルチキャスト パケットが送信元アプリケーションに配信されるかどうかを指定する値を取得または設定します。</summary>
        <value><see cref="T:System.Net.Sockets.Socket" /> が発信マルチキャスト パケットを受け取る場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 マルチキャストは、インターネット上の多対多通信のためのスケーラブルな方法です。 プロセスは、マルチキャストアドレスをサブスクライブします。次に、サブスクライブされたプロセスによって送信されたすべてのパケットが、マルチキャストアドレスをサブスクライブしている他のすべてのプロセスによって受信されます。  
  
 伝送制御プロトコル (TCP) ソケットでこのプロパティを設定しても効果はありません。  
  
   
  
## Examples  
 次のコード例は、 <xref:System.Net.Sockets.Socket.MulticastLoopback%2A>プロパティの使用方法を示しています。  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="NoDelay">
      <MemberSignature Language="C#" Value="public bool NoDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NoDelay" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.NoDelay" />
      <MemberSignature Language="VB.NET" Value="Public Property NoDelay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NoDelay { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NoDelay : bool with get, set" Usage="System.Net.Sockets.Socket.NoDelay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ストリーム <see cref="T:System.Net.Sockets.Socket" /> が Nagle アルゴリズムを使用するかどうかを指定する <see cref="T:System.Boolean" /> 値を取得または設定します。</summary>
        <value><see cref="T:System.Net.Sockets.Socket" /> が Nagle アルゴリズムを使用する場合は <see langword="false" />。それ以外の場合は <see langword="true" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nagle アルゴリズムは、ソケットが小さいパケットをバッファーに格納し、特定の状況下でそれらを結合して1つのパケットで送信することで、ネットワークトラフィックを削減するように設計されています。 TCP パケットは、40バイトのヘッダーと送信されるデータで構成されます。 TCP を使用して少量のデータパケットを送信すると、TCP ヘッダーによって生じるオーバーヘッドがネットワークトラフィックの重要な部分になる可能性があります。負荷が高いネットワークでは、このオーバーヘッドによって発生する輻輳によって、データグラムが失われ、再送信される可能性があります。また、輻輳による過剰な伝達時間も発生する可能性があります。 Nagle アルゴリズムでは、新しい TCP segmentswhen の送信が禁止されています。これにより、接続でデータが転送された場合に、新しい送信データが受信されます。  
  
 ほとんどのネットワークアプリケーションでは、Nagle アルゴリズムを使用する必要があります。  
  
 ユーザーデータグラムプロトコル (UDP) ソケットでこのプロパティを設定しても効果はありません。  
  
   
  
## Examples  
 次のコード例は、 <xref:System.Net.Sockets.Socket.NoDelay%2A>プロパティの使用方法を示しています。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><see cref="T:System.Net.Sockets.Socket" /> へのアクセスを試みているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>基になるオペレーティング システムおよびネットワーク アダプターが、インターネット プロトコル バージョン 4 (IPv4) をサポートするかどうかを示します。</summary>
        <value>オペレーティング システムおよびネットワーク アダプターが IPv4 プロトコルをサポートしている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 オペレーティングシステムは、IPv4 プロトコルと IPv6 プロトコルの両方をサポートしている場合があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>基になるオペレーティング システムおよびネットワーク アダプターが、インターネット プロトコル バージョン 6 (IPv6) をサポートするかどうかを示します。</summary>
        <value>オペレーティング システムおよびネットワーク アダプターが IPv6 プロトコルをサポートしている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 オペレーティングシステムは、IPv4 プロトコルと IPv6 プロトコルの両方をサポートしている場合があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="Poll">
      <MemberSignature Language="C#" Value="public bool Poll (int microSeconds, System.Net.Sockets.SelectMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Poll(int32 microSeconds, valuetype System.Net.Sockets.SelectMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function Poll (microSeconds As Integer, mode As SelectMode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Poll(int microSeconds, System::Net::Sockets::SelectMode mode);" />
      <MemberSignature Language="F#" Value="member this.Poll : int * System.Net.Sockets.SelectMode -&gt; bool" Usage="socket.Poll (microSeconds, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="microSeconds" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="mode" Type="System.Net.Sockets.SelectMode" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="microSeconds">マイクロ秒単位の待機時間。</param>
        <param name="mode"><see cref="T:System.Net.Sockets.SelectMode" /> 値のいずれか 1 つ。</param>
        <summary><see cref="T:System.Net.Sockets.Socket" /> の状態を確認します。</summary>
        <returns><paramref name="mode" /> パラメーターで渡されるポーリング モードの値に基づいた <see cref="T:System.Net.Sockets.Socket" /> の状態。  
  
 <list type="table"><listheader><term> モード 
 </term><description> 戻り値 
 </description></listheader><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectRead" /></term><description><see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> が呼び出されており、接続が保留中の場合は <see langword="true" />。 
- または - 
 データを読み取ることができる場合は <see langword="true" />。 
- または - 
 接続が閉じている、リセットされている、または終了している場合は <see langword="true" />。 
それ以外の場合、<see langword="false" /> を返します。  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /></term><description><see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> を処理し、接続に成功した場合は <see langword="true" />。 
- または - 
 データを送信できる場合は <see langword="true" />。 
それ以外の場合、<see langword="false" /> を返します。  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectError" /></term><description>ブロックしない <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> を処理し、接続に失敗した場合は <see langword="true" />。 
- または - 
 <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> が設定されておらず、帯域外データを使用できる場合は <see langword="true" />。 
それ以外の場合、<see langword="false" /> を返します。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドは、 <xref:System.Net.Sockets.Socket>の状態を確認します。 <xref:System.Net.Sockets.Socket.Poll%2A> が読み取り可能`selectMode`かどうかを判断するには、 <xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType>パラメーターにを指定します。 <xref:System.Net.Sockets.Socket> が<xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType>書き込み可能かどう<xref:System.Net.Sockets.Socket>かを判断するには、を指定します。 エラー <xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType>状態を検出するには、を使用します。 <xref:System.Net.Sockets.Socket.Poll%2A>は、指定された期間 (で`microseconds`測定) が経過するまで実行をブロックします。 応答を`microSeconds`無期限に待機する場合は、パラメーターを負の整数に設定します。 複数のソケットの状態を確認する場合は、 <xref:System.Net.Sockets.Socket.Select%2A>メソッドを使用することをお勧めします。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  この方法では、ネットワークケーブルの切断など、特定の種類の接続の問題を検出することはできません。また、リモートホストが異常終了をシャットダウンしたことを確認することもできません。 これらの種類のエラーを検出するには、データの送信または受信を試みる必要があります。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、ソケットを作成し、サーバーに接続<xref:System.Net.Sockets.Socket.Poll%2A>して、を使用してソケットの状態を確認します。  
  
 [!code-cpp[SelectModeExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SelectModeExample/CPP/source.cpp#1)]
 [!code-csharp[SelectModeExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SelectModeExample/CS/source.cs#1)]
 [!code-vb[SelectModeExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/SelectModeExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="mode" /> パラメーターが、<see cref="T:System.Net.Sockets.SelectMode" /> 値の 1 つではありません。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 以下の解説を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="T:System.Net.Sockets.SelectMode" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="ProtocolType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.ProtocolType ProtocolType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.ProtocolType ProtocolType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ProtocolType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProtocolType As ProtocolType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::ProtocolType ProtocolType { System::Net::Sockets::ProtocolType get(); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolType : System.Net.Sockets.ProtocolType" Usage="System.Net.Sockets.Socket.ProtocolType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.ProtocolType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> のプロトコルの種類を取得します。</summary>
        <value><see cref="T:System.Net.Sockets.ProtocolType" /> 値のいずれか 1 つ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティは、 <xref:System.Net.Sockets.Socket>が作成されるときに設定され、その<xref:System.Net.Sockets.Socket>によって使用されるプロトコルを指定します。 <xref:System.Net.Sockets.Socket.ProtocolType%2A>  
  
   
  
## Examples  
 次のコード例では<xref:System.Net.Sockets.AddressFamily>、 <xref:System.Net.Sockets.SocketType>、、 <xref:System.Net.Sockets.ProtocolType>およびをコンソールに表示します。  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>バインドされた <see cref="T:System.Net.Sockets.Socket" /> からデータを受信します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</param>
        <summary>バインドされた <see cref="T:System.Net.Sockets.Socket" /> からデータを受信し、受信バッファーに格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Net.Sockets.Socket.Receive%2A>は、バッファーパラメーターにデータを読み込み、正常に読み取られたバイト数を返します。 接続指向ソケット<xref:System.Net.Sockets.Socket.Receive%2A>とコネクションレスソケットの両方からを呼び出すことができます。  
  
 このオーバーロードでは、受信バッファーのみを指定する必要があります。 バッファーオフセットの既定値は0で、サイズは既定でバッファーパラメーターの長さに設定さ<xref:System.Net.Sockets.SocketFlags>れ、既定<xref:System.Net.Sockets.SocketFlags.None>値はに設定されます。  
  
 接続指向プロトコルを使用している場合は、を呼び出し<xref:System.Net.Sockets.Socket.Connect%2A>てリモートホスト接続を確立するか<xref:System.Net.Sockets.Socket.Accept%2A> 、を呼び出す<xref:System.Net.Sockets.Socket.Receive%2A>前に受信接続を受け入れる必要があります。 メソッドは、メソッド<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドで確立されたリモートホストから到着したデータのみを読み取ります。 <xref:System.Net.Sockets.Socket.Receive%2A> コネクションレスプロトコルを使用している場合は、 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドを使用することもできます。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>では、任意のホストから到着したデータを受信できます。  
  
 読み取り<xref:System.Net.Sockets.Socket.Receive%2A>可能なデータがない場合は、を使用<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>してタイムアウト値が設定されていない限り、データが使用可能になるまで、メソッドはブロックされます。 タイムアウト値を超えた場合、 <xref:System.Net.Sockets.Socket.Receive%2A>を<xref:System.Net.Sockets.SocketException>呼び出すと、がスローされます。 非ブロッキングモードで、プロトコルスタックバッファーのに使用できるデータがない場合、 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドは直ちに完了し、を<xref:System.Net.Sockets.SocketException>スローします。 プロパティを使用し<xref:System.Net.Sockets.Socket.Available%2A>て、データを読み取り可能にするかどうかを判断できます。 が<xref:System.Net.Sockets.Socket.Available%2A> 0 以外の場合は、受信操作を再試行します。  
  
 接続指向<xref:System.Net.Sockets.Socket>のを使用している場合、 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドは、バッファーのサイズまで、使用可能な限り多くのデータを読み取ります。 リモートホストが<xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.Socket.Shutdown%2A>メソッドとの接続を切断し、使用可能なすべてのデータを受信した<xref:System.Net.Sockets.Socket.Receive%2A>場合、メソッドは直ちに完了し、0バイトを返します。  
  
 コネクションレス<xref:System.Net.Sockets.Socket>を使用している<xref:System.Net.Sockets.Socket.Receive%2A>場合、は、 <xref:System.Net.Sockets.Socket.Connect%2A>メソッドで指定した送信先アドレスからキューに置かれた最初のデータグラムを読み取ります。 受信したデータグラムが`buffer`パラメーターのサイズよりも大きい場合は、 `buffer`メッセージの最初の部分を入力し、余分な<xref:System.Net.Sockets.SocketException>データが失われてがスローされます。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、接続さ<xref:System.Net.Sockets.Socket>れているでデータを受信します。  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるために使用します。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Receive buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">受信したデータを格納する <see cref="T:System.Byte" /> 型の複数の <see cref="T:System.ArraySegment`1" /> のリスト。</param>
        <summary>バインドされた <see cref="T:System.Net.Sockets.Socket" /> からデータを受信して、受信バッファーのリストに格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、buffers パラメーターにデータを読み込み、正常に読み取られたバイト数を返します。 接続指向ソケットとコネクションレスソケットの両方からを呼び出すことができます。  
  
 このオーバーロードでは、1つ以上の受信バッファーを指定する必要があります。  
  
 接続指向プロトコルを使用している場合は、を呼び出し<xref:System.Net.Sockets.Socket.Connect%2A>てリモートホスト接続を確立するか<xref:System.Net.Sockets.Socket.Accept%2A> 、を呼び出す<xref:System.Net.Sockets.Socket.Receive%2A>前に受信接続を受け入れる必要があります。 メソッドは、メソッド<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドで確立されたリモートホスト接続から受信したデータのみを読み取ります。 <xref:System.Net.Sockets.Socket.Receive%2A> コネクションレスプロトコルを使用している場合は、 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドを使用することもできます。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>では、任意のホストから到着したデータを受信できます。  
  
 読み取り<xref:System.Net.Sockets.Socket.Receive%2A>可能なデータがない場合は、を使用<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>してタイムアウト値が設定されていない限り、データが使用可能になるまで、メソッドはブロックされます。 タイムアウト値を超えた場合、 <xref:System.Net.Sockets.Socket.Receive%2A>を<xref:System.Net.Sockets.SocketException>呼び出すと、がスローされます。 非ブロッキングモードで、プロトコルスタックバッファーのに使用できるデータがない場合、 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドは直ちに完了し、を<xref:System.Net.Sockets.SocketException>スローします。 プロパティを使用し<xref:System.Net.Sockets.Socket.Available%2A>て、データを読み取り可能にするかどうかを判断できます。 が<xref:System.Net.Sockets.Socket.Available%2A> 0 以外の場合は、受信操作を再試行します。  
  
 接続指向<xref:System.Net.Sockets.Socket>のを使用している場合、 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドは、バッファーのサイズまで、使用可能な限り多くのデータを読み取ります。 リモートホストが<xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.Socket.Shutdown%2A>メソッドとの接続を切断し、使用可能なすべてのデータを受信した<xref:System.Net.Sockets.Socket.Receive%2A>場合、メソッドは直ちに完了し、0バイトを返します。  
  
 コネクションレス<xref:System.Net.Sockets.Socket>型を使用して<xref:System.Net.Sockets.Socket.Receive%2A>いる場合、は、 <xref:System.Net.Sockets.Socket.Connect%2A>メソッドで指定した宛先アドレスからエンキューされた最初のデータグラムを読み取ります。 受信したデータグラムが`buffers`パラメーターのサイズよりも大きい場合は、 `buffers`メッセージの最初の部分を入力し、余分な<xref:System.Net.Sockets.SocketException>データが失われてがスローされます。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
 **メモ**このメンバーは、アプリケーションでネットワークトレースを有効にしたときにトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試みているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、バインドされた <see cref="T:System.Net.Sockets.Socket" /> からデータを受信して受信バッファーに格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Net.Sockets.Socket.Receive%2A>は、バッファーパラメーターにデータを読み込み、正常に読み取られたバイト数を返します。 接続指向ソケット<xref:System.Net.Sockets.Socket.Receive%2A>とコネクションレスソケットの両方からを呼び出すことができます。  
  
 このオーバーロードでは、受信バッファーと必要な<xref:System.Net.Sockets.SocketFlags>を指定する必要があります。 バッファーオフセットは既定で0に設定され、サイズは既定でバイトパラメーターの長さに設定されます。  
  
 接続指向プロトコルを使用している場合は、を呼び出し<xref:System.Net.Sockets.Socket.Connect%2A>てリモートホスト接続を確立するか<xref:System.Net.Sockets.Socket.Accept%2A> 、を呼び出す<xref:System.Net.Sockets.Socket.Receive%2A>前に受信接続を受け入れる必要があります。 メソッドは、メソッド<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドで確立されたリモートホストから到着したデータのみを読み取ります。 <xref:System.Net.Sockets.Socket.Receive%2A> コネクションレスプロトコルを使用している場合は、 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドを使用することもできます。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>では、任意のホストから到着したデータを受信できます。  
  
 読み取り可能なデータがない場合、メソッド<xref:System.Net.Sockets.Socket.Receive%2A>はデータが使用可能になるまでブロックします。 非ブロッキングモードで、プロトコルスタックバッファー <xref:System.Net.Sockets.Socket.Receive%2A>に使用できるデータがない場合、メソッドは直ちに完了し、を<xref:System.Net.Sockets.SocketException>スローします。 プロパティを使用し<xref:System.Net.Sockets.Socket.Available%2A>て、データを読み取り可能にするかどうかを判断できます。 が<xref:System.Net.Sockets.Socket.Available%2A> 0 以外の場合は、受信操作を再試行してください。  
  
 接続指向<xref:System.Net.Sockets.Socket>のを使用している場合<xref:System.Net.Sockets.Socket.Receive%2A> 、メソッドは、バッファーのサイズまで使用可能な量のデータを読み取ります。 リモートホストが<xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.Socket.Shutdown%2A>メソッドとの接続を切断し、使用可能なすべてのデータを受信した<xref:System.Net.Sockets.Socket.Receive%2A>場合、メソッドは直ちに完了し、0バイトを返します。  
  
 コネクションレス<xref:System.Net.Sockets.Socket>型を使用して<xref:System.Net.Sockets.Socket.Receive%2A>いる場合、は、 <xref:System.Net.Sockets.Socket.Connect%2A>メソッドで指定した宛先アドレスからエンキューされた最初のデータグラムを読み取ります。 受信したデータグラムが`buffer`パラメーターのサイズよりも大きい場合は、 `buffer`メッセージの最初の部分を入力し、余分な<xref:System.Net.Sockets.SocketException>データが失われてがスローされます。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、データバッファー <xref:System.Net.Sockets.SocketFlags>を指定し、接続されている<xref:System.Net.Sockets.Socket>でデータを受信します。  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるために使用します。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">受信したデータを格納する <see cref="T:System.Byte" /> 型の複数の <see cref="T:System.ArraySegment`1" /> のリスト。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、バインドされた <see cref="T:System.Net.Sockets.Socket" /> からデータを受信して受信バッファーのリストに格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、 `buffers`パラメーターにデータを読み込み、正常に読み取られたバイト数を返します。 接続指向ソケットとコネクションレスソケットの両方からを呼び出すことができます。  
  
 このオーバーロードでは、1つ以上の受信バッファーを指定する必要があります。 既定値は<xref:System.Net.Sockets.SocketFlags> です。<xref:System.Net.Sockets.SocketFlags.None>  
  
 接続指向プロトコルを使用している場合は、を呼び出し<xref:System.Net.Sockets.Socket.Connect%2A>てリモートホスト接続を確立するか<xref:System.Net.Sockets.Socket.Accept%2A> 、を呼び出す<xref:System.Net.Sockets.Socket.Receive%2A>前に受信接続を受け入れる必要があります。 メソッドは、メソッド<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドで確立されたリモートホスト接続から受信したデータのみを読み取ります。 <xref:System.Net.Sockets.Socket.Receive%2A> コネクションレスプロトコルを使用している場合は、 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドを使用することもできます。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>では、任意のホストから到着したデータを受信できます。  
  
 読み取り<xref:System.Net.Sockets.Socket.Receive%2A>可能なデータがない場合は、を使用<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>してタイムアウト値が設定されていない限り、データが使用可能になるまで、メソッドはブロックされます。 タイムアウト値を超えた場合、この呼び出しは<xref:System.Net.Sockets.Socket.Receive%2A>を<xref:System.Net.Sockets.SocketException>スローします。 非ブロッキングモードで、プロトコルスタックバッファーのに使用できるデータがない場合、 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドは直ちに完了し、を<xref:System.Net.Sockets.SocketException>スローします。 プロパティを使用し<xref:System.Net.Sockets.Socket.Available%2A>て、データを読み取り可能にするかどうかを判断できます。 が<xref:System.Net.Sockets.Socket.Available%2A> 0 以外の場合は、受信操作を再試行します。  
  
 接続指向<xref:System.Net.Sockets.Socket>のを使用している場合、 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドは、バッファーのサイズまで、使用可能な限り多くのデータを読み取ります。 リモートホストが<xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.Socket.Shutdown%2A>メソッドとの接続を切断し、使用可能なすべてのデータを受信した<xref:System.Net.Sockets.Socket.Receive%2A>場合、メソッドは直ちに完了し、0バイトを返します。  
  
 コネクションレス<xref:System.Net.Sockets.Socket>型を使用して<xref:System.Net.Sockets.Socket.Receive%2A>いる場合、は、 <xref:System.Net.Sockets.Socket.Connect%2A>メソッドで指定した宛先アドレスからエンキューされた最初のデータグラムを読み取ります。 受信したデータグラムが`buffers`パラメーターのサイズよりも大きい場合は、 `buffers`メッセージの最初の部分を入力し、余分な<xref:System.Net.Sockets.SocketException>データが失われてがスローされます。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例は、接続さ<xref:System.Net.Sockets.Socket>れたでデータを受信する方法を示しています。  
  
 [!code-cpp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CPP/sendgeneric.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CS/sendgeneric.cs#2)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="buffers" />.Count が 0 です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試みているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるために使用します。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、バインドされた <see cref="T:System.Net.Sockets.Socket" /> から指定したバイト数のデータを受信して受信バッファーに格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Net.Sockets.Socket.Receive%2A>は、 `buffer`パラメーターにデータを読み込み、正常に読み取られたバイト数を返します。 接続指向ソケット<xref:System.Net.Sockets.Socket.Receive%2A>とコネクションレスソケットの両方からを呼び出すことができます。  
  
 このオーバーロードでは、受信バッファー、受信するバイト数、および必要な<xref:System.Net.Sockets.SocketFlags>を指定する必要があります。  
  
 接続指向プロトコルを使用している場合は、を呼び出し<xref:System.Net.Sockets.Socket.Connect%2A>てリモートホスト接続を確立するか<xref:System.Net.Sockets.Socket.Accept%2A> 、を呼び出す<xref:System.Net.Sockets.Socket.Receive%2A>前に受信接続を受け入れる必要があります。 メソッドは、メソッド<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドで確立されたリモートホストから到着したデータのみを読み取ります。 <xref:System.Net.Sockets.Socket.Receive%2A> コネクションレスプロトコルを使用している場合は、 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドを使用することもできます。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>では、任意のホストから到着したデータを受信できます。  
  
 読み取り<xref:System.Net.Sockets.Socket.Receive%2A>可能なデータがない場合は、を使用<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>してタイムアウト値が設定されていない限り、データが使用可能になるまで、メソッドはブロックされます。 タイムアウト値を超えた場合、 <xref:System.Net.Sockets.Socket.Receive%2A>を<xref:System.Net.Sockets.SocketException>呼び出すと、がスローされます。 非ブロッキングモードで、プロトコルスタックバッファーのに使用できるデータがない場合、 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドは直ちに完了し、を<xref:System.Net.Sockets.SocketException>スローします。 プロパティを使用し<xref:System.Net.Sockets.Socket.Available%2A>て、データを読み取り可能にするかどうかを判断できます。 が<xref:System.Net.Sockets.Socket.Available%2A> 0 以外の場合は、受信操作を再試行してください。  
  
 接続指向<xref:System.Net.Sockets.Socket> `size`のを使用している場合、メソッドは、パラメーターで指定されたバイト数まで、使用可能な量のデータを読み取ります。<xref:System.Net.Sockets.Socket.Receive%2A> リモートホストが<xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.Socket.Shutdown%2A>メソッドとの接続を切断し、使用可能なすべてのデータを受信した<xref:System.Net.Sockets.Socket.Receive%2A>場合、メソッドは直ちに完了し、0バイトを返します。  
  
 コネクションレス<xref:System.Net.Sockets.Socket>を使用している<xref:System.Net.Sockets.Socket.Receive%2A>場合、は、 <xref:System.Net.Sockets.Socket.Connect%2A>メソッドで指定した送信先アドレスからキューに置かれた最初のデータグラムを読み取ります。 受信したデータグラムが`buffer`パラメーターのサイズよりも大きい場合は、 `buffer`メッセージの最初の部分を入力し、余分な<xref:System.Net.Sockets.SocketException>データが失われてがスローされます。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のは、に`buffer`あるデータを受け取り、に<xref:System.Net.Sockets.SocketFlags>を指定<xref:System.Net.Sockets.SocketFlags.None>します。  
  
 [!code-cpp[Socket_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size" /> が <paramref name="buffer" /> のサイズを超えています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるために使用します。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">受信したデータを格納する <see cref="T:System.Byte" /> 型の複数の <see cref="T:System.ArraySegment`1" /> のリスト。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="errorCode">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、バインドされた <see cref="T:System.Net.Sockets.Socket" /> からデータを受信して受信バッファーのリストに格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、 `buffers`パラメーターにデータを読み込み、正常に読み取られたバイト数を返します。 接続指向ソケットとコネクションレスソケットの両方からを呼び出すことができます。  
  
 このオーバーロードでは、1つ以上の受信バッファーを指定する必要があります。 既定値は<xref:System.Net.Sockets.SocketFlags> です。<xref:System.Net.Sockets.SocketFlags.None>  
  
 接続指向プロトコルを使用している場合は、を呼び出し<xref:System.Net.Sockets.Socket.Connect%2A>てリモートホスト接続を確立するか<xref:System.Net.Sockets.Socket.Accept%2A> 、を呼び出す<xref:System.Net.Sockets.Socket.Receive%2A>前に受信接続を受け入れる必要があります。 メソッドは、メソッド<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドで確立されたリモートホスト接続から受信したデータのみを読み取ります。 <xref:System.Net.Sockets.Socket.Receive%2A> コネクションレスプロトコルを使用している場合は、 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドを使用することもできます。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>では、任意のホストから到着したデータを受信できます。  
  
 読み取り<xref:System.Net.Sockets.Socket.Receive%2A>可能なデータがない場合は、を使用<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>してタイムアウト値が設定されていない限り、データが使用可能になるまで、メソッドはブロックされます。 タイムアウト値を超えた場合、この呼び出しは<xref:System.Net.Sockets.Socket.Receive%2A>を<xref:System.Net.Sockets.SocketException>スローします。 非ブロッキングモードで、プロトコルスタックバッファーのに使用できるデータがない場合、 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドは直ちに完了し、を<xref:System.Net.Sockets.SocketException>スローします。 プロパティを使用し<xref:System.Net.Sockets.Socket.Available%2A>て、データを読み取り可能にするかどうかを判断できます。 が<xref:System.Net.Sockets.Socket.Available%2A> 0 以外の場合は、受信操作を再試行します。  
  
 接続指向<xref:System.Net.Sockets.Socket>のを使用している場合、 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドは、バッファーのサイズまで、使用可能な限り多くのデータを読み取ります。 リモートホストが<xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.Socket.Shutdown%2A>メソッドとの接続を切断し、使用可能なすべてのデータを受信した<xref:System.Net.Sockets.Socket.Receive%2A>場合、メソッドは直ちに完了し、0バイトを返します。  
  
 コネクションレス<xref:System.Net.Sockets.Socket>を使用している<xref:System.Net.Sockets.Socket.Receive%2A>場合、は、 <xref:System.Net.Sockets.Socket.Connect%2A>メソッドで指定した送信先アドレスからキューに置かれた最初のデータグラムを読み取ります。 受信したデータグラムが`buffers`パラメーターのサイズよりも大きい場合は、 `buffers`メッセージの最初の部分を入力し、余分な<xref:System.Net.Sockets.SocketException>データが失われてがスローされます。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="buffers" />.Count が 0 です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試みているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるために使用します。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの格納場所である、<see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">受信データを格納する <paramref name="buffer" />内の場所。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、バインドされた <see cref="T:System.Net.Sockets.Socket" /> から指定したバイト数のデータを受信して、受信バッファー内の指定したオフセット位置に格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Net.Sockets.Socket.Receive%2A>は、バッファーパラメーターにデータを読み込み、正常に読み取られたバイト数を返します。 接続指向ソケット<xref:System.Net.Sockets.Socket.Receive%2A>とコネクションレスソケットの両方からを呼び出すことができます。  
  
 接続指向プロトコルを使用している場合は、を呼び出し<xref:System.Net.Sockets.Socket.Connect%2A>てリモートホスト接続を確立するか<xref:System.Net.Sockets.Socket.Accept%2A> 、を呼び出す<xref:System.Net.Sockets.Socket.Receive%2A>前に受信接続を受け入れる必要があります。 メソッドは、メソッド<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドで確立されたリモートホストから到着したデータのみを読み取ります。 <xref:System.Net.Sockets.Socket.Receive%2A> コネクションレスプロトコルを使用している場合は、 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドを使用することもできます。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>では、任意のホストから到着したデータを受信できます。  
  
 読み取り<xref:System.Net.Sockets.Socket.Receive%2A>可能なデータがない場合は、を使用<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>してタイムアウト値が設定されていない限り、データが使用可能になるまで、メソッドはブロックされます。 タイムアウト値を超えた場合、 <xref:System.Net.Sockets.Socket.Receive%2A>を<xref:System.Net.Sockets.SocketException>呼び出すと、がスローされます。 非ブロッキングモードで、プロトコルスタックバッファーのに使用できるデータがない場合、 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドは直ちに完了し、を<xref:System.Net.Sockets.SocketException>スローします。 ソケットへのアクセスを試行しているときにエラーが発生しました。 以下の解説を参照してください。 プロパティを使用し<xref:System.Net.Sockets.Socket.Available%2A>て、データを読み取り可能にするかどうかを判断できます。 が<xref:System.Net.Sockets.Socket.Available%2A> 0 以外の場合は、受信操作を再試行します。  
  
 接続指向<xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.Socket.Receive%2A>のを使用している場合、メソッドは、size パラメーターで指定されたバイト数まで、使用可能な量のデータを読み取ります。 リモートホストが<xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.Socket.Shutdown%2A>メソッドとの接続を切断し、使用可能なすべてのデータを受信した<xref:System.Net.Sockets.Socket.Receive%2A>場合、メソッドは直ちに完了し、0バイトを返します。  
  
 コネクションレス<xref:System.Net.Sockets.Socket>を使用している<xref:System.Net.Sockets.Socket.Receive%2A>場合、は、 <xref:System.Net.Sockets.Socket.Connect%2A>メソッドで指定した送信先アドレスからキューに置かれた最初のデータグラムを読み取ります。 受信したデータグラムが`buffer`パラメーターのサイズよりも大きい場合は、 `buffer`メッセージの最初の部分を入力し、余分な<xref:System.Net.Sockets.SocketException>データが失われてがスローされます。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、接続されている<xref:System.Net.Sockets.Socket>でデータを受信する前に、データバッファー、オフセット、サイズ、およびソケットフラグを指定しています。  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> が 0 未満です。  
  
- または - 
 <paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  
  
- または - 
 <paramref name="size" /> が 0 未満です。  
  
- または - 
 <paramref name="size" /> が、<paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> は、値の有効な組み合わせではありません。  
  
- または - 
<see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> プロパティが設定されていませんでした。  
  
- または - 
<see cref="T:System.Net.Sockets.Socket" /> にアクセス中にオペレーティング システム エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるために使用します。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">受信したデータを格納する、<paramref name="buffer" /> パラメーター内の位置。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="errorCode">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、バインドされた <see cref="T:System.Net.Sockets.Socket" /> からデータを受信して受信バッファーに格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Net.Sockets.Socket.Receive%2A>は、バッファーパラメーターにデータを読み込み、正常に読み取られたバイト数を返します。 接続指向ソケット<xref:System.Net.Sockets.Socket.Receive%2A>とコネクションレスソケットの両方からを呼び出すことができます。  
  
 接続指向プロトコルを使用している場合は、を呼び出し<xref:System.Net.Sockets.Socket.Connect%2A>てリモートホスト接続を確立するか<xref:System.Net.Sockets.Socket.Accept%2A> 、を呼び出す<xref:System.Net.Sockets.Socket.Receive%2A>前に受信接続を受け入れる必要があります。 メソッドは、メソッド<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドで確立されたリモートホストから到着したデータのみを読み取ります。 <xref:System.Net.Sockets.Socket.Receive%2A> コネクションレスプロトコルを使用している場合は、 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドを使用することもできます。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>では、任意のホストから到着したデータを受信できます。  
  
 読み取り<xref:System.Net.Sockets.Socket.Receive%2A>可能なデータがない場合は、を使用<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>してタイムアウト値が設定されていない限り、データが使用可能になるまで、メソッドはブロックされます。 タイムアウト値を超えた場合、 <xref:System.Net.Sockets.Socket.Receive%2A>を<xref:System.Net.Sockets.SocketException>呼び出すと、がスローされます。 非ブロッキングモードで、プロトコルスタックバッファーのに使用できるデータがない場合、 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドは直ちに完了し、を<xref:System.Net.Sockets.SocketException>スローします。 ソケットへのアクセスを試行しているときにエラーが発生しました。 以下の解説を参照してください。 プロパティを使用し<xref:System.Net.Sockets.Socket.Available%2A>て、データを読み取り可能にするかどうかを判断できます。 が<xref:System.Net.Sockets.Socket.Available%2A> 0 以外の場合は、受信操作を再試行します。  
  
 接続指向<xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.Socket.Receive%2A>のを使用している場合、メソッドは、size パラメーターで指定されたバイト数まで、使用可能な量のデータを読み取ります。 リモートホストが<xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.Socket.Shutdown%2A>メソッドとの接続を切断し、使用可能なすべてのデータを受信した<xref:System.Net.Sockets.Socket.Receive%2A>場合、メソッドは直ちに完了し、0バイトを返します。  
  
 コネクションレス<xref:System.Net.Sockets.Socket>を使用している<xref:System.Net.Sockets.Socket.Receive%2A>場合、は、 <xref:System.Net.Sockets.Socket.Connect%2A>メソッドで指定した送信先アドレスからキューに置かれた最初のデータグラムを読み取ります。 受信したデータグラムが`buffer`パラメーターのサイズよりも大きい場合は、 `buffer`メッセージの最初の部分を入力し、余分な<xref:System.Net.Sockets.SocketException>データが失われてがスローされます。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> が 0 未満です。  
  
- または - 
 <paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  
  
- または - 
 <paramref name="size" /> が 0 未満です。  
  
- または - 
 <paramref name="size" /> が、<paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> は、値の有効な組み合わせではありません。  
  
または 
<see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> プロパティが設定されていません。  
  
- または - 
<see cref="T:System.Net.Sockets.Socket" /> にアクセス中にオペレーティング システム エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるために使用します。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</param>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> オブジェクトからデータを受信する非同期要求を開始します。</summary>
        <returns>I/O 操作が保留中の場合は <see langword="true" />。 操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。  
  
 I/O 操作が同期的に完了した場合は <see langword="false" />。 この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Net.Sockets.Socket.ReceiveAsync%2A>は、接続されたソケットまたはバインドされたコネクションレスソケットで使用され、受信データの読み取りに使用されます。 ソケットのローカルアドレスがわかっている必要があります。  
  
 バインドされたコネクションレスソケットの場合、この関数は、受信したメッセージが受け入れられるアドレスを制限します。 関数は、接続で指定されたリモートアドレスからのメッセージのみを返します。 他のアドレスからのメッセージは、暗黙的に破棄されます。  
  
 `e`パラメーター <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType>のプロパティは、windows ソケットサービスプロバイダーに読み取り要求に関する追加情報を提供します。 このパラメーターの使用方法の詳細については<xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>、「」を参照してください。  
  
 このメソッドを正常に呼び出すに<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>は、オブジェクトの次のプロパティとイベントが必要です。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> または <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>が<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>設定されている場合  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>が<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>設定されている場合  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼び出し元は、 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> <xref:System.Net.Sockets.Socket.ReceiveAsync%2A>メソッドを呼び出す前に、プロパティを任意のユーザー状態オブジェクトに設定できます。これにより、コールバックメソッドで情報を取得できるようになります。 コールバックが1つのオブジェクトよりも多くの情報を必要とする場合は、他の必要な状態情報をメンバーとして保持するために、小さなクラスを作成できます。  
  
 バイトストリームスタイルのソケットの場合、バッファーがいっぱいになるか、接続が閉じられるか、内部バッファーデータが使い果たされるまで、受信データがバッファーに配置されます。  
  
 メッセージ指向のソケットの場合、受信メッセージは、 `e`パラメーターに関連付けられているバッファーの合計サイズまでバッファーに配置されます。 メッセージがバッファーより大きい場合、バッファーにはメッセージの最初の部分が格納されます。  
  
 接続指向のソケットの場合、 <xref:System.Net.Sockets.Socket.ReceiveAsync%2A>メソッドは、ソケットがバイトストリームかメッセージ指向かに応じて、2つの方法のいずれかで仮想回線の正常な終了を示すことができます。 バイトストリームの場合、読み取られたゼロバイトは正常に終了したことを示し、これ以上バイトは読み取られません。 ゼロバイトのメッセージが許容されるメッセージ指向のソケットの場合、ネイティブ<xref:System.Net.Sockets.SocketException> Winsock WSAEDISCON <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>エラーコード (10101) に設定されたを使用して、正常なクロージャを示すことができます。 いずれの場合も、 <xref:System.Net.Sockets.SocketException>が<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>ネイティブ Winsock WSAECONNRESET エラーコード (10054) に設定されたを使用すると、強制終了が発生したことを示します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">引数が無効です。 <paramref name="e" /> パラメーターの <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> プロパティまたは <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> プロパティは、有効なバッファーを参照する必要があります。 これらのプロパティは、どちらか 1 つを設定できます。一度に両方のプロパティを設定することはできません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="e" /> パラメーターに指定された <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクトを使用してソケット操作が既に進行していました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows XP 以降が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveBufferSize">
      <MemberSignature Language="C#" Value="public int ReceiveBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> の受信バッファーのサイズを指定する値を取得または設定します。</summary>
        <value>受信バッファーのサイズ (バイト単位) を格納している <see cref="T:System.Int32" />。 既定値は 8192 です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 バッファーサイズを大きくすると、空の受信確認 (データ部分のない TCP パケット) の数が減少する可能性がありますが、接続の問題の認識が遅れる可能性もあります。 大きなファイルを転送する場合や、高帯域幅の高待機時間接続 (サテライトブロードバンドプロバイダーなど) を使用している場合は、バッファーサイズを大きくすることを検討してください。  
  
   
  
## Examples  
 次のコード例は、 <xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A>プロパティの使用方法を示しています。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">設定操作として指定された値が 0 未満です。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveFrom">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>データグラムを受信し、ソース エンドポイントを格納します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFrom (buffer As Byte(), ByRef remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] *  -&gt; int" Usage="socket.ReceiveFrom (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの格納場所である、<see cref="T:System.Byte" /> 型の配列。</param>
        <param name="remoteEP">リモート サーバーを表す、参照渡しされた <see cref="T:System.Net.EndPoint" />。</param>
        <summary>データグラムを受信してデータバッファーに格納します。さらに、エンドポイントを格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>は、 `buffer`パラメーターにデータを読み込み、正常に読み取られたバイト数を返し、データの送信元のリモートホストエンドポイントをキャプチャします。 この方法は、不明なホストまたは複数のホストからコネクションレスのデータグラムを受信する場合に便利です。  
  
 このオーバーロードでは、受信`buffer` <xref:System.Net.EndPoint>を指定するだけで、リモートホストを表すを使用する必要があります。 バッファーオフセットの既定値は0です。 サイズの既定値は`buffer`パラメーターの長さで、既定値は`socketFlags`に<xref:System.Net.Sockets.SocketFlags.None>設定されます。  
  
> [!NOTE]
>  を呼び出す<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>前に、 <xref:System.Net.Sockets.Socket.Bind%2A>メソッドを使用<xref:System.Net.Sockets.Socket>してをローカルエンドポイントに明示的にバインドする必要があります。 そうしないと、 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>はを<xref:System.Net.Sockets.SocketException>スローします。  
  
 コネクションレスプロトコルを<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>使用すると、は、ローカルネットワークバッファーに受信した最初のエンキューされたデータグラムを読み取ります。 受信したデータグラムがのサイズを超える場合、 `buffer`メソッドは<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>可能な限り`buffer`多くのメッセージを格納し、を<xref:System.Net.Sockets.SocketException>スローします。 信頼性の低いプロトコルを使用している場合は、余分なデータが失われます。 信頼できるプロトコルを使用している場合は、余分なデータがサービスプロバイダーによって保持され、十分な<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>大きさのバッファーを持つメソッドを呼び出すことによって取得できます。  
  
 読み取り可能なデータがない場合、メソッド<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>はデータが使用可能になるまでブロックします。 非ブロッキングモードで、プロトコルスタックバッファーのに使用できるデータがない場合、 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドは直ちに完了し、を<xref:System.Net.Sockets.SocketException>スローします。 プロパティを使用し<xref:System.Net.Sockets.Socket.Available%2A>て、データを読み取り可能にするかどうかを判断できます。 が<xref:System.Net.Sockets.Socket.Available%2A> 0 以外の場合は、受信操作を再試行します。  
  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>はコネクションレスプロトコルを対象としていますが、接続指向プロトコルを使用することもできます。 これを選択する場合は、最初にメソッドを<xref:System.Net.Sockets.Socket.Connect%2A>呼び出してリモートホスト接続を確立するか、 <xref:System.Net.Sockets.Socket.Accept%2A>メソッドを呼び出して受信リモートホスト接続を受け入れる必要があります。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドを呼び出す前に接続を確立または受け入れない場合は、 <xref:System.Net.Sockets.SocketException>が取得されます。 また、 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドを呼び出す前に、コネクションレスプロトコルの既定のリモートホストを確立することもできます。 どちらの場合<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>も、メソッドは`remoteEP`パラメーターを無視し、接続されたまたは既定のリモートホストからのデータのみを受信します。  
  
 接続指向のソケットを使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>すると、はのサイズまで使用可能な量の`buffer`データを読み取ります。 リモートホストが<xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.Socket.Shutdown%2A>メソッドとの接続を切断し、使用可能なすべてのデータを受信した<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>場合、メソッドは直ちに完了し、0バイトを返します。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily> で<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>使用されるのは、 <xref:System.Net.EndPoint>で使用さ<xref:System.Net.Sockets.Socket.SendTo%2A>れているのと一致する必要<xref:System.Net.Sockets.AddressFamily>があります。 <xref:System.Net.EndPoint>  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、リモートホストからコネクションレスのデータグラムを受信します。  
  
 [!code-cpp[Socket_Sync_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Sync_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Sync_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="remoteEP" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるために使用します。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP">リモート サーバーを表す、参照渡しされた <see cref="T:System.Net.EndPoint" />。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、データグラムを受信してデータバッファーに格納します。さらに、エンドポイントを格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>は、 `buffer`パラメーターにデータを読み込み、正常に読み取られたバイト数を返し、データの送信元のリモートホストエンドポイントをキャプチャします。 この方法は、不明なホストまたは複数のホストからコネクションレスのデータグラムを受信する場合に便利です。  
  
 このオーバーロードでは、受信バッファー、必要な<xref:System.Net.Sockets.SocketFlags>、 <xref:System.Net.EndPoint>およびリモートホストを表すが指定されている必要があります。 オフセットの既定値は0で、サイズは既定でバッファーパラメーターの長さに設定されます。  
  
> [!NOTE]
>  を呼び出す<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>前に、 <xref:System.Net.Sockets.Socket.Bind%2A>メソッドを使用<xref:System.Net.Sockets.Socket>してをローカルエンドポイントに明示的にバインドする必要があります。 そうしないと、 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>はを<xref:System.Net.Sockets.SocketException>スローします。  
  
 コネクションレスプロトコルを<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>使用すると、は、ローカルネットワークバッファーに受信した最初のエンキューされたデータグラムを読み取ります。 受信したデータグラムがのサイズを超える場合、 `buffer`メソッドは<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>可能な限り`buffer`多くのメッセージを格納し、を<xref:System.Net.Sockets.SocketException>スローします。 信頼性の低いプロトコルを使用している場合は、余分なデータが失われます。 信頼できるプロトコルを使用している場合は、余分なデータがサービスプロバイダーによって保持され、十分な<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>大きさのバッファーを持つメソッドを呼び出すことによって取得できます。  
  
 読み取り可能なデータがない場合、メソッド<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>はデータが使用可能になるまでブロックします。 非ブロッキングモードで、プロトコルスタックバッファーのに使用できるデータがない場合、 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドは直ちに完了し、を<xref:System.Net.Sockets.SocketException>スローします。 プロパティを使用し<xref:System.Net.Sockets.Socket.Available%2A>て、データを読み取り可能にするかどうかを判断できます。 が<xref:System.Net.Sockets.Socket.Available%2A> 0 以外の場合は、受信操作を再試行します。  
  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>はコネクションレスプロトコルを対象としていますが、接続指向プロトコルを使用することもできます。 これを選択する場合は、最初にメソッドを<xref:System.Net.Sockets.Socket.Connect%2A>呼び出してリモートホスト接続を確立するか、 <xref:System.Net.Sockets.Socket.Accept%2A>メソッドを呼び出して受信リモートホスト接続を受け入れる必要があります。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドを呼び出す前に接続を確立または受け入れない場合は、 <xref:System.Net.Sockets.SocketException>が取得されます。 また、 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドを呼び出す前に、コネクションレスプロトコルの既定のリモートホストを確立することもできます。 どちらの場合<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>も、メソッドは`remoteEP`パラメーターを無視し、接続されたまたは既定のリモートホストからのデータのみを受信します。  
  
 接続指向のソケットを使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>すると、はのサイズまで使用可能な量の`buffer`データを読み取ります。 リモートホストが<xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.Socket.Shutdown%2A>メソッドとの接続を切断し、使用可能なすべてのデータを受信した<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>場合、メソッドは直ちに完了し、0バイトを返します。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily> で<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>使用されるのは、 <xref:System.Net.EndPoint>で使用さ<xref:System.Net.Sockets.Socket.SendTo%2A>れているのと一致する必要<xref:System.Net.Sockets.AddressFamily>があります。 <xref:System.Net.EndPoint>  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、リモートホストからコネクションレスのデータグラムを受信します。 <xref:System.Net.Sockets.SocketFlags>は、 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドに渡されます。  
  
 [!code-cpp[Socket_Sync_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Sync_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Sync_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="remoteEP" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるために使用します。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの格納場所である、<see cref="T:System.Byte" /> 型の配列。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP">リモート サーバーを表す、参照渡しされた <see cref="T:System.Net.EndPoint" />。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、指定したバイト数のデータを受信してデータ バッファーに格納します。さらに、エンドポイントを格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>は、 `buffer`パラメーターにデータを読み込み、正常に読み取られたバイト数を返し、データの送信元のリモートホストエンドポイントをキャプチャします。 この方法は、不明なホストまたは複数のホストからコネクションレスのデータグラムを受信する場合に便利です。  
  
 このオーバーロードで必要なのは、受信バッファー、受信<xref:System.Net.Sockets.SocketFlags>するバイト数、 <xref:System.Net.EndPoint>およびリモートホストを表すを指定することだけです。 バッファーオフセットの既定値は0です。  
  
 コネクションレスプロトコルを<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>使用すると、は、ローカルネットワークバッファーに受信した最初のエンキューされたデータグラムを読み取ります。 受信したデータグラムがのサイズを超える場合、 `buffer`メソッドは<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>可能な限り`buffer`多くのメッセージを格納し、を<xref:System.Net.Sockets.SocketException>スローします。 信頼性の低いプロトコルを使用している場合は、余分なデータが失われます。 信頼できるプロトコルを使用している場合は、余分なデータがサービスプロバイダーによって保持され、十分な<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>大きさのバッファーを持つメソッドを呼び出すことによって取得できます。  
  
 読み取り可能なデータがない場合、メソッド<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>はデータが使用可能になるまでブロックします。 非ブロッキングモードで、プロトコルスタックバッファーのに使用できるデータがない場合、 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドは直ちに完了し、を<xref:System.Net.Sockets.SocketException>スローします。 プロパティを使用し<xref:System.Net.Sockets.Socket.Available%2A>て、データを読み取り可能にするかどうかを判断できます。 が<xref:System.Net.Sockets.Socket.Available%2A> 0 以外の場合は、受信操作を再試行します。  
  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>はコネクションレスプロトコルを対象としていますが、接続指向プロトコルを使用することもできます。 これを選択する場合は、最初にメソッドを<xref:System.Net.Sockets.Socket.Connect%2A>呼び出してリモートホスト接続を確立するか、 <xref:System.Net.Sockets.Socket.Accept%2A>メソッドを呼び出して受信リモートホスト接続を受け入れる必要があります。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドを呼び出す前に接続を確立または受け入れない場合は、 <xref:System.Net.Sockets.SocketException>が取得されます。 また、 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドを呼び出す前に、コネクションレスプロトコルの既定のリモートホストを確立することもできます。 どちらの場合<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>も、メソッドは`remoteEP`パラメーターを無視し、接続されたまたは既定のリモートホストからのデータのみを受信します。  
  
 接続指向のソケットでは<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 、は`size`パラメーターで指定されたバイト数まで、使用可能な量のデータを読み取ります。 リモートホストが<xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.Socket.Shutdown%2A>メソッドとの接続を切断し、使用可能なすべてのデータを受信した<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>場合、メソッドは直ちに完了し、0バイトを返します。  
  
> [!NOTE]
>  を呼び出す<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>前に、 <xref:System.Net.Sockets.Socket.Bind%2A>メソッドを使用<xref:System.Net.Sockets.Socket>してをローカルエンドポイントに明示的にバインドする必要があります。 そうしないと、 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>はを<xref:System.Net.Sockets.SocketException>スローします。 を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily> で<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>使用されるのは、 <xref:System.Net.EndPoint>で使用さ<xref:System.Net.Sockets.Socket.SendTo%2A>れているのと一致する必要<xref:System.Net.Sockets.AddressFamily>があります。 <xref:System.Net.EndPoint>  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、リモートホストからコネクションレスのデータグラムを受信します。 バッファーサイズと<xref:System.Net.Sockets.SocketFlags>は、 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドに渡されます。  
  
 [!code-cpp[Socket_Sync_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Sync_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Sync_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="remoteEP" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size" /> が 0 未満です。  
  
または 
 <paramref name="size" /> が <paramref name="buffer" />の長さを超えています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> は、値の有効な組み合わせではありません。  
  
- または - 
<see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> プロパティが設定されていませんでした。  
  
または 
<see cref="T:System.Net.Sockets.Socket" /> にアクセス中にオペレーティング システム エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるために使用します。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの格納場所である、<see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">受信したデータを格納する、<paramref name="buffer" /> パラメーター内の位置。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP">リモート サーバーを表す、参照渡しされた <see cref="T:System.Net.EndPoint" />。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、指定したバイト数のデータを受信して、データ バッファー内の指定した位置に格納します。またエンドポイントを格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>は、 `buffer`パラメーターにデータを読み込み、正常に読み取られたバイト数を返し、データの送信元のリモートホストエンドポイントをキャプチャします。 この方法は、不明なホストまたは複数のホストからコネクションレスのデータグラムを受信する場合に便利です。  
  
 コネクションレスプロトコルを<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>使用すると、は、ローカルネットワークバッファーに受信した最初のエンキューされたデータグラムを読み取ります。 受信したデータグラムがのサイズを超える場合、 `buffer`メソッドは<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>可能な限り`buffer`多くのメッセージを格納し、を<xref:System.Net.Sockets.SocketException>スローします。 信頼性の低いプロトコルを使用している場合は、余分なデータが失われます。 信頼できるプロトコルを使用している場合は、余分なデータがサービスプロバイダーによって保持され、十分な<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>大きさのバッファーを持つメソッドを呼び出すことによって取得できます。  
  
 読み取り可能なデータがない場合、メソッド<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>はデータが使用可能になるまでブロックします。 非ブロッキングモードで、プロトコルスタックバッファーのに使用できるデータがない場合、 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドは直ちに完了し、を<xref:System.Net.Sockets.SocketException>スローします。 プロパティを使用し<xref:System.Net.Sockets.Socket.Available%2A>て、データを読み取り可能にするかどうかを判断できます。 が<xref:System.Net.Sockets.Socket.Available%2A> 0 以外の場合は、受信操作を再試行します。  
  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>はコネクションレスプロトコルを対象としていますが、接続指向プロトコルを使用することもできます。 これを選択する場合は、最初にメソッドを<xref:System.Net.Sockets.Socket.Connect%2A>呼び出してリモートホスト接続を確立するか、 <xref:System.Net.Sockets.Socket.Accept%2A>メソッドを呼び出して受信リモートホスト接続を受け入れる必要があります。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドを呼び出す前に接続を確立または受け入れない場合は、 <xref:System.Net.Sockets.SocketException>が取得されます。 また、 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドを呼び出す前に、コネクションレスプロトコルの既定のリモートホストを確立することもできます。 どちらの場合<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>も、メソッドは`remoteEP`パラメーターを無視し、接続されたまたは既定のリモートホストからのデータのみを受信します。  
  
 接続指向のソケットでは<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 、は、 `size`パラメーターで指定されたバイト数まで、使用可能な量のデータを読み取ります。 リモートホストが<xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.Socket.Shutdown%2A>メソッドとの接続を切断し、使用可能なすべてのデータを受信した<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>場合、メソッドは直ちに完了し、0バイトを返します。  
  
> [!NOTE]
>  を呼び出す<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>前に、 <xref:System.Net.Sockets.Socket.Bind%2A>メソッドを使用<xref:System.Net.Sockets.Socket>してをローカルエンドポイントに明示的にバインドする必要があります。 そうしないと、 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>はを<xref:System.Net.Sockets.SocketException>スローします。 を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily> で<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>使用されるのは、 <xref:System.Net.EndPoint>で使用さ<xref:System.Net.Sockets.Socket.SendTo%2A>れているのと一致する必要<xref:System.Net.Sockets.AddressFamily>があります。 <xref:System.Net.EndPoint>  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、リモートホストからコネクションレスのデータグラムを受信します。 オフセット、バッファーサイズ、および<xref:System.Net.Sockets.SocketFlags>が<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドに渡されます。  
  
 [!code-cpp[Socket_Sync_Send_Receive#12](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#12)]
 [!code-csharp[Socket_Sync_Send_Receive#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#12)]
 [!code-vb[Socket_Sync_Send_Receive#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> が <see langword="null" /> です。  
  
- または - 
 <paramref name="remoteEP" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> が 0 未満です。  
  
- または - 
 <paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  
  
または 
 <paramref name="size" /> が 0 未満です。  
  
- または - 
 <paramref name="size" /> が、<paramref name="buffer" /> の長さからオフセット パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> は、値の有効な組み合わせではありません。  
  
または 
<see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> プロパティが設定されていませんでした。  
  
- または - 
ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるために使用します。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</param>
        <summary>指定したネットワーク デバイスから、データの非同期の受信を開始します。</summary>
        <returns>I/O 操作が保留中の場合は <see langword="true" />。 操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。  
  
 I/O 操作が同期的に完了した場合は <see langword="false" />。 この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A>は、主にコネクションレスソケットでデータを受信するために使用されます。 ソケットのローカルアドレスがわかっている必要があります。  
  
 呼び出し元は、 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>プロパティを、データを受信するリモートホスト<xref:System.Net.IPEndPoint>のに設定する必要があります。  
  
 `e`パラメーター <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType>のプロパティは、windows ソケットサービスプロバイダーに読み取り要求に関する追加情報を提供します。 このパラメーターの使用方法の詳細については<xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>、「」を参照してください。  
  
 このメソッドを正常に呼び出すに<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>は、オブジェクトの次のプロパティとイベントが必要です。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼び出し元は、 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A>メソッドを呼び出す前に、プロパティを任意のユーザー状態オブジェクトに設定できます。これにより、コールバックメソッドで情報を取得できるようになります。 コールバックが1つのオブジェクトよりも多くの情報を必要とする場合は、他の必要な状態情報をメンバーとして保持するために、小さなクラスを作成できます。  
  
 メッセージ指向のソケットの場合は、バッファーの合計サイズまで、受信メッセージがバッファーに格納されます。 プロパティ<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> と<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>プロパティは、データが格納されるバッファー内の場所とデータ量を決定します。  
  
 バイトストリームスタイルのソケットの場合、バッファーがいっぱいになるか、接続が閉じられるか、内部バッファーデータが使い果たされるまで、受信データがバッファーに配置されます。 プロパティ<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> と<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>プロパティは、データが格納されるバッファー内の場所とデータ量を決定します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> に null 値を指定することはできません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="e" /> パラメーターに指定された <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクトを使用してソケット操作が既に進行していました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows XP 以降が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int ReceiveMessageFrom (byte[] buffer, int offset, int size, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; remoteEP, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFrom (buffer As Byte(), offset As Integer, size As Integer, ByRef socketFlags As SocketFlags, ByRef remoteEP As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % remoteEP, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFrom : byte[] * int * int *  *  *  -&gt; int" Usage="socket.ReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" RefType="ref" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation" RefType="out" Index="5" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの格納場所である、<see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">受信したデータを格納する、<paramref name="buffer" /> パラメーター内の位置。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP">リモート サーバーを表す、参照渡しされた <see cref="T:System.Net.EndPoint" />。</param>
        <param name="ipPacketInformation">アドレスとインターフェイスの情報を保持する <see cref="T:System.Net.Sockets.IPPacketInformation" />。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、指定したバイト数のデータをデータ バッファー内の指定した位置で受信して、エンドポイントおよびパケット情報を格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>は、 `buffer`パラメーターにデータを読み込み、正常に読み取られたバイト数を返します。さらに、データの送信元のリモートホストエンドポイントと、受信パケットに関する情報をキャプチャします。  
  
 メソッド<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>は、主にコネクションレスソケットでメッセージデータを受信するために使用されます。 ソケットのローカルアドレスがわかっている必要があります。 このメソッドは、データグラムと raw ソケットでのみ使用できます。 このメソッドを呼び出す前に、ソケットの種類を<xref:System.Net.Sockets.SocketType.Dgram>また<xref:System.Net.Sockets.SocketType.Raw>はに設定して、ソケットを初期化する必要があります。 これは、を使用して<xref:System.Net.Sockets.Socket.%23ctor%2A>ソケットを構築するときに実行できます。  
  
 メッセージ指向のソケットの場合、パラメーターに指定された`buffer` `size`合計サイズまで、受信メッセージがパラメーターに配置されます。 パラメーター `offset`は、データのどこ`buffer`に配置されるかを決定します。 に`buffer`格納される実際のデータ量は、 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>メソッドによって返されます。  
  
 メソッド<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>は、指定`true`さ<xref:System.Net.Sockets.SocketOptionName.PacketInformation> れたに対して初めて呼び出されるときに、socketオプションを自動的に<xref:System.Net.Sockets.Socket>設定します。 ただし、返さ<xref:System.Net.Sockets.IPPacketInformation>れるオブジェクトは、ソケットオプションが設定された後にローカルコンピューターに到着するパケットに対してのみ有効です。 ソケットがローカルエンドポイントにバインドされる<xref:System.Net.Sockets.Socket.Bind%2A>とき (メソッドによって明示的に、または、、 <xref:System.Net.Sockets.Socket.SendTo%2A>、または<xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.SendToAsync%2A>メソッド<xref:System.Net.Sockets.Socket.ConnectAsync%2A>のいずれかによって暗黙的に指定される<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> ) にパケットが送信される場合は。メソッドでは、 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>メソッドを呼び出す<xref:System.Net.Sockets.IPPacketInformation>と、これらのパケットに対して無効なオブジェクトが返されます。  
  
 すべて<xref:System.Net.Sockets.IPPacketInformation>のオブジェクトが有効であることを確認するには<xref:System.Net.Sockets.SocketOptionName.PacketInformation> 、アプリケーションで`true` socket オプションをに設定してから、 <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29>メソッドを使用してローカルエンドポイントにバインドします。  
  
 アプリケーションでは、ユニ`ipPacketInformation`キャストアドレス、マルチキャストアドレス、またはブロードキャストアドレスを使用してデータグラムが送信されたかどうかを確認する必要がある場合に、パラメーターを調べることができます。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily> で<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>使用されるのは、 <xref:System.Net.EndPoint>で使用さ<xref:System.Net.Sockets.Socket.SendTo%2A>れているのと一致する必要<xref:System.Net.Sockets.AddressFamily>があります。 <xref:System.Net.EndPoint>  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> は <see langword="null" />です。  
  
\- または 
 <paramref name="remoteEP" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> が 0 未満です。  
  
- または - 
 <paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  
  
または 
 <paramref name="size" /> が 0 未満です。  
  
- または - 
 <paramref name="size" /> が、<paramref name="buffer" /> の長さからオフセット パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> は、値の有効な組み合わせではありません。  
  
または 
<see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> プロパティが設定されていませんでした。  
  
- または - 
.NET Framework が、AMD 64 ビット プロセッサ上で実行されています。  
  
- または - 
ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">Windows 2000 以前のオペレーティング システムです。このメソッドを使用するには、Windows XP が必要です。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるために使用します。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveMessageFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveMessageFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveMessageFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveMessageFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="e">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</param>
        <summary>指定された <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" /> を使用し、指定されたバイト数のデータの非同期受信を開始して、データ バッファー内の指定された場所に格納します。さらに、エンドポイントとパケットの情報を格納します。</summary>
        <returns>I/O 操作が保留中の場合は <see langword="true" />。 操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。  
  
 I/O 操作が同期的に完了した場合は <see langword="false" />。 この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>は、主にコネクションレスソケットでメッセージデータを受信するために使用されます。 ソケットのローカルアドレスがわかっている必要があります。 このメソッドは、データグラムと raw ソケットでのみ使用できます。 このメソッドを呼び出す前に、ソケットの種類を<xref:System.Net.Sockets.SocketType.Dgram>また<xref:System.Net.Sockets.SocketType.Raw>はに設定して、ソケットを初期化する必要があります。 これは、を使用して<xref:System.Net.Sockets.Socket.%23ctor%2A>ソケットを構築するときに実行できます。  
  
 呼び出し元は、 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>プロパティを、データを受信するリモートホスト<xref:System.Net.IPEndPoint>のに設定する必要があります。  
  
 このメソッドを正常に呼び出すに<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>は、オブジェクトの次のプロパティとイベントが必要です。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼び出し元は、 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>メソッドを呼び出す前に、プロパティを任意のユーザー状態オブジェクトに設定できます。これにより、コールバックメソッドで情報を取得できるようになります。 コールバックが1つのオブジェクトよりも多くの情報を必要とする場合は、他の必要な状態情報をメンバーとして保持するために、小さなクラスを作成できます。  
  
 メッセージ指向のソケットの場合は、バッファーの合計サイズまで、受信メッセージがバッファーに格納されます。 プロパティ<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> と<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>プロパティは、データが格納されるバッファー内の場所とデータ量を決定します。  
  
 メソッド<xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>は、指定さ<xref:System.Net.Sockets.SocketOptionName.PacketInformation> `true` れたに対して初めて呼び出されるときに、ソケットオプションを自動的に<xref:System.Net.Sockets.Socket>設定します。 ただし、オブジェクトは、ソケットオプションが設定された後にローカルコンピューターに到着するパケットに対してのみ有効です。 <xref:System.Net.Sockets.IPPacketInformation> ソケットがローカルエンドポイントにバインドされたとき<xref:System.Net.Sockets.Socket.Bind%2A> (メソッドによって明示的に、または、、 <xref:System.Net.Sockets.Socket.SendTo%2A>、または<xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.SendToAsync%2A>メソッド<xref:System.Net.Sockets.Socket.ConnectAsync%2A>のいずれかによって暗黙的に呼び出さ<xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>れたとき)に、ソケットがパケットを送信する場合は、メソッドでは、 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>メソッドを呼び出すと<xref:System.Net.Sockets.IPPacketInformation> 、これらのパケットに対して無効なオブジェクトが生成されます。  
  
 すべて<xref:System.Net.Sockets.IPPacketInformation>のオブジェクトが有効であることを確認するには<xref:System.Net.Sockets.SocketOptionName.PacketInformation> 、アプリケーションで`true` socket オプションをに設定してから、 <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29>メソッドを使用してローカルエンドポイントにバインドします。  
  
 アプリケーションは、データグラムがユニ<xref:System.Net.Sockets.IPPacketInformation>キャスト、マルチキャスト、またはブロードキャストアドレスを使用して送信されたかどうかを知る必要がある場合に、結果として得られるオブジェクトを調べることができます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> に null 値を指定することはできません。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows XP 以降が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveTimeout">
      <MemberSignature Language="C#" Value="public int ReceiveTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveTimeout : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>同期の <see cref="Overload:System.Net.Sockets.Socket.Receive" /> 呼び出しがタイムアウトするまでの合計時間を指定する値を取得または設定します。</summary>
        <value>タイムアウト値 (ミリ秒)。 既定値は 0 です。タイムアウトが無期限であることを示します。 -1 の指定も、タイムアウトが無期限であることを示します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオプションは、同期<xref:System.Net.Sockets.Socket.Receive%2A>呼び出しにのみ適用されます。 タイムアウト期間を超過<xref:System.Net.Sockets.Socket.Receive%2A>した場合、メソッドはを<xref:System.Net.Sockets.SocketException>スローします。  
  
   
  
## Examples  
 次のコード例は、 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A>プロパティの使用方法を示しています。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">設定操作として指定された値が -1 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoteEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint RemoteEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint RemoteEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RemoteEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ RemoteEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RemoteEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>リモート エンドポイントを取得します。</summary>
        <value><see cref="T:System.Net.EndPoint" /> の通信先の <see cref="T:System.Net.Sockets.Socket" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向プロトコルを使用している場合、 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>プロパティは、 <xref:System.Net.Sockets.Socket>が<xref:System.Net.EndPoint>接続されているリモート IP アドレスとポート番号を含むを取得します。 コネクションレスプロトコルを使用している<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>場合、には、 <xref:System.Net.Sockets.Socket>が通信する既定のリモート IP アドレスとポート番号が含まれています。 情報を取得する<xref:System.Net.EndPoint>前に<xref:System.Net.IPEndPoint> 、これをにキャストする必要があります。 その後、 <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType>メソッドを呼び出してリモート<xref:System.Net.IPAddress>を<xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType>取得し、メソッドを呼び出してリモートポート番号を取得できます。  
  
 は<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 、 <xref:System.Net.Sockets.Socket.Accept%2A>または<xref:System.Net.Sockets.Socket.Connect%2A>の呼び出しの後に設定されます。 以前にこのプロパティにアクセスしようとする<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>と、は<xref:System.Net.Sockets.SocketException>をスローします。 を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、ローカルとリモートのエンドポイントを取得して表示します。  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SafeSocketHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.SafeSocketHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeSocketHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SafeSocketHandle ^ SafeHandle { System::Net::Sockets::SafeSocketHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeHandle : System.Net.Sockets.SafeSocketHandle" Usage="System.Net.Sockets.Socket.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SafeSocketHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Net.Sockets.Socket" /> オブジェクトによってカプセル化されているソケット ハンドルを表す <see cref="T:System.Net.Sockets.SafeSocketHandle" /> を取得します。</summary>
        <value>現在<see cref="T:System.Net.Sockets.Socket" />のオブジェクトによってカプセル化されるソケットに対して安全な方法で公開されるソケットハンドル。</value>
        <remarks>  
          <format type="text/markdown"><![CDATA[  

> [!IMPORTANT]
> を使用してソケットを直接操作すると、ドキュメント化されていない状態になる場合があります。<xref:System.Net.Sockets.SafeSocketHandle> 

         ]]></format>
         </remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public static void Select (System.Collections.IList checkRead, System.Collections.IList checkWrite, System.Collections.IList checkError, int microSeconds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Select(class System.Collections.IList checkRead, class System.Collections.IList checkWrite, class System.Collections.IList checkError, int32 microSeconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Select (checkRead As IList, checkWrite As IList, checkError As IList, microSeconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Select(System::Collections::IList ^ checkRead, System::Collections::IList ^ checkWrite, System::Collections::IList ^ checkError, int microSeconds);" />
      <MemberSignature Language="F#" Value="static member Select : System.Collections.IList * System.Collections.IList * System.Collections.IList * int -&gt; unit" Usage="System.Net.Sockets.Socket.Select (checkRead, checkWrite, checkError, microSeconds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="checkRead" Type="System.Collections.IList" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="checkWrite" Type="System.Collections.IList" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="checkError" Type="System.Collections.IList" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="microSeconds" Type="System.Int32" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="checkRead">読みやすさを確認する <see cref="T:System.Net.Sockets.Socket" /> インスタンスの <see cref="T:System.Collections.IList" />。</param>
        <param name="checkWrite">書き込み機能をチェックする <see cref="T:System.Net.Sockets.Socket" /> インスタンスの <see cref="T:System.Collections.IList" />。</param>
        <param name="checkError">エラーをチェックする <see cref="T:System.Net.Sockets.Socket" /> インスタンスの <see cref="T:System.Collections.IList" />。</param>
        <param name="microSeconds">タイムアウト値 (マイクロ秒)。 値が -1 の場合は、タイムアウトが無限であることを示します。</param>
        <summary>1 つまたは複数のソケットのステータスを判断します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Select%2A>は、1つ<xref:System.Net.Sockets.Socket>以上のインスタンスの状態を決定する静的メソッドです。 メソッド<xref:System.Net.Sockets.Socket.Select%2A>を使用する前に、 <xref:System.Collections.IList> 1 つまたは複数のソケットをに配置する必要があります。 パラメーターとして<xref:System.Net.Sockets.Socket.Select%2A> <xref:System.Collections.IList>を指定してを呼び出すことにより、読みやすさを確認します。 `checkRead` 書き込み機能のソケットを確認するには`checkWrite` 、パラメーターを使用します。 エラー状態を検出するに`checkError`は、を使用します。 を呼び<xref:System.Net.Sockets.Socket.Select%2A>出すと、条件を満たすソケットだけがに格納されます。<xref:System.Collections.IList>  
  
 リッスン状態の場合、読みやすさとは、の呼び出しがブロック<xref:System.Net.Sockets.Socket.Accept%2A>されずに成功することを意味します。 既に接続を受け入れている場合、読みやすさとは、データが読み取り可能であることを意味します。 このような場合、すべての受信操作はブロックされずに成功します。 また、読みやすさは、リモート<xref:System.Net.Sockets.Socket>が接続をシャットダウンしたかどうかを示すこと<xref:System.Net.Sockets.Socket.Receive%2A>もできます。この場合、への呼び出しは、ゼロバイトが返された直後に戻ります。  
  
 <xref:System.Net.Sockets.Socket.Select%2A>対象のソケットの少なくとも1つ`checkRead`(、 `checkWrite`、および`checkError`リスト内のソケット) が、指定された条件を満たし`microSeconds`ている場合、またはパラメーターの値を超えた場合、いずれか早い方がを返します。 を`microSeconds` -1 に設定すると、無制限のタイムアウトが指定されます。  
  
 に対し<xref:System.Net.Sockets.Socket.Connect%2A>て非ブロッキング呼び出しを行うと、書き込み機能は正常に接続したことを意味します。 既に接続が確立されている場合、書き込み機能は、すべての送信操作がブロックせずに成功することを意味します。  
  
 へ<xref:System.Net.Sockets.Socket.Connect%2A>の非ブロッキング呼び出しを行った場合、パラメーターは`checkerror`正常に接続されていないソケットを識別します。  
  
> [!NOTE]
>  1つ<xref:System.Net.Sockets.Socket.Poll%2A> <xref:System.Net.Sockets.Socket>のの状態のみを確認する場合は、メソッドを使用します。  
  
> [!NOTE]
>  この方法では、ネットワークケーブルの切断など、特定の種類の接続の問題を検出することはできません。また、リモートホストが異常終了をシャットダウンしたことを確認することもできません。 これらの種類のエラーを検出するには、データの送信または受信を試みる必要があります。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
   
  
## Examples  
 次のコード例で<xref:System.Net.Sockets.Socket.Select%2A>は、を使用して、接続要求があるリッスンソケットを特定します。  
  
 [!code-cpp[Socket_Select#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Select/CPP/source.cpp#1)]
 [!code-csharp[Socket_Select#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Select/CS/source.cs#1)]
 [!code-vb[Socket_Select#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Select/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="checkRead" /> パラメーターは <see langword="null" /> または空です。  
  
および 
<paramref name="checkWrite" /> パラメーターは <see langword="null" /> または空です。 
および 
<paramref name="checkError" /> パラメーターは <see langword="null" /> または空です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>接続された <see cref="T:System.Net.Sockets.Socket" /> にデータを送信します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</param>
        <summary>接続された <see cref="T:System.Net.Sockets.Socket" /> にデータを送信します。</summary>
        <returns><see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A><xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドで指定されたリモートホストにデータを同期的に送信し、正常に送信されたバイト数を返します。 <xref:System.Net.Sockets.Socket.Send%2A>は、接続指向プロトコルとコネクションレスプロトコルの両方に使用できます。  
  
 このオーバーロードには、送信するデータを格納するバッファーが必要です。 既定<xref:System.Net.Sockets.SocketFlags>値は0です。バッファーオフセットの既定値は0で、既定で送信されるバイト数はバッファーのサイズに設定されます。  
  
 コネクションレスプロトコルを使用している場合は<xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Send%2A> 、このメソッドを呼び出す前にを呼び出す<xref:System.Net.Sockets.SocketException>必要があります。これを行わないと、がスローされます。 接続指向プロトコルを使用している場合は、を使用<xref:System.Net.Sockets.Socket.Connect%2A>してリモートホスト接続を確立するか、を使用<xref:System.Net.Sockets.Socket.Accept%2A>して受信接続を許可する必要があります。  
  
 コネクションレスプロトコルを使用していて、複数の異なるホストにデータを送信することを<xref:System.Net.Sockets.Socket.SendTo%2A>計画している場合は、メソッドを使用する必要があります。 <xref:System.Net.Sockets.Socket.SendTo%2A>メソッドを使用しない場合は、の各呼び出し<xref:System.Net.Sockets.Socket.Send%2A>の前<xref:System.Net.Sockets.Socket.Connect%2A>にを呼び出す必要があります。 <xref:System.Net.Sockets.Socket.SendTo%2A> を<xref:System.Net.Sockets.Socket.Connect%2A>使用して既定のリモートホストを確立した後でも、を使用できます。 を呼び出す前<xref:System.Net.Sockets.Socket.Send%2A>に、を<xref:System.Net.Sockets.Socket.Connect%2A>もう一度呼び出すことによって、既定のリモートホストを変更することもできます。  
  
 接続指向プロトコルを使用している場合、 <xref:System.Net.Sockets.Socket.Send%2A>は、を使用<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>してタイムアウトが設定されていない限り、バッファー内のすべてのバイトが送信されるまでブロックされます。 タイムアウト値を超えた場合、 <xref:System.Net.Sockets.Socket.Send%2A>を<xref:System.Net.Sockets.SocketException>呼び出すと、がスローされます。 非ブロッキングモードで<xref:System.Net.Sockets.Socket.Send%2A>は、がバッファー内のバイト数よりも少ない場合でも、が正常に完了することがあります。 アプリケーションは、送信されたバイト数を追跡し、アプリケーションがバッファー内のバイトを送信するまで操作を再試行する必要があります。 また、送信したデータがネットワークに直ちに表示される保証もありません。 ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。 <xref:System.Net.Sockets.Socket.Send%2A>メソッドが正常に終了するということは、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されたことは示されません。 転送されるデータを保持するためにトランスポートシステム内で使用できるバッファー領域がない場合、ソケットが非ブロッキングモードに設定されていない限り、send はブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例は、接続さ<xref:System.Net.Sockets.Socket>れたにデータを送信する方法を示しています。  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Send buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">送信するデータを格納する <see cref="T:System.Byte" /> 型の <see cref="T:System.ArraySegment`1" /> のリスト。</param>
        <summary>リスト内のバッファーのセットを接続された <see cref="T:System.Net.Sockets.Socket" /> に送信します。</summary>
        <returns><see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A>は、接続指向プロトコルとコネクションレスプロトコルの両方に使用できます。  
  
 このオーバーロードには、送信するデータを含むバッファーが少なくとも1つ必要です。  
  
 コネクションレスプロトコルを使用している場合は<xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Send%2A> 、このメソッドを呼び出す前にを呼び出す<xref:System.Net.Sockets.SocketException>必要があります。これを行わないと、がスローされます。 接続指向プロトコルを使用している場合は、を使用<xref:System.Net.Sockets.Socket.Connect%2A>してリモートホスト接続を確立するか、を使用<xref:System.Net.Sockets.Socket.Accept%2A>して受信接続を許可する必要があります。  
  
 コネクションレスプロトコルを使用していて、複数の異なるホストにデータを送信することを<xref:System.Net.Sockets.Socket.SendTo%2A>計画している場合は、メソッドを使用する必要があります。 <xref:System.Net.Sockets.Socket.SendTo%2A>メソッドを使用しない場合は、の各呼び出し<xref:System.Net.Sockets.Socket.Send%2A>の前<xref:System.Net.Sockets.Socket.Connect%2A>にを呼び出す必要があります。 <xref:System.Net.Sockets.Socket.SendTo%2A> を<xref:System.Net.Sockets.Socket.Connect%2A>使用して既定のリモートホストを確立した後でも、を使用できます。 を呼び出す前<xref:System.Net.Sockets.Socket.Send%2A>に、を<xref:System.Net.Sockets.Socket.Connect%2A>もう一度呼び出すことによって、既定のリモートホストを変更することもできます。  
  
 接続指向プロトコルを使用している場合、 <xref:System.Net.Sockets.Socket.Send%2A>は、を使用<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>してタイムアウトが設定されていない限り、バッファー内のすべてのバイトが送信されるまでブロックされます。 タイムアウト値を超えた場合、 <xref:System.Net.Sockets.Socket.Send%2A>を<xref:System.Net.Sockets.SocketException>呼び出すと、がスローされます。 非ブロッキングモードで<xref:System.Net.Sockets.Socket.Send%2A>は、がバッファー内のバイト数よりも少ない場合でも、が正常に完了することがあります。 アプリケーションは、送信されたバイト数を追跡し、アプリケーションがバッファー内のバイトを送信するまで操作を再試行する必要があります。 また、送信したデータがネットワークに直ちに表示される保証もありません。 ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。 <xref:System.Net.Sockets.Socket.Send%2A>メソッドが正常に終了するということは、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されたことは示されません。 転送されるデータを保持するためにトランスポートシステム内で使用できるバッファー領域がない場合、ソケットが非ブロッキングモードに設定されていない限り、send はブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> が空です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 以下の解説を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、接続された <see cref="T:System.Net.Sockets.Socket" /> にデータを送信します。</summary>
        <returns><see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A><xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドで確立されたリモートホストにデータを同期的に送信し、正常に送信されたバイト数を返します。 メソッド<xref:System.Net.Sockets.Socket.Send%2A>は、接続指向プロトコルとコネクションレスプロトコルの両方に使用できます。  
  
 このオーバーロードには、送信するデータを格納するバッファーと、のビットごとの<xref:System.Net.Sockets.SocketFlags>組み合わせが必要です。 バッファーオフセットの既定値は0で、既定で送信されるバイト数はバッファーのサイズに設定されます。 パラメーター`socketflags`値とし<xref:System.Net.Sockets.SocketFlags.DontRoute>てフラグを指定した場合、送信するデータはルーティングされません。  
  
 コネクションレスプロトコルを使用している場合は<xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Send%2A> 、このメソッドを呼び出す前にを呼び出す<xref:System.Net.Sockets.SocketException>必要があります。これを行わないと、がスローされます。 接続指向プロトコルを使用している場合は、を使用<xref:System.Net.Sockets.Socket.Connect%2A>してリモートホスト接続を確立するか、を使用<xref:System.Net.Sockets.Socket.Accept%2A>して受信接続を許可する必要があります。  
  
 コネクションレスプロトコルを使用していて、複数の異なるホストにデータを送信することを<xref:System.Net.Sockets.Socket.SendTo%2A>計画している場合は、メソッドを使用する必要があります。 <xref:System.Net.Sockets.Socket.SendTo%2A>メソッドを使用しない場合は、を<xref:System.Net.Sockets.Socket.Send%2A>呼び出すたびに<xref:System.Net.Sockets.Socket.Connect%2A>メソッドを呼び出す必要があります。 <xref:System.Net.Sockets.Socket.SendTo%2A> を<xref:System.Net.Sockets.Socket.Connect%2A>使用して既定のリモートホストを確立した後でも、を使用できます。 を呼び出す前<xref:System.Net.Sockets.Socket.Send%2A>に、を<xref:System.Net.Sockets.Socket.Connect%2A>もう一度呼び出すことによって、既定のリモートホストを変更することもできます。  
  
 接続指向プロトコルを使用している場合、 <xref:System.Net.Sockets.Socket.Send%2A>は、を使用<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>してタイムアウトが設定されていない限り、バッファー内のすべてのバイトが送信されるまでブロックされます。 タイムアウト値を超えた場合、 <xref:System.Net.Sockets.Socket.Send%2A>を<xref:System.Net.Sockets.SocketException>呼び出すと、がスローされます。 非ブロッキングモードで<xref:System.Net.Sockets.Socket.Send%2A>は、がバッファー内のバイト数よりも少ない場合でも、が正常に完了することがあります。 アプリケーションは、送信されたバイト数を追跡し、要求されたバイト数をアプリケーションが送信するまで操作を再試行する必要があります。 また、送信したデータがネットワークに直ちに表示される保証もありません。 ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。 <xref:System.Net.Sockets.Socket.Send%2A>メソッドが正常に終了するということは、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。  
  
> [!NOTE]
>  バッファーのサイズが、基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要があります。 この場合、データグラムは送信<xref:System.Net.Sockets.Socket.Send%2A>されず、が<xref:System.Net.Sockets.SocketException>スローされます。 を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されたことは示されません。 転送されるデータを保持するためにトランスポートシステム内で使用できるバッファー領域がない場合、ソケットが非ブロッキングモードに設定されていない限り、send はブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例は、接続さ<xref:System.Net.Sockets.Socket>れたにデータを送信する方法を示しています。  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">送信するデータを格納する <see cref="T:System.Byte" /> 型の <see cref="T:System.ArraySegment`1" /> のリスト。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、リスト内のバッファーのセットを接続された <see cref="T:System.Net.Sockets.Socket" /> に送信します。</summary>
        <returns><see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードには、送信するデータを含むバッファーが少なくとも1つ必要です。 既定<xref:System.Net.Sockets.SocketFlags>値は0です。 パラメーターとして<xref:System.Net.Sockets.SocketFlags.DontRoute>フラグを指定した場合、送信するデータはルーティングされません。 `socketFlags`  
  
 コネクションレスプロトコルを使用している場合は<xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Send%2A> 、このメソッドを呼び出す前にを呼び出す<xref:System.Net.Sockets.SocketException>必要があります。これを行わないと、がスローされます。 接続指向プロトコルを使用している場合は、を使用<xref:System.Net.Sockets.Socket.Connect%2A>してリモートホスト接続を確立するか、を使用<xref:System.Net.Sockets.Socket.Accept%2A>して受信接続を許可する必要があります。  
  
 コネクションレスプロトコルを使用していて、複数の異なるホストにデータを送信することを<xref:System.Net.Sockets.Socket.SendTo%2A>計画している場合は、メソッドを使用する必要があります。 <xref:System.Net.Sockets.Socket.SendTo%2A>メソッドを使用しない場合は、の各呼び出し<xref:System.Net.Sockets.Socket.Send%2A>の前<xref:System.Net.Sockets.Socket.Connect%2A>にを呼び出す必要があります。 <xref:System.Net.Sockets.Socket.SendTo%2A> を<xref:System.Net.Sockets.Socket.Connect%2A>使用して既定のリモートホストを確立した後でも、を使用できます。 を呼び出す前<xref:System.Net.Sockets.Socket.Send%2A>に、を<xref:System.Net.Sockets.Socket.Connect%2A>もう一度呼び出すことによって、既定のリモートホストを変更することもできます。  
  
 接続指向プロトコルを使用している場合、 <xref:System.Net.Sockets.Socket.Send%2A>は、を使用<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>してタイムアウトが設定されていない限り、バッファー内のすべてのバイトが送信されるまでブロックされます。 タイムアウト値を超えた場合、 <xref:System.Net.Sockets.Socket.Send%2A>を<xref:System.Net.Sockets.SocketException>呼び出すと、がスローされます。 非ブロッキングモードでは、 <xref:System.Net.Sockets.Socket.Send%2A>がバッファー内のバイト数よりも少ない場合でも、が正常に完了することがあります。 アプリケーションは、送信されたバイト数を追跡し、アプリケーションがバッファー内のバイトを送信するまで操作を再試行する必要があります。 また、送信したデータがネットワークに直ちに表示される保証もありません。 ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。 <xref:System.Net.Sockets.Socket.Send%2A>メソッドが正常に終了するということは、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されたことは示されません。 転送されるデータを保持するためにトランスポートシステム内で使用できるバッファー領域がない場合、ソケットが非ブロッキングモードに設定されていない限り、send はブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> が空です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、指定したバイト数のデータを、接続された <see cref="T:System.Net.Sockets.Socket" /> に送信します。</summary>
        <returns><see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A><xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドで確立されたリモートホストにデータを同期的に送信し、正常に送信されたバイト数を返します。 <xref:System.Net.Sockets.Socket.Send%2A>は、接続指向プロトコルとコネクションレスプロトコルの両方に使用できます。  
  
 このオーバーロードには、送信するデータを含むバッファー、送信するバイト数、およびのビットごとの<xref:System.Net.Sockets.SocketFlags>組み合わせが必要です。 パラメーターとして<xref:System.Net.Sockets.SocketFlags.DontRoute>フラグを指定した場合、送信するデータはルーティングされません。 `socketflags`  
  
 コネクションレスプロトコルを使用している場合は<xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Send%2A> 、このメソッドを呼び出す前にを呼び出す<xref:System.Net.Sockets.SocketException>必要があります。これを行わないと、がスローされます。 接続指向プロトコルを使用している場合は、を使用<xref:System.Net.Sockets.Socket.Connect%2A>してリモートホスト接続を確立するか、を使用<xref:System.Net.Sockets.Socket.Accept%2A>して受信接続を許可する必要があります。  
  
 コネクションレスプロトコルを使用していて、複数の異なるホストにデータを送信することを<xref:System.Net.Sockets.Socket.SendTo%2A>計画している場合は、メソッドを使用する必要があります。 メソッドを使用<xref:System.Net.Sockets.Socket.SendTo%2A>しない場合は、メソッドを<xref:System.Net.Sockets.Socket.Send%2A>呼び出すたびに<xref:System.Net.Sockets.Socket.Connect%2A>メソッドを呼び出す必要があります。 <xref:System.Net.Sockets.Socket.SendTo%2A> を<xref:System.Net.Sockets.Socket.Connect%2A>使用して既定のリモートホストを確立した後でも、を使用できます。 を呼び出す前<xref:System.Net.Sockets.Socket.Send%2A>に、を<xref:System.Net.Sockets.Socket.Connect%2A>もう一度呼び出すことによって、既定のリモートホストを変更することもできます。  
  
 接続指向のプロトコルでは、 <xref:System.Net.Sockets.Socket.Send%2A>を使用<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>してタイムアウトが設定されていない限り、は要求されたバイト数が送信されるまでブロックします。 タイムアウト値を超えた場合、 <xref:System.Net.Sockets.Socket.Send%2A>を<xref:System.Net.Sockets.SocketException>呼び出すと、がスローされます。 非ブロッキングモードで<xref:System.Net.Sockets.Socket.Send%2A>は、が要求したバイト数よりも少ない場合でも、が正常に完了することがあります。 アプリケーションは、送信されたバイト数を追跡し、要求されたバイト数をアプリケーションが送信するまで操作を再試行する必要があります。 また、送信したデータがネットワークに直ちに表示される保証もありません。 ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。 <xref:System.Net.Sockets.Socket.Send%2A>メソッドが正常に終了するということは、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。  
  
> [!NOTE]
>  サイズが、基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要があります。 この場合、データグラムは送信<xref:System.Net.Sockets.Socket.Send%2A>されず、が<xref:System.Net.Sockets.SocketException>スローされます。 を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されたことは示されません。 転送されるデータを保持するためにトランスポートシステム内で使用できるバッファー領域がない場合、ソケットが非ブロッキングモードに設定されていない限り、send はブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、buffer で見つかったデータを<xref:System.Net.Sockets.SocketFlags.None>送信<xref:System.Net.Sockets.SocketFlags>し、にを指定しています。  
  
 [!code-cpp[Socket_Sync_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Sync_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Sync_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size" /> が 0 未満か、バッファーのサイズを超える値です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> は、値の有効な組み合わせではありません。  
  
- または - 
ソケットへのアクセス中にオペレーティング システム エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">送信するデータを格納する <see cref="T:System.Byte" /> 型の <see cref="T:System.ArraySegment`1" /> のリスト。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="errorCode">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、リスト内のバッファーのセットを接続された <see cref="T:System.Net.Sockets.Socket" /> に送信します。</summary>
        <returns><see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードには、送信するデータを含むバッファーが少なくとも1つ必要です。 既定<xref:System.Net.Sockets.SocketFlags>値は0です。 パラメーターとして<xref:System.Net.Sockets.SocketFlags.DontRoute>フラグを指定した場合、送信するデータはルーティングされません。 `socketFlags`  
  
 コネクションレスプロトコルを使用している場合は<xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Send%2A> 、このメソッドを呼び出す前にを呼び出す<xref:System.Net.Sockets.SocketException>必要があります。これを行わないと、がスローされます。 接続指向プロトコルを使用している場合は、を使用<xref:System.Net.Sockets.Socket.Connect%2A>してリモートホスト接続を確立するか、を使用<xref:System.Net.Sockets.Socket.Accept%2A>して受信接続を許可する必要があります。  
  
 コネクションレスプロトコルを使用していて、複数の異なるホストにデータを送信することを<xref:System.Net.Sockets.Socket.SendTo%2A>計画している場合は、メソッドを使用する必要があります。 <xref:System.Net.Sockets.Socket.SendTo%2A>メソッドを使用しない場合は、の各呼び出し<xref:System.Net.Sockets.Socket.Send%2A>の前<xref:System.Net.Sockets.Socket.Connect%2A>にを呼び出す必要があります。 <xref:System.Net.Sockets.Socket.SendTo%2A> を<xref:System.Net.Sockets.Socket.Connect%2A>使用して既定のリモートホストを確立した後でも、を使用できます。 を呼び出す前<xref:System.Net.Sockets.Socket.Send%2A>に、を<xref:System.Net.Sockets.Socket.Connect%2A>もう一度呼び出すことによって、既定のリモートホストを変更することもできます。  
  
 接続指向プロトコルを使用している場合、 <xref:System.Net.Sockets.Socket.Send%2A>は、を使用<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>してタイムアウトが設定されていない限り、バッファー内のすべてのバイトが送信されるまでブロックされます。 タイムアウト値を超えた場合、 <xref:System.Net.Sockets.Socket.Send%2A>を<xref:System.Net.Sockets.SocketException>呼び出すと、がスローされます。 非ブロッキングモードでは、 <xref:System.Net.Sockets.Socket.Send%2A>がバッファー内のバイト数よりも少ない場合でも、が正常に完了することがあります。 アプリケーションは、送信されたバイト数を追跡し、アプリケーションがバッファー内のバイトを送信するまで操作を再試行する必要があります。 また、送信したデータがネットワークに直ちに表示される保証もありません。 ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。 <xref:System.Net.Sockets.Socket.Send%2A>メソッドが正常に終了するということは、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されたことは示されません。 転送されるデータを保持するためにトランスポートシステム内で使用できるバッファー領域がない場合、ソケットが非ブロッキングモードに設定されていない限り、send はブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> が空です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">データの送信を開始する、データ バッファー内の位置。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>指定したオフセットから開始し、指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、指定したバイト数のデータを接続された <see cref="T:System.Net.Sockets.Socket" /> に送信します。</summary>
        <returns><see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A><xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドで指定されたリモートホストにデータを同期的に送信し、正常に送信されたバイト数を返します。 <xref:System.Net.Sockets.Socket.Send%2A>は、接続指向プロトコルとコネクションレスプロトコルの両方に使用できます。  
  
 このオーバーロードでは、 <xref:System.Net.Sockets.SocketFlags.DontRoute> `socketflags`パラメーターとしてフラグを指定すると、送信するデータはルーティングされません。  
  
 コネクションレスプロトコルを使用している場合は<xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Send%2A> 、このメソッドを呼び出す前にを呼び<xref:System.Net.Sockets.SocketException>出す必要があります。指定しないと、がスローされます。 接続指向プロトコルを使用している場合は、を使用<xref:System.Net.Sockets.Socket.Connect%2A>してリモートホスト接続を確立するか、を使用<xref:System.Net.Sockets.Socket.Accept%2A>して受信接続を許可する必要があります。  
  
 コネクションレスプロトコルを使用していて、複数の異なるホストにデータを送信すること<xref:System.Net.Sockets.Socket.SendTo%2A>を計画している場合は、を使用する必要があります。 を使用<xref:System.Net.Sockets.Socket.SendTo%2A>しない場合は、の各呼び出し<xref:System.Net.Sockets.Socket.Send%2A>の<xref:System.Net.Sockets.Socket.Connect%2A>前にを呼び出す必要があります。 <xref:System.Net.Sockets.Socket.SendTo%2A> で<xref:System.Net.Sockets.Socket.Connect%2A>既定のリモートホストを確立した後でも、を使用できます。 を呼び出す前<xref:System.Net.Sockets.Socket.Send%2A>に、を<xref:System.Net.Sockets.Socket.Connect%2A>もう一度呼び出すことによって、既定のリモートホストを変更することもできます。  
  
 また、サイズが基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要もあります。 この場合、データグラムは送信<xref:System.Net.Sockets.Socket.Send%2A>されず、が<xref:System.Net.Sockets.SocketException>スローされます。  
  
 接続指向プロトコルを使用している場合、 <xref:System.Net.Sockets.Socket.Send%2A>は、を使用<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>してタイムアウトが設定されていない限り、要求されたバイト数が送信されるまでブロックします。 タイムアウト値を超えた場合、 <xref:System.Net.Sockets.Socket.Send%2A>を<xref:System.Net.Sockets.SocketException>呼び出すと、がスローされます。 非ブロッキングモードで<xref:System.Net.Sockets.Socket.Send%2A>は、が要求したバイト数よりも少ない場合でも、が正常に完了することがあります。 アプリケーションは、送信されたバイト数を追跡し、要求されたバイト数をアプリケーションが送信するまで操作を再試行する必要があります。 また、送信したデータがネットワークに直ちに表示される保証もありません。 ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。 <xref:System.Net.Sockets.Socket.Send%2A>メソッドが正常に終了するということは、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されたことは示されません。 転送されるデータを保持するためにトランスポートシステム内で使用できるバッファー領域がない場合、ソケットが非ブロッキングモードに設定されていない限り、send はブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、接続さ<xref:System.Net.Sockets.SocketFlags> <xref:System.Net.Sockets.Socket>れたにデータを送信するために、データバッファー、オフセット、サイズ、およびを指定します。  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> が 0 未満です。  
  
- または - 
 <paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  
  
- または - 
 <paramref name="size" /> が 0 未満です。  
  
- または - 
 <paramref name="size" /> が、<paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> は、値の有効な組み合わせではありません。  
  
または 
<see cref="T:System.Net.Sockets.Socket" /> にアクセス中にオペレーティング システム エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">データの送信を開始する、データ バッファー内の位置。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="errorCode">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</param>
        <summary>指定したオフセットから開始し、指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、指定したバイト数のデータを接続された <see cref="T:System.Net.Sockets.Socket" /> に送信します。</summary>
        <returns><see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A><xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドで指定されたリモートホストにデータを同期的に送信し、正常に送信されたバイト数を返します。 <xref:System.Net.Sockets.Socket.Send%2A>は、接続指向プロトコルとコネクションレスプロトコルの両方に使用できます。  
  
 このオーバーロードでは、 <xref:System.Net.Sockets.SocketFlags.DontRoute> `socketflags`パラメーターとしてフラグを指定すると、送信するデータはルーティングされません。  
  
 コネクションレスプロトコルを使用している場合は<xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Send%2A> 、このメソッドを呼び出す前にを呼び<xref:System.Net.Sockets.SocketException>出す必要があります。指定しないと、がスローされます。 接続指向プロトコルを使用している場合は、を使用<xref:System.Net.Sockets.Socket.Connect%2A>してリモートホスト接続を確立するか、を使用<xref:System.Net.Sockets.Socket.Accept%2A>して受信接続を許可する必要があります。  
  
 コネクションレスプロトコルを使用していて、複数の異なるホストにデータを送信すること<xref:System.Net.Sockets.Socket.SendTo%2A>を計画している場合は、を使用する必要があります。 を使用<xref:System.Net.Sockets.Socket.SendTo%2A>しない場合は、の各呼び出し<xref:System.Net.Sockets.Socket.Send%2A>の<xref:System.Net.Sockets.Socket.Connect%2A>前にを呼び出す必要があります。 <xref:System.Net.Sockets.Socket.SendTo%2A> で<xref:System.Net.Sockets.Socket.Connect%2A>既定のリモートホストを確立した後でも、を使用できます。 を呼び出す前<xref:System.Net.Sockets.Socket.Send%2A>に、を<xref:System.Net.Sockets.Socket.Connect%2A>もう一度呼び出すことによって、既定のリモートホストを変更することもできます。  
  
 また、サイズが基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要もあります。 この場合、データグラムは送信<xref:System.Net.Sockets.Socket.Send%2A>されず、が<xref:System.Net.Sockets.SocketException>スローされます。  
  
 接続指向プロトコルを使用している場合、 <xref:System.Net.Sockets.Socket.Send%2A>は、を使用<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>してタイムアウトが設定されていない限り、要求されたバイト数が送信されるまでブロックします。 タイムアウト値を超えた場合、 <xref:System.Net.Sockets.Socket.Send%2A>を<xref:System.Net.Sockets.SocketException>呼び出すと、がスローされます。 非ブロッキングモードで<xref:System.Net.Sockets.Socket.Send%2A>は、が要求したバイト数よりも少ない場合でも、が正常に完了することがあります。 アプリケーションは、送信されたバイト数を追跡し、要求されたバイト数をアプリケーションが送信するまで操作を再試行する必要があります。 また、送信したデータがネットワークに直ちに表示される保証もありません。 ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。 <xref:System.Net.Sockets.Socket.Send%2A>メソッドが正常に終了するということは、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されたことは示されません。 転送されるデータを保持するためにトランスポートシステム内で使用できるバッファー領域がない場合、ソケットが非ブロッキングモードに設定されていない限り、send はブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、接続さ<xref:System.Net.Sockets.SocketFlags> <xref:System.Net.Sockets.Socket>れたにデータを送信するために、データバッファー、オフセット、サイズ、およびを指定します。  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> が 0 未満です。  
  
- または - 
 <paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  
  
または 
 <paramref name="size" /> が 0 未満です。  
  
- または - 
 <paramref name="size" /> が、<paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> は、値の有効な組み合わせではありません。  
  
- または - 
<see cref="T:System.Net.Sockets.Socket" /> にアクセス中にオペレーティング システム エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public bool SendAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</param>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> オブジェクトに、データを非同期に送信します。</summary>
        <returns>I/O 操作が保留中の場合は <see langword="true" />。 操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。  
  
 I/O 操作が同期的に完了した場合は <see langword="false" />。 この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Net.Sockets.Socket.SendAsync%2A>は、接続指向のソケット上の1つ以上のバッファーから送信データを書き込むために使用されます。 ただし、このメソッドは、接続操作でリモートホストを指定したコネクションレスソケットでも使用できます。  
  
 メソッド<xref:System.Net.Sockets.Socket.SendAsync%2A>は<xref:System.Net.Sockets.Socket.Accept%2A>、、、 <xref:System.Net.Sockets.Socket.BeginAccept%2A>、 <xref:System.Net.Sockets.Socket.AcceptAsync%2A> 、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、のいずれか<xref:System.Net.Sockets.Socket.ConnectAsync%2A>のメソッドで確立されたリモートホストに対して、非同期の送信操作を開始します。 <xref:System.Net.Sockets.Socket.Connect%2A>  
  
 このメソッドを正常に呼び出すに<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>は、オブジェクトの次のプロパティとイベントが必要です。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> または <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>が<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>設定されている場合  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>が<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>設定されている場合  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼び出し元は、 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> <xref:System.Net.Sockets.Socket.SendAsync%2A>メソッドを呼び出す前に、プロパティを任意のユーザー状態オブジェクトに設定できます。これにより、コールバックメソッドで情報を取得できるようになります。 コールバックが1つのオブジェクトよりも多くの情報を必要とする場合は、他の必要な状態情報をメンバーとして保持するために、小さなクラスを作成できます。  
  
 最初<xref:System.Net.Sockets.Socket.SendAsync%2A>に、 <xref:System.Net.Sockets.Socket.Accept%2A> 、<xref:System.Net.Sockets.Socket.AcceptAsync%2A>、、またはを呼び出さない場合、メソッドは例外をスローします。<xref:System.Net.Sockets.Socket.ConnectAsync%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.Connect%2A>  
  
 メソッドを<xref:System.Net.Sockets.Socket.SendAsync%2A>呼び出すと、別の実行スレッド内でデータを送信できるようになります。  
  
 メッセージ指向のソケットの場合、基になる Windows sockets service プロバイダーの最大メッセージサイズを超えないようにしてください。 データが長すぎて、基になるサービスプロバイダーでアトミックに渡すことができない場合、 <xref:System.Net.Sockets.Socket.SendAsync%2A>データは送信<xref:System.Net.Sockets.SocketException>され<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>ず、メソッドはをネイティブ Winsock WSAEMSGSIZE エラーコード (10040) に設定してをスローします。  
  
 <xref:System.Net.Sockets.Socket.SendAsync%2A>メソッドが正常に完了したことは、データが正常に配信されたことを示していないことに注意してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="e" /> パラメーターの <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> プロパティまたは <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> プロパティは、有効なバッファーを参照する必要があります。 これらのプロパティは、どちらか 1 つを設定できます。一度に両方のプロパティを設定することはできません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="e" /> パラメーターに指定された <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクトを使用してソケット操作が既に進行していました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows XP 以降が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><see cref="T:System.Net.Sockets.Socket" /> がまだ接続されていないか、<see cref="M:System.Net.Sockets.Socket.Accept" />、<see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />、または <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" /> の各メソッドによって取得されませんでした。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendBufferSize">
      <MemberSignature Language="C#" Value="public int SendBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property SendBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.SendBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> の送信バッファーのサイズを指定する値を取得または設定します。</summary>
        <value>送信バッファーのサイズ (バイト単位) を格納している <see cref="T:System.Int32" />。 既定値は 8192 です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 バッファーサイズを大きくすると、接続の問題の認識が遅れる可能性があります。 大きなファイルを転送する場合や、高帯域幅の高待機時間接続 (サテライトブロードバンドプロバイダーなど) を使用している場合は、バッファーサイズを大きくすることを検討してください。  
  
   
  
## Examples  
 次のコード例は、 <xref:System.Net.Sockets.Socket.SendBufferSize%2A>プロパティの使用方法を示しています。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">設定操作として指定された値が 0 未満です。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>接続された <see cref="T:System.Net.Sockets.Socket" /> に、ファイルおよびオプション データを同期的に送信します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string -&gt; unit" Usage="socket.SendFile fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">送信されるファイルのパスと名前を含む <see cref="T:System.String" />。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <summary><see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> 送信フラグを使用して、接続されている <see cref="T:System.Net.Sockets.Socket" /> オブジェクトにファイル <paramref name="fileName" /> を送信します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードは、接続`fileName`されているソケットにファイルを送信します。 パラメーター `flags`の`preBuffer` `postBuffer` `null`既定値は(0)で、パラメーターとパラメーターの既定値はです。<xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread> が`fileName`ローカルディレクトリにある場合は、ファイル名だけで識別されます。それ以外の場合は、ファイルの完全なパスと名前を指定する必要があります。 ワイルドカード ("..\\\\\\\\\myfile.txt ") と UNC 共有名 (" \ shared directory \myfile.txt ") がサポートされています。 \\ ファイルが見つからない場合は、例外<xref:System.IO.FileNotFoundException>がスローされます。  
  
 このメソッドは、 `TransmitFile` Windows Sockets 2 API で検出された関数を使用します。 関数とそのフラグの`TransmitFile`詳細については、 [Windows ソケット](/windows/desktop/WinSock/)のドキュメントを参照してください。  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A><xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドで指定したリモートホストにファイルを同期的に送信します。 <xref:System.Net.Sockets.Socket.SendFile%2A>接続指向プロトコルとコネクションレスプロトコルの両方に使用できます。  
  
 コネクションレスプロトコルを使用している場合は、 <xref:System.Net.Sockets.Socket.Connect%2A>このメソッドを呼び出す前に<xref:System.Net.Sockets.Socket.SendFile%2A>を呼び<xref:System.Net.Sockets.SocketException>出す必要があります。それ以外の場合は、例外がスローされます。 接続指向プロトコルを使用している場合は、を使用<xref:System.Net.Sockets.Socket.Connect%2A>してリモートホスト接続を確立するか、を使用<xref:System.Net.Sockets.Socket.Accept%2A>して受信接続を受け入れる必要があります。  
  
 接続指向プロトコルを使用している場合、 <xref:System.Net.Sockets.Socket.SendFile%2A>はファイルが送信されるまでブロックします。 非ブロッキングモードで<xref:System.Net.Sockets.Socket.SendFile%2A>は、ファイル全体が送信される前にが正常に完了することがあります。 送信したデータがネットワークに直ちに表示される保証はありません。 ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。 <xref:System.Net.Sockets.Socket.SendFile%2A>メソッドが正常に終了するということは、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、ソケットを作成して接続し、リモートホストにファイルを送信します。 ファイル "test.txt" は、ローカルコンピューターのルートディレクトリにあります。  
  
 [!code-cpp[NCLSocketEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#3)]
 [!code-csharp[NCLSocketEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">ソケットがリモート ホストに接続されていません。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトはブロック モードではなく、この同期呼び出しを受け付けることができません。</exception>
        <exception cref="T:System.IO.FileNotFoundException">ファイル <paramref name="fileName" /> が見つかりませんでした。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions -&gt; unit" Usage="socket.SendFile (fileName, preBuffer, postBuffer, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="preBuffer" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="postBuffer" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">送信されるファイルのパスと名前を含む <see cref="T:System.String" />。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="preBuffer">ファイルが送信される前に送信されるデータを格納する <see cref="T:System.Byte" /> 配列。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="postBuffer">ファイルが送信された後で送信されるデータを格納する <see cref="T:System.Byte" /> 配列。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="flags">1 つ以上の <see cref="T:System.Net.Sockets.TransmitFileOptions" /> 値。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.TransmitFileOptions" /> 値を使用して、接続された <see cref="T:System.Net.Sockets.Socket" /> オブジェクトにファイル <paramref name="fileName" /> およびデータのバッファーを送信します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードには、送信するファイルの名前と値の<xref:System.Net.Sockets.TransmitFileOptions>ビットごとの組み合わせが必要です。 パラメーター `preBuffer`には、ファイルの前に配置するデータが含まれています。 `postBuffer`ファイルに従う必要があるデータが含まれています。 が`fileName`現在の作業ディレクトリ内にある場合は、ファイル名だけで識別されます。それ以外の場合は、ファイルの完全なパスと名前を指定する必要があります。 ワイルドカード ("..\\\\\\\\\myfile.txt ") と UNC 共有名 (" \ shared directory \myfile.txt ") がサポートされています。 \\  
  
 パラメーター `flags`は、ファイル転送に関する追加情報を Window Sockets service プロバイダーに提供します。 このパラメーターの使用方法の詳細については<xref:System.Net.Sockets.TransmitFileOptions>、「」を参照してください。  
  
 このメソッドは、 `TransmitFile` Windows Sockets 2 API で検出された関数を使用します。 関数とそのフラグの`TransmitFile`詳細については、 [Windows ソケット](/windows/desktop/WinSock/)のドキュメントを参照してください。  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A><xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドで指定したリモートホストにファイルを同期的に送信します。 <xref:System.Net.Sockets.Socket.SendFile%2A>接続指向プロトコルとコネクションレスプロトコルの両方に使用できます。  
  
 コネクションレスプロトコルを使用している場合は、 <xref:System.Net.Sockets.Socket.Connect%2A>このメソッドを呼び出す前に<xref:System.Net.Sockets.Socket.SendFile%2A>を呼び<xref:System.Net.Sockets.SocketException>出す必要があります。それ以外の場合は、がスローされます。 接続指向プロトコルを使用している場合は、を使用<xref:System.Net.Sockets.Socket.Connect%2A>してリモートホスト接続を確立するか、を使用<xref:System.Net.Sockets.Socket.Accept%2A>して受信接続を許可する必要があります。  
  
 接続指向プロトコルを使用している場合は<xref:System.Net.Sockets.Socket.SendFile%2A> 、ファイル全体が送信されるまでブロックされます。 非ブロッキングモードで<xref:System.Net.Sockets.Socket.SendFile%2A>は、ファイル全体が送信される前にが正常に完了することがあります。 送信したデータがネットワークに直ちに表示される保証はありません。 ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。 <xref:System.Net.Sockets.Socket.SendFile%2A>メソッドが正常に終了するということは、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、ソケットを作成して接続します。 ファイル "test.txt" は、ローカルコンピューターのルートディレクトリにあります。 この例では、データの prebuffer と postbuffer を作成し、ファイルを使用してリモートホストに送信します。 既定値<xref:System.Net.Sockets.TransmitFileOptions>が使用されます。  
  
 [!code-cpp[NCLSocketEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#4)]
 [!code-csharp[NCLSocketEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">オペレーティング システムは Windows NT 以降ではありません。  
  
または
  
 ソケットがリモート ホストに接続されていません。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトはブロック モードではなく、この同期呼び出しを受け付けることができません。</exception>
        <exception cref="T:System.IO.FileNotFoundException">ファイル <paramref name="fileName" /> が見つかりませんでした。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="SendPacketsAsync">
      <MemberSignature Language="C#" Value="public bool SendPacketsAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendPacketsAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendPacketsAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendPacketsAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendPacketsAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendPacketsAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="e">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</param>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> オブジェクトに、ファイルのコレクションまたはメモリ内のデータ バッファーを非同期に送信します。</summary>
        <returns>I/O 操作が保留中の場合は <see langword="true" />。 操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。  
  
 I/O 操作が同期的に完了した場合は <see langword="false" />。 この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>は、ファイルのコレクションまたはメモリ内のデータバッファーをリモートホストに送信するために使用されます。 は<xref:System.Net.Sockets.Socket> 、リモートホストに既に接続されている必要があります。  
  
 が<xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType>作業ディレクトリ内のファイルを参照している場合は、ファイル名だけで識別できます。それ以外の場合は、ファイルの完全なパスと名前を指定する必要があります。 ワイルドカードと UNC 共有名がサポートされています。 ファイルが見つからない場合は、 <xref:System.IO.FileNotFoundException>がスローされます。  
  
 完了が通知されるようにするには、EventHandler\<SocketAsyncEventArgs > delegate を実装するコールバックメソッドを作成し、そのコールバックを<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>イベントにアタッチする必要があります。  
  
 `e`パラメーター <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType>のプロパティは、ファイル転送に関する追加情報を Window Sockets service プロバイダーに提供します。 このパラメーターの使用方法の詳細については<xref:System.Net.Sockets.TransmitFileOptions>、「」を参照してください。  
  
 このメソッドを正常に呼び出すに<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>は、オブジェクトの次のプロパティとイベントが必要です。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼び出し元は、 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>メソッドを呼び出す前に、プロパティを任意のユーザー状態オブジェクトに設定できます。これにより、コールバックメソッドで情報を取得できるようになります。 コールバックが1つのオブジェクトよりも多くの情報を必要とする場合は、他の必要な状態情報をメンバーとして保持するために、小さなクラスを作成できます。  
  
 このメソッドは、Windows Sockets 2 API の送信パケット関数を使用します。 送信パケット関数とそのフラグの詳細については、 [Windows ソケット](/windows/desktop/WinSock/)のドキュメントを参照してください。  
  
 接続指向プロトコルを想定しています<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>が、メソッドは<xref:System.Net.Sockets.Socket.BeginConnect%2A>、最初に、 <xref:System.Net.Sockets.Socket.Connect%2A>、または<xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッドを呼び出して既定のリモートホストを確立した場合に、コネクションレスプロトコルに対しても機能します。 コネクションレスプロトコルを使用する場合は、ファイルのサイズが基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要もあります。 この場合、データグラムは送信<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>されず、 <xref:System.Net.Sockets.SocketException>例外がスローされます。  
  
 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>メソッドは、使用されているオペレーティングシステムに従って最適化されます。 Windows server のエディションでは<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> 、この方法は高パフォーマンスのために最適化されています。  
  
 Windows クライアントのエディションでは<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> 、メモリとリソースの使用率が最小になるようにメソッドが最適化されています。  
  
 パラメーターの<xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType>プロパティでフラグを使用すると、パフォーマンスを大幅に向上させることができます。<xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType> `e` <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>メソッド呼び出しを開始するスレッドが大量の計算に使用されている場合、その apc が起動できなくなる可能性があります。 カーネルとユーザーモードの Apc には違いがあることに注意してください。 スレッドが待機状態になると、カーネル Apc が起動します。 スレッドが警告可能な待機状態になったときにユーザーモードの Apc が起動する  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException"><see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" /> プロパティで指定されたファイルが見つかりませんでした。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="e" /> パラメーターに指定された <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクトを使用してソケット操作が既に進行していました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows XP 以降が必要です。 この例外は、<see cref="T:System.Net.Sockets.Socket" /> がリモート ホストに接続されていない場合にも発生します。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">コネクションレスの <see cref="T:System.Net.Sockets.Socket" /> が使用されており、送信するファイルが基になるトランスポートの最大パケット サイズを超えています。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendTimeout">
      <MemberSignature Language="C#" Value="public int SendTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property SendTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendTimeout : int with get, set" Usage="System.Net.Sockets.Socket.SendTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>同期の <see cref="Overload:System.Net.Sockets.Socket.Send" /> 呼び出しがタイムアウトするまでの合計時間を指定する値を取得または設定します。</summary>
        <value>タイムアウト値 (ミリ秒)。 プロパティに 1 から 499 までの値を設定しても、その値は 500 に変更されます。 既定値は 0 です。タイムアウトが無期限であることを示します。 -1 の指定も、タイムアウトが無期限であることを示します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオプションは、同期<xref:System.Net.Sockets.Socket.Send%2A>呼び出しにのみ適用されます。 タイムアウト期間を超過<xref:System.Net.Sockets.Socket.Send%2A>した場合、メソッドはを<xref:System.Net.Sockets.SocketException>スローします。  
  
   
  
## Examples  
 次のコード例は、 <xref:System.Net.Sockets.Socket.SendTimeout%2A>プロパティの使用方法を示しています。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">設定操作として指定された値が -1 未満です。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendTo">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>データを特定のエンドポイントに送信します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendTo (buffer As Byte(), remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="remoteEP">データの送信先を表す <see cref="T:System.Net.EndPoint" />。</param>
        <summary>指定したエンドポイントにデータを送信します。</summary>
        <returns>送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードでは、バッファーオフセットは既定で0に設定され、既定で送信されるバイト数`buffer`はパラメーターのサイズ<xref:System.Net.Sockets.SocketFlags>に設定され、既定値は0に設定されます。  
  
 コネクションレスプロトコルを使用している場合は、を呼び出す<xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.SendTo%2A>前に、メソッドを使用して既定のリモートホストを確立する必要はありません。 この操作は、 <xref:System.Net.Sockets.Socket.Send%2A>メソッドを呼び出す場合にのみ必要です。 を呼び出す<xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.SendTo%2A>前にメソッドを呼び出すと、 `remoteEP`その送信操作に対してのみ、指定した既定のリモートホストがパラメーターによってオーバーライドされます。 基になるサービスプロバイダーによって<xref:System.Net.Sockets.Socket.Bind%2A>最も適切なローカルネットワークアドレスとポート番号が割り当てられるため、メソッドを呼び出す必要もありません。 割り当てられたローカルネットワークアドレスとポート番号を識別する必要がある場合は<xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 、 <xref:System.Net.Sockets.Socket.SendTo%2A>メソッドが正常に完了した後でプロパティを使用できます。  
  
 コネクションレスプロトコルを対象と<xref:System.Net.Sockets.Socket.SendTo%2A>していますが、接続指向プロトコルでも機能します。 接続指向プロトコルを使用している場合は、最初に<xref:System.Net.Sockets.Socket.Connect%2A>メソッドを呼び出すか、 <xref:System.Net.Sockets.Socket.Accept%2A>メソッドを使用して受信接続要求を受け入れることによって、リモートホスト接続を確立する必要があります。 リモートホスト接続を確立していない場合、 <xref:System.Net.Sockets.Socket.SendTo%2A>または受け入れない場合は、によってが<xref:System.Net.Sockets.SocketException>スローされます。 また、 <xref:System.Net.Sockets.Socket.SendTo%2A>メソッドを呼び出す前に、コネクションレスプロトコルの既定のリモートホストを確立することもできます。 どちらの場合も、 <xref:System.Net.Sockets.Socket.SendTo%2A>は`remoteEP`パラメーターを無視し、接続されたまたは既定のリモートホストにのみデータを送信します。  
  
 ブロックソケットは、バッファー内のすべてのバイトが送信されるまでブロックされます。 非ブロッキング<xref:System.Net.Sockets.Socket>はすぐには完了しないため、 `buffer`内のすべてのバイトが送信されるとは限りません。 送信されるバイト数を追跡し、アプリケーションが内`buffer`のすべてのバイトを送信するまで操作を再試行するのは、アプリケーションの役割です。 また、送信したデータがネットワークに直ちに表示される保証もありません。 ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。 <xref:System.Net.Sockets.Socket.SendTo%2A>メソッドが正常に終了するということは、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。  
  
 ブロックモードでコネクションレスプロトコルを使用している<xref:System.Net.Sockets.Socket.SendTo%2A>場合、はデータグラムが送信されるまでブロックします。 ブロードキャストアドレスにデータを送信する場合は、最初に<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドを呼び出し、ソケットオプションをに<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>設定する必要があります。 また、送信されたバイト数が、基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要があります。 この場合、データグラムは送信<xref:System.Net.Sockets.Socket.SendTo%2A>されず、が<xref:System.Net.Sockets.SocketException>スローされます。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、指定したリモートホストにコネクションレスのデータグラムを送信します。  
  
 [!code-cpp[Socket_Sync_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Sync_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Sync_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="remoteEP" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP">データの送信先の位置を表す <see cref="T:System.Net.EndPoint" />。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、特定のエンドポイントにデータを送信します。</summary>
        <returns>送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードでは、バッファーオフセットは既定で0に設定され、送信するバイト数は既定での`buffer`サイズに設定されます。 パラメーターとして<xref:System.Net.Sockets.SocketFlags.DontRoute>フラグを指定した場合、送信するデータはルーティングされません。 `socketflags`  
  
 コネクションレスプロトコルを使用している場合は、を呼び出す<xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.SendTo%2A>前に、メソッドを使用して既定のリモートホストを確立する必要はありません。 この操作は、 <xref:System.Net.Sockets.Socket.Send%2A>メソッドを呼び出す場合にのみ必要です。 を呼び出す<xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.SendTo%2A>前にメソッドを呼び出すと、 `remoteEP`その送信操作に対してのみ、指定した既定のリモートホストがパラメーターによってオーバーライドされます。 基になるサービスプロバイダーによって<xref:System.Net.Sockets.Socket.Bind%2A>最も適切なローカルネットワークアドレスとポート番号が割り当てられるため、メソッドを呼び出す必要もありません。 割り当てられたローカルネットワークアドレスとポート番号を識別する必要がある場合は<xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 、 <xref:System.Net.Sockets.Socket.SendTo%2A>メソッドが正常に完了した後でプロパティを使用できます。  
  
 コネクションレスプロトコルを対象と<xref:System.Net.Sockets.Socket.SendTo%2A>していますが、接続指向プロトコルでも機能します。 接続指向プロトコルを使用している場合は、最初に<xref:System.Net.Sockets.Socket.Connect%2A>メソッドを呼び出すか、 <xref:System.Net.Sockets.Socket.Accept%2A>メソッドを使用して受信接続要求を受け入れることによって、リモートホスト接続を確立する必要があります。 リモートホスト接続を確立していない場合、 <xref:System.Net.Sockets.Socket.SendTo%2A>または受け入れない場合は、によってが<xref:System.Net.Sockets.SocketException>スローされます。 また、 <xref:System.Net.Sockets.Socket.SendTo%2A>メソッドを呼び出す前に、コネクションレスプロトコルの既定のリモートホストを確立することもできます。 どちらの場合も、 <xref:System.Net.Sockets.Socket.SendTo%2A>は`remoteEP`パラメーターを無視し、接続されたまたは既定のリモートホストにのみデータを送信します。  
  
 ブロックされたソケットは、で`buffer`要求されたすべてのバイトが送信されるまでブロックされます。 非ブロッキング<xref:System.Net.Sockets.Socket>はすぐには完了しないため、 `buffer`内のすべてのバイトが送信されるとは限りません。 送信されるバイト数を追跡し、アプリケーションが内`buffer`のすべてのバイトを送信するまで操作を再試行するのは、アプリケーションの役割です。 また、送信したデータがネットワークに直ちに表示される保証もありません。 ネットワークの効率を高めるため、基になるシステムは、大量のデータが収集されるまで転送を遅らせます。 <xref:System.Net.Sockets.Socket.SendTo%2A>メソッドが正常に終了するということは、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。  
  
 ブロックモードでコネクションレスプロトコルを使用している<xref:System.Net.Sockets.Socket.SendTo%2A>場合、はデータグラムが送信されるまでブロックします。 ブロードキャストアドレスにデータを送信する場合は、最初に<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドを呼び出し、ソケットオプションをに<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>設定する必要があります。 また、送信されたバイト数が、基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要があります。 この場合、データグラムは送信<xref:System.Net.Sockets.Socket.SendTo%2A>されず、が<xref:System.Net.Sockets.SocketException>スローされます。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、指定したリモートホストにコネクションレスのデータグラムを送信します。 <xref:System.Net.Sockets.SocketFlags>は、 <xref:System.Net.Sockets.Socket.SendTo%2A>メソッドに渡されます。  
  
 [!code-cpp[Socket_Sync_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Sync_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Sync_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="remoteEP" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP">データの送信先の位置を表す <see cref="T:System.Net.EndPoint" />。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、指定したバイト数のデータを、指定したエンドポイントに送信します。</summary>
        <returns>送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードでは、バッファーオフセットは既定で0に設定されます。 パラメーターとして<xref:System.Net.Sockets.SocketFlags.DontRoute>フラグを指定した場合、送信するデータはルーティングされません。 `socketflags`  
  
 コネクションレスプロトコルを使用している場合は、を呼び出す<xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.SendTo%2A>前に、メソッドを使用して既定のリモートホストを確立する必要はありません。 この操作は、 <xref:System.Net.Sockets.Socket.Send%2A>メソッドを呼び出す場合にのみ必要です。 を呼び出す<xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.SendTo%2A>前にメソッドを呼び出すと、 `remoteEP`その送信操作に対してのみ、指定した既定のリモートホストがパラメーターによってオーバーライドされます。 基になるサービスプロバイダーによって<xref:System.Net.Sockets.Socket.Bind%2A>最も適切なローカルネットワークアドレスとポート番号が割り当てられるため、メソッドを呼び出す必要もありません。 割り当てられたローカルネットワークアドレスとポート番号を識別する必要がある場合は<xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 、 <xref:System.Net.Sockets.Socket.SendTo%2A>メソッドが正常に完了した後でプロパティを使用できます。  
  
 コネクションレスプロトコルを対象と<xref:System.Net.Sockets.Socket.SendTo%2A>していますが、接続指向プロトコルでも機能します。 接続指向プロトコルを使用している場合は、最初に<xref:System.Net.Sockets.Socket.Connect%2A>メソッドを呼び出すか、 <xref:System.Net.Sockets.Socket.Accept%2A>メソッドを使用して受信接続要求を受け入れることによって、リモートホスト接続を確立する必要があります。 リモートホスト接続を確立していない場合、 <xref:System.Net.Sockets.Socket.SendTo%2A>または受け入れない場合は、によってが<xref:System.Net.Sockets.SocketException>スローされます。 また、 <xref:System.Net.Sockets.Socket.SendTo%2A>メソッドを呼び出す前に、コネクションレスプロトコルの既定のリモートホストを確立することもできます。 どちらの場合も、 <xref:System.Net.Sockets.Socket.SendTo%2A>は`remoteEP`パラメーターを無視し、接続されたまたは既定のリモートホストにのみデータを送信します。  
  
 ブロックされたソケットは、要求されたバイト数が送信されるまでブロックされます。 非ブロッキング<xref:System.Net.Sockets.Socket>はすぐには完了しないため、1回の操作で要求されたバイト数がすべて送信されない可能性があります。 アプリケーションは、送信されたバイト数を追跡し、要求されたバイト数をアプリケーションが送信するまで操作を再試行する必要があります。 また、送信したデータがネットワークに直ちに表示される保証もありません。 ネットワークの効率を高めるため、基になるシステムは、大量のデータが収集されるまで転送を遅らせます。 <xref:System.Net.Sockets.Socket.SendTo%2A>メソッドが正常に終了するということは、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。  
  
 ブロックモードでコネクションレスプロトコルを使用している<xref:System.Net.Sockets.Socket.SendTo%2A>場合、はデータグラムが送信されるまでブロックします。 ブロードキャストアドレスにデータを送信する場合は、最初に<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドを呼び出し、ソケットオプションをに<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>設定する必要があります。 また、送信されたバイト数が、基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要があります。 この場合、データグラムは送信<xref:System.Net.Sockets.Socket.SendTo%2A>されず、が<xref:System.Net.Sockets.SocketException>スローされます。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、指定したリモートホストにコネクションレスのデータグラムを送信します。 サイズと<xref:System.Net.Sockets.SocketFlags>は、 <xref:System.Net.Sockets.Socket.SendTo%2A>メソッドに渡されます。  
  
 [!code-cpp[Socket_Sync_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Sync_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Sync_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> が <see langword="null" /> です。  
  
- または - 
 <paramref name="remoteEP" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">指定した <paramref name="size" /> が <paramref name="buffer" /> のサイズを超えています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">データの送信を開始する、データ バッファー内の位置。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP">データの送信先の位置を表す <see cref="T:System.Net.EndPoint" />。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、指定したバイト数のデータを、指定したエンドポイントに送信します。送信はバッファー内の指定した位置から開始されます。</summary>
        <returns>送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードでは、 <xref:System.Net.Sockets.SocketFlags.DontRoute> `socketflags`パラメーターとしてフラグを指定すると、送信するデータはルーティングされません。  
  
 コネクションレスプロトコルを使用している場合は、を呼び出す<xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.SendTo%2A>前に、メソッドを使用して既定のリモートホストを確立する必要はありません。 この操作は、 <xref:System.Net.Sockets.Socket.Send%2A>メソッドを呼び出す場合にのみ必要です。 を呼び出す<xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.SendTo%2A>前にメソッドを呼び出すと、 `remoteEP`その送信操作に対してのみ、指定した既定のリモートホストがパラメーターによってオーバーライドされます。 基になるサービスプロバイダーによって<xref:System.Net.Sockets.Socket.Bind%2A>最も適切なローカルネットワークアドレスとポート番号が割り当てられるため、メソッドを呼び出す必要もありません。 割り当てられたローカルネットワークアドレスとポート番号を識別する必要がある場合は<xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 、 <xref:System.Net.Sockets.Socket.SendTo%2A>メソッドが正常に完了した後でプロパティを使用できます。  
  
 コネクションレスプロトコルを対象と<xref:System.Net.Sockets.Socket.SendTo%2A>していますが、接続指向プロトコルでも機能します。 接続指向プロトコルを使用している場合は、最初に<xref:System.Net.Sockets.Socket.Connect%2A>メソッドを呼び出すか、 <xref:System.Net.Sockets.Socket.Accept%2A>メソッドを使用して受信接続要求を受け入れることによって、リモートホスト接続を確立する必要があります。 リモートホスト接続を確立していない場合、 <xref:System.Net.Sockets.Socket.SendTo%2A>または受け入れない場合は、によってが<xref:System.Net.Sockets.SocketException>スローされます。 また、 <xref:System.Net.Sockets.Socket.SendTo%2A>メソッドを呼び出す前に、コネクションレスプロトコルの既定のリモートホストを確立することもできます。 どちらの場合も、 <xref:System.Net.Sockets.Socket.SendTo%2A>は`remoteEP`パラメーターを無視し、接続されたまたは既定のリモートホストにのみデータを送信します。  
  
 ブロックされたソケットは、要求されたバイト数が送信されるまでブロックされます。 非ブロッキング<xref:System.Net.Sockets.Socket>はすぐに完了するため、1回の操作で要求されたバイト数がすべて送信されるとは限りません。 アプリケーションは、送信されたバイト数を追跡し、要求されたバイト数をアプリケーションが送信するまで操作を再試行する必要があります。 また、送信したデータがネットワークに直ちに表示される保証もありません。 ネットワークの効率を高めるため、基になるシステムは、大量のデータが収集されるまで転送を遅らせます。 <xref:System.Net.Sockets.Socket.SendTo%2A>メソッドが正常に終了するということは、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。  
  
 ブロックモードでコネクションレスプロトコルを使用している<xref:System.Net.Sockets.Socket.SendTo%2A>場合、はデータグラムが送信されるまでブロックします。 ブロードキャストアドレスにデータを送信する場合は、最初に<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドを呼び出し、ソケットオプションをに<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>設定する必要があります。 また、サイズが基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要もあります。 この場合、データグラムは送信<xref:System.Net.Sockets.Socket.SendTo%2A>されず、が<xref:System.Net.Sockets.SocketException>スローされます。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、指定したリモートホストにコネクションレスのデータグラムを送信します。 オフセット、サイズ、および<xref:System.Net.Sockets.SocketFlags>が<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドに渡されます。  
  
 [!code-cpp[Socket_Sync_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Sync_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Sync_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> が <see langword="null" /> です。  
  
- または - 
 <paramref name="remoteEP" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> が 0 未満です。  
  
- または - 
 <paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  
  
または 
 <paramref name="size" /> が 0 未満です。  
  
または 
 <paramref name="size" /> が、<paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> は、値の有効な組み合わせではありません。  
  
- または - 
<see cref="T:System.Net.Sockets.Socket" /> にアクセス中にオペレーティング システム エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendToAsync">
      <MemberSignature Language="C#" Value="public bool SendToAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendToAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendToAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendToAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendToAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendToAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</param>
        <summary>特定のリモート ホストにデータを非同期的に送信します。</summary>
        <returns>I/O 操作が保留中の場合は <see langword="true" />。 操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。  
  
 I/O 操作が同期的に完了した場合は <see langword="false" />。 この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Net.Sockets.Socket.SendToAsync%2A>は、 `e`パラメーターの<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>プロパティで指定されたリモートホストに対して非同期の送信操作を開始します。 メソッドを<xref:System.Net.Sockets.Socket.SendToAsync%2A>呼び出すと、別の実行スレッド内でデータを送信できるようになります。 この方法は、コネクションレスプロトコルを対象<xref:System.Net.Sockets.Socket.SendToAsync%2A>としていますが、コネクションレスプロトコルと接続指向プロトコルの両方で動作します。  
  
 完了が通知されるようにするには、EventHandler\<SocketAsyncEventArgs > delegate を実装するコールバックメソッドを作成し、そのコールバックを<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>イベントにアタッチする必要があります。  
  
 このメソッドを正常に呼び出すに<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>は、オブジェクトの次のプロパティとイベントが必要です。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼び出し元は、 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> <xref:System.Net.Sockets.Socket.SendToAsync%2A>メソッドを呼び出す前に、プロパティを任意のユーザー状態オブジェクトに設定できます。これにより、コールバックメソッドで情報を取得できるようになります。 コールバックが1つのオブジェクトよりも多くの情報を必要とする場合は、他の必要な状態情報をメンバーとして保持するために、小さなクラスを作成できます。  
  
 接続指向プロトコルを使用している場合は<xref:System.Net.Sockets.Socket.Accept%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A>、まず、 <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.AcceptAsync%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A>、、、、または<xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッドを呼び出す必要があります。 それ<xref:System.Net.Sockets.Socket.SendToAsync%2A>以外の場合<xref:System.Net.Sockets.SocketException>は、がスローされます。 接続<xref:System.Net.Sockets.Socket.SendToAsync%2A>指向プロトコルを使用する場合、メソッドは<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>プロパティを無視<xref:System.Net.EndPoint?displayProperty=nameWithType>し、 <xref:System.Net.Sockets.Socket.Accept%2A>、 <xref:System.Net.Sockets.Socket.AcceptAsync%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A>、、、 <xref:System.Net.Sockets.Socket.Connect%2A>の各で確立されたにデータを送信します。、、 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>またはメソッド。  
  
 コネクションレスプロトコルを使用している<xref:System.Net.Sockets.Socket.BeginConnect%2A>場合は、を呼び出す<xref:System.Net.Sockets.Socket.SendToAsync%2A>前に、 <xref:System.Net.Sockets.Socket.Connect%2A>、、またはのいずれか<xref:System.Net.Sockets.Socket.ConnectAsync%2A>のメソッドを使用して、既定のリモートホストを確立する必要はありません。 この操作は、 <xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドまたは<xref:System.Net.Sockets.Socket.SendAsync%2A>メソッドを呼び出す場合にのみ必要です。 <xref:System.Net.Sockets.Socket.BeginConnect%2A>を呼び出す<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.ConnectAsync%2A>前に、、またはメソッドを呼び出した場合、プロパティは、その送信操作に対してのみ、指定された既定のリモートホストをオーバーライドします。 <xref:System.Net.Sockets.Socket.SendToAsync%2A> また、 <xref:System.Net.Sockets.Socket.Bind%2A>メソッドを呼び出す必要はありません。 この場合、基になるサービスプロバイダーによって、最も適切なローカルネットワーク IP アドレスとポート番号が割り当てられます。 基になるサービスプロバイダーで空きポートを選択する場合は、ポート番号を0にします。 割り当てられているローカルネットワークの IP アドレスとポート番号を識別する必要がある<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>場合は、 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>イベントが通知され、関連付けられているデリゲートが呼び出された後に、プロパティを使用できます。  
  
 ブロードキャストアドレスにデータを送信する場合は、最初に<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドを呼び出し、の<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> socket オプションを true に設定する必要があります。 また、バッファーのサイズが、基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要があります。 この場合、データグラムは送信<xref:System.Net.Sockets.Socket.SendToAsync%2A>されず、が<xref:System.Net.Sockets.SocketException>スローされます。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType>プロパティで DontRoute フラグを指定した場合、送信するデータはルーティングされません。  
  
 メッセージ指向のソケットの場合は、基になるトランスポートの最大メッセージサイズを超えないように注意する必要があります。 バッファーのサイズが基になるサービスプロバイダーの最大パケットサイズを超えると<xref:System.Net.Sockets.Socket.SendToAsync%2A> 、データグラムは送信されず、が<xref:System.Net.Sockets.SocketException>スローされます。 <xref:System.Net.Sockets.Socket.SendToAsync%2A>メソッドが正常に完了しても、データが正常に配信されたことは示されません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> に null 値を指定することはできません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="e" /> パラメーターに指定された <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクトを使用してソケット操作が既に進行していました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows XP 以降が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">指定されたプロトコルは接続指向ですが、<see cref="T:System.Net.Sockets.Socket" /> がまだ接続されていません。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SetIPProtectionLevel">
      <MemberSignature Language="C#" Value="public void SetIPProtectionLevel (System.Net.Sockets.IPProtectionLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetIPProtectionLevel(valuetype System.Net.Sockets.IPProtectionLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetIPProtectionLevel (level As IPProtectionLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetIPProtectionLevel(System::Net::Sockets::IPProtectionLevel level);" />
      <MemberSignature Language="F#" Value="member this.SetIPProtectionLevel : System.Net.Sockets.IPProtectionLevel -&gt; unit" Usage="socket.SetIPProtectionLevel level" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Net.Sockets.IPProtectionLevel" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="level">このソケットに設定する IP 保護レベル。</param>
        <summary>ソケットの IP 保護レベルを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A>メソッドを使用すると、同じリンクローカルまたはサイトローカルプレフィックスを持つアドレスなど、指定されたスコープでリッスンするように IPv6 または IP ソケットを制限できます。 このソケットオプションを使用すると、アプリケーションは IPv6 または IP ソケットにアクセス制限を設けることができます。 この制限により、プライベート LAN で実行されるアプリケーションを外部からの攻撃に対して簡単かつ堅牢に強化できます。 パラメーターがに<xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>設定されている場合は、このソケット`level`オプションを使用してアクセス制限を削除することもできます。 このソケット オプションで待機中のソケットのスコープを変更して、適切な場合はパブリック ユーザーおよびプライベート ユーザーからの無制限のアクセスを許可したり、必要に応じて同じサイトへのアクセスのみに制限したりできます。  
  
 このソケット オプションには、<xref:System.Net.Sockets.IPProtectionLevel> 列挙型で指定されている定義済みの保護レベルが設定されています。  
  
 メソッド<xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A>は、 <xref:System.Net.Sockets.Socket>インスタンスのネットワークアドレストラバーサル (NAT) を有効または無効にするために使用されます。 NAT トラバーサルは、Teredo、6to4、または ISATAP トンネルを使用して提供される場合があります。  
  
 パラメーターが`level` 、またはに<xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>設定さ<xref:System.Net.Sockets.IPProtectionLevel.Restricted>れている場合、 <xref:System.Net.Sockets.Socket>インスタンスの NAT トラバーサルは明示的に無効になります。  
  
 パラメーターをに<xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>設定すると、システムに配置されている<xref:System.Net.Sockets.Socket>ファイアウォールルールに応じて、に対して NAT トラバーサルが許可されることがあります。 `level`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="level" /> パラメーターとして <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" /> を使用することはできません。 IP 保護レベルを未指定に設定することはできません。</exception>
        <exception cref="T:System.NotSupportedException">ソケットの <see cref="T:System.Net.Sockets.AddressFamily" /> は、<see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> または <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> である必要があります。</exception>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> オプションを設定します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, bool optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * bool -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか 1 つ。</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか。</param>
        <param name="optionValue"><see cref="T:System.Boolean" /> として表されるオプションの値。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.Socket" /> オプションを、指定した <see cref="T:System.Boolean" /> 値に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>オプションは、現在<xref:System.Net.Sockets.Socket>のの動作を決定します。 オプションを有効にする場合はに設定`false`し、オプションを無効にする場合はに設定`optionValue`します。 `true`  
  
 <xref:System.Net.Sockets.Socket>オプションは、プロトコルサポートのレベルによってグループ化されます。  
  
 このオーバーロードを使用し<xref:System.Net.Sockets.Socket>て設定できるさまざまなオプションを以下に示します。 これらのオプションは、適切な<xref:System.Net.Sockets.SocketOptionLevel>値によってグループ化されます。 これらのオプションのいずれかを設定する場合は、 <xref:System.Net.Sockets.SocketOptionLevel> `optionLevel`パラメーターに適切な値を使用してください。 設定するオプションは、 `optionName`パラメーターに指定する必要があります。 一覧表示されているいずれかのオプションの現在の値を取得する<xref:System.Net.Sockets.Socket.GetSocketOption%2A>場合は、メソッドを使用します。  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType>このオーバーロードを使用して設定できるオプション。  
  
-   <xref:System.Net.Sockets.SocketOptionName.AcceptConnection>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType>このオーバーロードを使用して設定できるオプション。  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType>このオーバーロードを使用して設定できるオプション。  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType>このオーバーロードを使用して設定できるオプション。  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 これらのオプションの詳細については、 <xref:System.Net.Sockets.SocketOptionName>列挙体を参照してください。  
  
> [!NOTE]
>  例外が発生した場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 <xref:System.Net.Sockets.SocketException> このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
   
  
## Examples  
 次のコード例では、ソケットを開き`DontLinger` 、 `OutOfBandInline`およびソケットオプションを有効にします。  
  
 [!code-cpp[NCLSocketEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#5)]
 [!code-csharp[NCLSocketEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか。</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか 1 つ。</param>
        <param name="optionValue">オプションの値を表す <see cref="T:System.Byte" /> 型の配列。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.Socket" /> オプションを、指定した値に設定します。この値はバイト配列で表されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>オプションは、現在<xref:System.Net.Sockets.Socket>のの動作を決定します。 このオーバーロードを使用して<xref:System.Net.Sockets.Socket> 、バイト配列を必要とするオプションをオプション値として設定します。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では<xref:System.Net.Sockets.LingerOption> 、 <xref:System.Net.Sockets.Socket.Send%2A>とのタイムアウト値を設定します。  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか 1 つ。</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか 1 つ。</param>
        <param name="optionValue">オプションの値。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.Socket" /> オプションを、指定した整数値に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>オプションは、現在<xref:System.Net.Sockets.Socket>のの動作を決定します。 <xref:System.Boolean>データ型のオプションの場合は、0以外の値を指定してオプションを有効にし、ゼロの値を指定してオプションを無効にします。 整数データ型のオプションの場合は、適切な値を指定します。 <xref:System.Net.Sockets.Socket>オプションは、プロトコルサポートのレベルによってグループ化されます。  
  
 このオーバーロードを使用し<xref:System.Net.Sockets.Socket>て設定できるさまざまなオプションを以下に示します。 これらのオプションは、適切な<xref:System.Net.Sockets.SocketOptionLevel>でグループ化されます。 これらのオプションのいずれかを設定する場合は、 <xref:System.Net.Sockets.SocketOptionLevel> `optionLevel`パラメーターに適切なを使用してください。 設定するオプションは、 `optionName`パラメーターに指定する必要があります。 一覧表示されているいずれかのオプションの現在の値を取得する<xref:System.Net.Sockets.Socket.GetSocketOption%2A>場合は、メソッドを使用します。  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType>このオーバーロードを使用して設定できるオプション。  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Error>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Type>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType>このオーバーロードを使用して設定できるオプション。  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IPOptions>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IpTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastInterface>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.TypeOfService>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType>このオーバーロードを使用して設定できるオプション。  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType>このオーバーロードを使用して設定できるオプション。  
  
-   <xref:System.Net.Sockets.SocketOptionName.ChecksumCoverage>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType>このオーバーロードを使用して設定できるオプション。  
  
-   <xref:System.Net.Sockets.SocketOptionName.HopLimit>  
  
 これらのオプションの詳細については、 <xref:System.Net.Sockets.SocketOptionName>列挙体を参照してください。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では<xref:System.Net.Sockets.LingerOption> 、 <xref:System.Net.Sockets.Socket.Send%2A>とのタイムアウト値を設定します。  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, object optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, object optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, System::Object ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * obj -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Object" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか 1 つ。</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか。</param>
        <param name="optionValue">オプションの値を格納する <see cref="T:System.Net.Sockets.LingerOption" /> または <see cref="T:System.Net.Sockets.MulticastOption" />。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.Socket" /> オプションを、指定した値に設定します。この値はオブジェクトで表されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>オプションは、現在<xref:System.Net.Sockets.Socket>のの動作を決定します。 、 <xref:System.Net.Sockets.SocketOptionName.Linger> 、<xref:System.Net.Sockets.SocketOptionName.AddMembership>およびの各オプション<xref:System.Net.Sockets.Socket>を設定するには、このオーバーロードを使用します。 <xref:System.Net.Sockets.SocketOptionName.DropMembership> オプションには、 `optionLevel`パラメーター <xref:System.Net.Sockets.Socket>にを使用します。 <xref:System.Net.Sockets.SocketOptionName.Linger> とでは、 <xref:System.Net.Sockets.SocketOptionLevel.IP>を使用します。 <xref:System.Net.Sockets.SocketOptionName.DropMembership> <xref:System.Net.Sockets.SocketOptionName.AddMembership> 上記のいずれかのオプションの現在の値を取得する場合は、 <xref:System.Net.Sockets.Socket.GetSocketOption%2A>メソッドを使用します。  
  
> [!NOTE]
>  を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
   
  
## Examples  
 次のコード例では<xref:System.Net.Sockets.LingerOption> 、 <xref:System.Net.Sockets.Socket.Send%2A>とのタイムアウト値を設定します。  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="optionValue" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (System.Net.Sockets.SocketShutdown how);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(valuetype System.Net.Sockets.SocketShutdown how) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (how As SocketShutdown)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(System::Net::Sockets::SocketShutdown how);" />
      <MemberSignature Language="F#" Value="member this.Shutdown : System.Net.Sockets.SocketShutdown -&gt; unit" Usage="socket.Shutdown how" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="how" Type="System.Net.Sockets.SocketShutdown" />
      </Parameters>
      <Docs>
        <param name="how">許可されなくなる操作を指定する <see cref="T:System.Net.Sockets.SocketShutdown" /> 値の 1 つ。</param>
        <summary><see cref="T:System.Net.Sockets.Socket" /> での送受信を無効にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向<xref:System.Net.Sockets.Socket>のを使用する場合は、を<xref:System.Net.Sockets.Socket.Shutdown%2A>閉じる<xref:System.Net.Sockets.Socket>前に常にメソッドを呼び出します。 これにより、接続されたソケットが閉じられる前に、すべてのデータが送信され、受信されます。  
  
 メソッドを呼び出して、に関連付けられているすべて<xref:System.Net.Sockets.Socket>のマネージリソースとアンマネージリソースを解放します。 <xref:System.Net.Sockets.Socket.Close%2A> 終了<xref:System.Net.Sockets.Socket>後にを再利用しないようにしてください。  
  
 次の表は、 <xref:System.Net.Sockets.SocketShutdown> `how`パラメーターに対して有効な列挙値を示しています。  
  
|[値]|説明|  
|-----------|-----------------|  
|送信|この<xref:System.Net.Sockets.Socket>での送信を無効にします。|  
|Receive|この<xref:System.Net.Sockets.Socket>での受信を無効にします。|  
|両方|この<xref:System.Net.Sockets.Socket>で送信と受信の両方を無効にします。|  
  
 を`how`に<xref:System.Net.Sockets.SocketShutdown.Send>設定すると、後続<xref:System.Net.Sockets.Socket.Send%2A>のへの呼び出しは許可されません。 コネクションレス<xref:System.Net.Sockets.Socket>型を使用している<xref:System.Net.Sockets.SocketShutdown.Send>場合、を指定しても効果はありません。  
  
 を`how`に<xref:System.Net.Sockets.SocketShutdown.Receive>設定すると、後続<xref:System.Net.Sockets.Socket.Receive%2A>のへの呼び出しは許可されません。 これは、下位のプロトコルレイヤーには影響しません。 接続指向プロトコルを使用している場合は、の呼び出しの後に<xref:System.Net.Sockets.Socket.Shutdown%2A>次のいずれかの条件が満たされると、接続が終了します。  
  
-   受信を待機している受信ネットワークバッファーにデータがあります。  
  
-   さらに多くのデータが到着しました。  
  
 コネクションレスプロトコルを使用している場合は、データグラムが受け入れられ、キューに登録されます。 ただし、追加の受信データグラムに使用できるバッファー領域がない場合は、破棄され、送信側にエラーは返されません。 コネクション<xref:System.Net.Sockets.Socket.Shutdown%2A> レス<xref:System.Net.Sockets.Socket>でを使用することは推奨されません。  
  
 を`how`に<xref:System.Net.Sockets.SocketShutdown.Both>設定すると、前述のように、送信と受信の両方が無効になります。  
  
> [!NOTE]
>  メソッドの<xref:System.Net.Sockets.SocketException> <xref:System.Net.Sockets.Socket.Shutdown%2A>呼び出し時にを受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例で<xref:System.Net.Sockets.Socket.Shutdown%2A>は、を<xref:System.Net.Sockets.Socket>使用してを無効にします。  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketShutdown" />
      </Docs>
    </Member>
    <Member MemberName="SocketType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketType SocketType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketType SocketType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SocketType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SocketType As SocketType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SocketType SocketType { System::Net::Sockets::SocketType get(); };" />
      <MemberSignature Language="F#" Value="member this.SocketType : System.Net.Sockets.SocketType" Usage="System.Net.Sockets.Socket.SocketType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> の型を取得します。</summary>
        <value><see cref="T:System.Net.Sockets.SocketType" /> 値のいずれか 1 つ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SocketType%2A>は読み取り専用で、 <xref:System.Net.Sockets.Socket>が作成されるときに設定されます。  
  
   
  
## Examples  
 次のコード例では<xref:System.Net.Sockets.AddressFamily>、 <xref:System.Net.Sockets.SocketType>、、 <xref:System.Net.Sockets.ProtocolType>およびをコンソールに表示します。  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use OSSupportsIPv4 instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のホストで IPv4 サポートが使用可能で有効になっているかどうかを示す値を取得します。</summary>
        <value>現在のホストが IPv4 プロトコルをサポートしている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 オペレーティングシステムは、IPv4 プロトコルと IPv6 プロトコルの両方をサポートしている場合があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use OSSupportsIPv6 instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>互換性のために残されている特定の <see cref="T:System.Net.Dns" /> メンバー向けに、フレームワークが IPv6 をサポートしているかどうかを示す値を取得します。</summary>
        <value>互換性のために残されている特定の <see cref="T:System.Net.Dns" /> メソッド向けに、フレームワークが IPv6 をサポートしている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 オペレーティングシステムは、IPv4 プロトコルと IPv6 プロトコルの両方をサポートしている場合があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> によって使用されているすべてのリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
の使用が終了したら、 <xref:System.Net.Sockets.Socket>IDisposable. Dispose を呼び出します。 IDisposable メソッドは、を<xref:System.Net.Sockets.Socket>使用できない状態のままにします。 IDisposable を呼び出した後、に対する<xref:System.Net.Sockets.Socket>すべての参照を解放して、が占有し<xref:System.Net.Sockets.Socket>ていたメモリをガベージコレクターが再利用できるようにする必要があります。 詳細については、[アンマネージ リソースのクリーンアップ](~/docs/standard/garbage-collection/unmanaged.md)および[Dispose メソッドの実装](~/docs/standard/garbage-collection/implementing-dispose.md)を参照してください。

> [!NOTE] 
> への最後の参照を解放する前に、 <xref:System.Net.Sockets.Socket>常に IDisposable. Dispose を呼び出してください。 そうしないと、ガベージ コレクターが <xref:System.Net.Sockets.Socket> オブジェクトの `Finalize` メソッドを呼び出すまで、使用されているリソースは解放されません。

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="Ttl">
      <MemberSignature Language="C#" Value="public short Ttl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 Ttl" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Ttl" />
      <MemberSignature Language="VB.NET" Value="Public Property Ttl As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short Ttl { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.Ttl : int16 with get, set" Usage="System.Net.Sockets.Socket.Ttl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> によって送信されたインターネット プロトコル (IP) パケットの有効期間 (TTL) の値を指定する値を取得または設定します。</summary>
        <value>TTL の値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 TTL 値は、ルーターがパケットを破棄する前にパケットが通過できるルーターの最大数を示します。 ICMP (インターネット制御メッセージプロトコル) エラーメッセージが送信側に返されます。  
  
 TTL 値は 0 ~ 255 の値に設定できます。 このプロパティが設定されていない場合、ソケットの既定の TTL 値は32です。  
  
 ソケットを使用して接続が正常に確立されている場合、TCP/IP スタックでは、伝送制御プロトコル (TCP) ソケットでこのプロパティを設定することは無視されます。  
  
 を<xref:System.Net.Sockets.SocketException>受け取った場合は、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
   
  
## Examples  
 次のコード例は、 <xref:System.Net.Sockets.Socket.Ttl%2A>プロパティの使用方法を示しています。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">TTL 値には、負の数を設定できません。</exception>
        <exception cref="T:System.NotSupportedException">このプロパティは、<see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> ファミリまたは <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> ファミリのソケットに対してだけ設定できます。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 このエラーは、TTL に 255 より大きい値を設定しようとしたときにも返されます。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="UseOnlyOverlappedIO">
      <MemberSignature Language="C#" Value="public bool UseOnlyOverlappedIO { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseOnlyOverlappedIO" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberSignature Language="VB.NET" Value="Public Property UseOnlyOverlappedIO As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseOnlyOverlappedIO { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseOnlyOverlappedIO : bool with get, set" Usage="System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("This doesn't do anything on Mono yet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ソケットが重複 I/O モードだけを使用する必要があるかどうかを指定します。</summary>
        <value><see cref="T:System.Net.Sockets.Socket" /> が重複 I/O モードだけを使用する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 を呼び出す`true` <xref:System.Net.Sockets.Socket>には、このプロパティをに設定します。<xref:System.Net.Sockets.Socket.DuplicateAndClose%2A> それ以外の場合、フレームワークは、ソケットに完了ポートを割り当てることができます。 <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>これにより、の使用が禁止されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">ソケットが完了ポートにバインドされています。</exception>
      </Docs>
    </Member>
  </Members>
</Type>